# 数据结构与算法
## 知识点梳理
* 基本概念，算法效率，时间复杂度，空间复杂度
* 熟悉的查找算法有哪些（二分查找）
* 熟悉的排序算法有哪些（冒泡排序）
* 一些基本数据结构的实现
* 


## 为什么重写equals方法都需要重写hashcode
在实际开发中，只重写equals方法不重写hashcode 方法可能导致equals方法返回true而hashcode的值却不同，而在集合如hashMap、HashSet中判断集合中是否存在某个对象是根据对象的hashcode值来判断的，
如果只写equals方法，可能导致hashcode不同，可能导致类无法与散列集合一起工作


## 查找算法
### 衡量算法的好坏
时间复杂度： 衡量算法执行时间随着数据规模增大而增加的时间成本
渐近上界 O(g(n)):标识最差情况下的时间复杂度

空间复杂度： 衡量一个算法随着数据规模增大而占用的额外空间成本，也是使用O(g(n))来进行衡量


### 二分查找
#### 代码实现
版本一代码实现(左闭右闭边界)
注意的点：
1. i <= j 判断必须是 <= ,不能用< ,否则会出现漏判的情况
2. int m = (i + j) >>> 1; 这里使用无符号右移保证操作过程中不会出现溢出，可以看成除2向下取整，无符号右移可以在其他语言中通用

```java
    /**
     *
     * @param arr 升序排列的数组
     * @param target 查找的值
     * @return 返回查找到的值的索引
     */
    public static int binarySearchBasic(int[] arr, int target){
        //设置指针
        int i = 0,j = arr.length -1;
        while (i <= j){
            //当j的值是整数的最大值，有可能出现溢出而导致j的m的值不准确
//            int m = (i + j) /2;
            //这里使用无符号右移保证操作过程中不会出现溢出，可以看成除2向下取整，无符号右移可以在其他语言中通用
            int m = (i + j) >>> 1;
            if(target < arr[m]){ //目标在左边
                j = m-1;
            }else if(arr[m] < target){ //目标在右边
                i = m+1;
            }else{
                return m; //找到了
            }
        }
        return -1;
    }
```



版本二代码实现（左闭右开边界）
```java
    /**
     * 二分查找版本2
     * @param arr
     * @param target
     * @return
     */
    public static int binarySearchBasic2(int[] arr, int target){
        //设置指针
        int i = 0,j = arr.length; //j设置成数组长度
        while (i < j){ //不使用等于号
            //当j的值是整数的最大值，有可能出现溢出而导致j的m的值不准确
//            int m = (i + j) /2;
            //这里使用无符号右移保证操作过程中不会出现溢出，可以看成除2向下取整
            int m = (i + j) >>> 1;
            if(target < arr[m]){ //目标在左边
                j = m;
            }else if(arr[m] < target){ //目标在右边
                i = m+1;
            }else{
                return m; //找到了
            }
        }
        return -1;
    }
```
前两个版本的重复元素问题：当查找到第一个重复元素时，就返回该元素（注意，是循环遇到的第一个元素）


版本三代码实现，进一步缩小时间复杂度，减少循环内的比较次数，缺点：当target恰好在第一次循环时的m处，则需要等待所有的循环走完才能跳出循环

```java
    public static int binarySearchBasic3(int[] arr, int target) {
        //设置指针
        int i = 0, j = arr.length; //j设置成数组长度
        while (1 < j - i) { //不使用等于号
            int m = (i + j) >>> 1;
            if (target < arr[m]) { //目标在左边
                j = m;
            } else  { //目标在右边或者就在m处
                i = m;
            }
        }
        //当最后范围缩小到一个元素时，如果匹配上则返回i
        if(arr[i] ==target){
            return i;
        }
        return -1;
    }
```

在版本一的基础上返回重复元素最左侧的重复元素

```java
    /**
     * 被查找元素出现重复时，返回左侧的第一个重复元素
     * @param arr
     * @param target
     * @return
     */
    public static int binarySearchBasicLeftMost(int[] arr, int target) {
        //设置指针
        int i = 0, j = arr.length - 1;
        int candidate = -1;
        while (i <= j) {
            //这里使用无符号右移保证操作过程中不会出现溢出，可以看成除2向下取整
            int m = (i + j) >>> 1;
            if (target < arr[m]) { //目标在左边
                j = m - 1;
            } else if (arr[m] < target) { //目标在右边
                i = m + 1;
            } else {
                candidate = m;
                //缩小边界,继续查找最左侧的重复目标值
                j = m -1;
            }
        }
        return candidate;
    }
```

在版本一的基础上返回重复元素最右侧的重复元素
```java
    /**
     * 被查找元素出现重复时，返回右侧的第一个重复元素
     * @param arr
     * @param target
     * @return
     */
    public static int binarySearchBasicRightMost(int[] arr, int target) {
        //设置指针
        int i = 0, j = arr.length - 1;
        int candidate = -1;
        while (i <= j) {
            //这里使用无符号右移保证操作过程中不会出现溢出，可以看成除2向下取整
            int m = (i + j) >>> 1;
            if (target < arr[m]) { //目标在左边
                j = m - 1;
            } else if (arr[m] < target) { //目标在右边
                i = m + 1;
            } else {
                candidate = m;
                //缩小边界
                i = m + 1;
            }
        }
        return candidate;
    }
```

在leftmost的基础上找不到元素时返回有实际意义的值(返回i)
```java

    /**
     * 被查找元素出现重复时，返回左侧的第一个重复元素,查找不到时返回有意义的值
     * 当找到时返回指定的index，当找不到时，返回比目标小的最左侧的索引位置
     * @param arr [1,3,5,6,8]
     * @param target  5
     * @return
     */
    public static int binarySearchBasicLeftMost2(int[] arr, int target) {
        //设置指针
        int i = 0, j = arr.length - 1;
        while (i <= j) {
            //这里使用无符号右移保证操作过程中不会出现溢出，可以看成除2向下取整
            int m = (i + j) >>> 1;
            if (target <= arr[m]) { //目标在左边
                j = m - 1;
            } else {
                i = m + 1;
            }
        }
        return i;
    }
```
实际应用：
查找小于目标的所有元素，由于binarySearchBasicLeftMost2返回的是目标的索引或比目标大的最左侧的索引，所以，可以查找所有 arr[i] < target的元素
查找大于等于目标的所有元素


在rightmost的基础上找不到元素时返回有实际意义的值(返回i-1)
```java
    /**
     * 被查找元素出现重复时，返回右侧的第一个重复元素,找不到时返回具体含义的值
     * @param arr
     * @param target
     * @return 找到时返回索引，找到时返回最右的索引，当找不到时，返回比目标小的最靠右的元素
     */
    public static int binarySearchBasicRightMost2(int[] arr, int target) {
        //设置指针
        int i = 0, j = arr.length - 1;
        while (i <= j) {
            //这里使用无符号右移保证操作过程中不会出现溢出，可以看成除2向下取整
            int m = (i + j) >>> 1;
            if (target < arr[m]) { //目标在左边
                j = m - 1;
            } else  { //目标在右边
                i = m + 1;
            }
        }
        return (i -1);
    }
```
实际应用：查找小于等于目标的所有元素，查找大于目标的所有元素

查找数组中第一个和最后一个目标元素位置




二分查找的性能：
时间复杂度： O（log2(n)）
空间复杂度： O（1）


#### java中二分查找的实现
Arrays.binarySearch(int[] a,int key): 当找不到时，返回-（insertion + 1）,即插入点 + 1的负值

## 数组
数组是由一组元素构成的数据结构，每个元素至少有一个索引或键来标识

java中的动态数组ArrayList

基本操作：
插入元素
删除元素
扩容功能

代码实现：
```java
public class DynamicArray implements Iterable<Integer>{

    /**
     * 数组的逻辑大小
     */
    private int size = 0;

    /**
     * 容量
     */
    private int capacity = 8;

    private int[] array = new int[capacity];

    public int get(int index ){
        if(index > size -1){
            throw new ArrayIndexOutOfBoundsException();
        }
        return array[index];
    }

    /**
     * 尾部添加
     * @param element
     */
    public void addLast(int element){
        add(size,element);
    }

    /**
     * 插入指定位置
     * @param index
     * @param element
     */
    public void add(int index,int element){
        //划定边界
        if(index >= 0 && index <size){
            //拷贝后面的元素
            System.arraycopy(array,index,array,index + 1,size - index);
        }else{
            throw new ArrayIndexOutOfBoundsException();
        }
        array[index] = element;
        size ++;
    }
     /**
     * 遍历元素，提供函数式编程方式
     */
    public void forEach1(Consumer<Integer> consumer){
        for (int i = 0; i < size; i++) {
            consumer.accept(array[i]);
        }
    }

    /**
     * 迭代器遍历
     * @return
     */
    @Override
    public Iterator<Integer> iterator() {

        return new Iterator<Integer>() {
            int i = 0;
            @Override
            public boolean hasNext() {
                return i < size;
            }

            @Override
            public Integer next() {
                return array[i++];
            }
        };
    }

    /**
     * 使用流进行遍历
     * @return
     */
    public IntStream stream(){
        //使用流处理方式遍历
        return IntStream.of(Arrays.copyOfRange(array,0,size));
    }
}

    /**
     * 删除元素
     * @param index
     * @return
     */
    public int remove(int index){
        //todo 判断index的合法性
        //....
        int removed = array[index];
        //不是最后一个元素时才移动操作
        if(index < size -1){
            System.arraycopy(array,index + 1,array,index,size-index-1);
        }
        size--;
        return removed;
    }
```

### 链表
数据元素的线性集合，每个元素都指向另一个元素，元素存储上并不连续
单向链表
双向链表
循环链表

链表内的哨兵节点（sentinel） 也叫哑元节点（dummy ）

链表随机访问性能比数组随机访问速度慢
链表的插入速度比数组快，不需要移动数据

#### 单向链表，不带哨兵的情况
需要判断链表为空边界条件
```java
package com.steven.dataalg.linkedlist;

import java.util.Iterator;
import java.util.function.Consumer;

/**
 * @Description: 单向列表
 * @CreateDate: Created in 2023/7/24 12:51
 * @Author: lijie3
 */
public class SingleLinkedList implements Iterable<Integer> {

    /**
     * 头指针
     */
    private Node head;

    /**
     * 在头部添加新节点
     *
     * @param value
     */
    public void addFirst(int value) {
        //1.链表为空的情况
//         head = new Node(value, null);

        //2.链表非空、为空的情况，都能处理
        head = new Node(value, head);
    }

    /**
     * 遍历链表
     */
    public void loop1(Consumer<Integer> consumer) {

        Node p = head;
        while (p.next != null) {
//            System.out.println(p.getValue());
            consumer.accept(p.getValue());
            p = p.getNext();
        }

    }

    /**
     * 使用for循环实现链表遍历
     *
     * @param consumer
     */
    public void loop2(Consumer<Integer> consumer) {
        for (Node p = head; p != null; p = p.getNext()) {
            consumer.accept(p.getValue());
        }
    }

    /**
     * 递归遍历
     */
    public void loop3(Consumer<Integer> before,Consumer<Integer> after){
        recursion(head,before,after);
    }

    //某个节点要进行的操作
    private void recursion(Node curr, Consumer<Integer> before, Consumer<Integer> after){
        if(curr == null){
            return;
        }
        //类似于spring中的aop
        before.accept(curr.value);
        recursion(curr.next, before, after);
        after.accept(curr.value);
    }


    /**
     * 使用迭代器遍历
     *
     * @return
     */
    @Override
    public Iterator<Integer> iterator() {
        //匿名内部类
        return new Iterator<Integer>() {
            Node p = head;

            //是否包含下一个元素
            @Override
            public boolean hasNext() {
                return p != null;
            }

            //获取下一个指针的值
            @Override
            public Integer next() {
                int v = p.getValue();
                p = p.getNext();
                return v;
            }
        };
    }

    /**
     * 查找最后一个节点
     *
     * @return
     */
    private Node findLast() {
        if (head == null) {
            return null;
        }
        Node p;
        for (p = head; p.next != null; p = p.next) {

        }
        return p;
    }

    /**
     * 尾部添加
     *
     * @param value
     */
    public void addLast(int value) {
        Node last = findLast();
        //空链表相当于头部添加
        if (last == null) {
            addFirst(value);
            return;
        }
        last.next = new Node(value, null);
    }

    /**
     * 根据索引取node
     */
    private Node findNode(int index) {
        int i = 0;
        for (Node p = head; p != null; p = p.next, i++) {
            if (i == index) {
                return p;
            }
        }
        return null;
    }

    /**
     * 根据索引查找数据
     *
     * @param index
     * @return
     */
    public int get(int index) {
        Node node = findNode(index);
        if (node == null) {
            throw illlegalIndex(index);
        }
        return node.getValue();
    }

    /**
     * 异常抽取
     * @param index
     * @return
     */
    private IllegalArgumentException illlegalIndex(int index) {
        return new IllegalArgumentException(String.format("index [%d] is illegal%n", index));
    }

    /**
     * 向指定索引位置插入元素
     */
    public void insert(int index, int value) {
        if(index == 0){
            addFirst(value);
            return;
        }
        //查找上一个节点的位置
        Node prev = findNode(index - 1);
        if (prev == null) {
            throw illlegalIndex(index);
        }
        prev.next = new Node(value, prev.getNext());
    }

    /**
     * 删除节点
     * @param
     */
    public void removeFirst(){
        if(head == null){
            throw illlegalIndex(0);
        }
        head = head.next;
    }

    /**
     * 删除指定index的节点
     * @param index
     */
    public void remove(int index){
        if(index == 0){
            removeFirst();
            return;
        }
        //查找上个节点
        Node prev = findNode(index - 1);
        if(prev == null){
            throw illlegalIndex(index);
        }
        //要删除的节点
        Node removed = prev.next;
        if(removed == null){
            throw illlegalIndex(index);
        }
        prev.next = removed.next;
    }

    /**
     * 节点类，内部类，对外隐藏底层信息，当内部类使用了外部类的成员变量时，不能使用static修饰内部类，如果能加static尽量加上
     */
    private static class Node {
        //值
        private int value;
        //下一个节点
        private Node next;

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }

        public int getValue() {
            return value;
        }

        public void setValue(int value) {
            this.value = value;
        }

        public Node getNext() {
            return next;
        }

        public void setNext(Node next) {
            this.next = next;
        }
    }

}
```
单向链表，带哨兵的情况（哨兵的作用就是为了简化链表操作中的空链表判断以及索引0位置的节点判断）
```java
package com.steven.dataalg.linkedlist;

import java.util.Iterator;
import java.util.function.Consumer;

/**
 * @Description: 单向列表,带哨兵，简化代码,避免空链表，index=0的特殊情况判断
 * @CreateDate: Created in 2023/7/24 12:51
 * @Author: lijie3
 */
public class SingleLinkedSentinelList implements Iterable<Integer> {

    /**
     * 头指针,将头指针指向哨兵
     */
    private Node head = new Node(666,null);

    /**
     * 在头部添加新节点
     *
     * @param value
     */
    public void addFirst(int value) {
       //直接调用insert方法
        insert(0,value);
    }

    /**
     * while遍历链表
     */
    public void loop1(Consumer<Integer> consumer) {

        Node p = head.next;
        while (p.next != null) {
//            System.out.println(p.getValue());
            consumer.accept(p.getValue());
            p = p.getNext();
        }

    }

    /**
     * 使用for循环实现链表遍历
     *
     * @param consumer
     */
    public void loop2(Consumer<Integer> consumer) {
        for (Node p = head.next; p != null; p = p.getNext()) {
            consumer.accept(p.getValue());
        }
    }

    /**
     * 使用迭代器遍历
     *
     * @return
     */
    @Override
    public Iterator<Integer> iterator() {
        //匿名内部类
        return new Iterator<Integer>() {
            //从哨兵之后的一个节点开始遍历
            Node p = head.next;

            //是否包含下一个元素
            @Override
            public boolean hasNext() {
                return p != null;
            }

            //获取下一个指针的值
            @Override
            public Integer next() {
                int v = p.getValue();
                p = p.getNext();
                return v;
            }
        };
    }

    /**
     * 查找最后一个节点
     *
     * @return
     */
    private Node findLast() {
        if (head == null) {
            return null;
        }
        Node p;
        for (p = head; p.next != null; p = p.next) {

        }
        return p;
    }

    /**
     * 尾部添加
     *
     * @param value
     */
    public void addLast(int value) {
        //存在哨兵，last不可能为空
        Node last = findLast();
        last.next = new Node(value, null);
    }

    /**
     * 根据索引取node
     */
    private Node findNode(int index) {
        int i = -1;
        //从哨兵下一个节点开始查找
        for (Node p = head; p != null; p = p.next, i++) {
            if (i == index) {
                return p;
            }
        }
        return null;
    }

    /**
     * 根据索引查找数据
     *
     * @param index
     * @return
     */
    public int get(int index) {
        Node node = findNode(index);
        if (node == null) {
            throw illlegalIndex(index);
        }
        return node.getValue();
    }

    /**
     * 异常抽取
     * @param index
     * @return
     */
    private IllegalArgumentException illlegalIndex(int index) {
        return new IllegalArgumentException(String.format("index [%d] is illegal%n", index));
    }

    /**
     * 向指定索引位置插入元素
     */
    public void insert(int index, int value) {
        //不需要对索引0进行特殊处理
//        if(index == 0){
//            addFirst(value);
//            return;
//        }
        //查找上一个节点的位置
        Node prev = findNode(index - 1);
        if (prev == null) {
            throw illlegalIndex(index);
        }
        prev.next = new Node(value, prev.getNext());
    }

    /**
     * 删除节点
     * @param
     */
    public void removeFirst(){
        //删除第一个节点，不需要考虑空链表的情况
        remove(0);
    }

    /**
     * 删除指定index的节点
     * @param index
     */
    public void remove(int index){
        //加入哨兵不需要考虑索引0位置
//        if(index == 0){
//            removeFirst();
//            return;
//        }
        //查找上个节点
        Node prev = findNode(index - 1);
        if(prev == null){
            throw illlegalIndex(index);
        }
        //要删除的节点
        Node removed = prev.next;
        if(removed == null){
            throw illlegalIndex(index);
        }
        prev.next = removed.next;
    }

    /**
     * 节点类，内部类，对外隐藏底层信息，当内部类使用了外部类的成员变量时，不能使用static修饰内部类，如果能加static尽量加上
     */
    private static class Node {
        //值
        private int value;
        //下一个节点
        private Node next;

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }

        public int getValue() {
            return value;
        }

        public void setValue(int value) {
            this.value = value;
        }

        public Node getNext() {
            return next;
        }

        public void setNext(Node next) {
            this.next = next;
        }
    }

}
```

双向链表，带哨兵实现
```java
package com.steven.dataalg.linkedlist;

import java.util.Iterator;

/**
 * @Description: 带哨兵的双向链表
 * @CreateDate: Created in 2023/7/25 09:28
 * @Author: lijie3
 */
public class DoublySentinelLinkedList implements Iterable<Integer>{
    static class Node{
        Node prev; //上一个节点指针
        Node next; //下一个节点指针
        int value;//值

        public Node(Node prev, int value,Node next) {
            this.prev = prev;
            this.next = next;
            this.value = value;
        }
    }

    private Node head; //头哨兵

    private Node tail; //尾哨兵

    public DoublySentinelLinkedList() {

        head = new Node(null,666,null);
        tail = new Node(null,888,null);
        //初始情况
        head.next = tail;
        tail.prev = head;
    }

    /**
     * 根据索引位置查找节点
     * @param index
     * @return
     */
    private Node findNode(int index){
        int i = -1;
        for(Node p = head;p != tail;p = p.next,i++){
            if(i == index){
                return p;
            }
        }
        return null;
    }

    public void insert(int index,int value){
        Node prev = findNode(index-1);
        if(prev == null){
            throw illegalIndex(index);
        }
        Node next = prev.next;
        //指针切换
        Node inserted = new Node(prev,value,next);
        prev.next = inserted;
        next.prev = inserted;
    }

    /**
     * 删除元素
     * @param index
     */
    public void remove(int index){
        Node prev = findNode(index - 1);
        if(prev == null){
            throw illegalIndex(index);
        }
        Node removed = prev.next;
        if(removed == tail){
            throw illegalIndex(index);
        }
        Node next = removed.next;
        prev.next= next;
        next.prev = prev;
    }

    /**
     * 在尾部加上一个节点
     * @param value
     */
    public void addLast(int value){
        //查找最后一个节点
         Node last = tail.prev;
         Node added = new Node(last, value, tail);
         last.next = added;
         tail.prev= added;

    }

    /**
     * 删除最后一个节点
     */
    public void removeLast(){
        Node removed = tail.prev;
        if(removed == head){
            throw illegalIndex(0);
        }
        Node prev = removed.prev;
        prev.next = tail;
        tail.prev = prev;
    }


    /**
     * 迭代器遍历
     * @return
     */
    @Override
    public Iterator<Integer> iterator() {

        return new Iterator<Integer>() {
            Node p = head.next;
            @Override
            public boolean hasNext() {

                return p != tail;
            }

            @Override
            public Integer next() {
                int value = p.value;
                p = p.next;
                return value;
            }
        };
    }

    /**
     * 异常抽取
     * @param index
     * @return
     */
    private IllegalArgumentException illegalIndex(int index) {
        return new IllegalArgumentException(String.format("index [%d] is illegal%n", index));
    }
}

```

双向循环链表代码实现
```java
package com.steven.dataalg.linkedlist;

import java.util.Iterator;

/**
 * @Description: 带哨兵的环形链表
 * @CreateDate: Created in 2023/7/25 21:13
 * @Author: lijie3
 */
public class CircleSentinelDoublyLinkedList implements Iterable<Integer>{

    private static class Node{
        Node prev;
        int value;
        Node next;

        public Node(Node prev, int value, Node next) {
            this.prev = prev;
            this.value = value;
            this.next = next;
        }
    }

    private Node sentinel = new Node(null,-1,null);

    public CircleSentinelDoublyLinkedList() {
        //哨兵的前后指针都指向自己
        sentinel.prev = sentinel;
        sentinel.next = sentinel;
    }

    /**
     * 在第一个位置添加节点
     * @param value
     */
    public void addFirst(int value){
        //涉及到四个指针
//        哨兵
        Node a = sentinel;
        //原来的第一个元素
        Node b = sentinel.next;
        Node added = new Node(a, value, b);
        //指针切换
        a.next = added;
        b.prev = added;
    }

    /**
     * 在最后添加一个元素
     * @param value
     */
    public void addLast(int value){
        Node a = sentinel.prev;
        Node b = sentinel;
        Node added = new Node(a,value,b);
        a.prev = added;
        b.next = added;
    }

    /**
     * 移除第一个元素
     */
    public void removeFirst(){
        Node removed = sentinel.next;
        if(removed== sentinel){
            throw new  IllegalArgumentException("非法");
        }
        Node a= sentinel;
        Node b = removed.next;
        a.next = b;
        b.prev = a;
    }

    /**
     * 删除最后一个节点
     */
    public void removeLast(){
        Node removed = sentinel.prev;
        if(removed == sentinel){
            throw new  IllegalArgumentException("非法");
        }
        Node a = removed.prev;
        Node b = sentinel;
        a.next = b;
        b.prev = a;
    }

    /**
     * 根据值删除
     * @param value
     */
    public void removeByValue(int value){
        Node removed = findByValue(value);
        //未找到
        if(removed == null){
            return;
        }
        //修改指针
         Node a = removed.prev;
         Node b = removed.next;
         a.next = b;
         b.prev = a;
    }

    private Node findByValue(int value){
        Node p= sentinel.next;
        while (p != sentinel){
            if(p.value == value){
                return p;
            }
            p = p.next;
        }
        return null;
    }

    @Override
    public Iterator<Integer> iterator() {
        return new Iterator<Integer>() {
            Node p = sentinel.next;
            @Override
            public boolean hasNext() {
                return p != sentinel;
            }

            @Override
            public Integer next() {
                int value = p.value;
                p = p.next;
                return value;
            }
        };
    }
}

```


## 递归
解决同一类问题，递归过程中数据会持续缩减，必须有一个递归的出口
求n的阶层

```java
/**
 * @Description: 使用递归求 n!
 * @CreateDate: Created in 2023/7/25 22:01
 * @Author: lijie3
 */
public class Factorial {

    public static int f(int n){
        if(n == 1){
            return 1;
        }
        return n * f(n-1);
    }

    public static void main(String[] args) {
        System.out.println(f(5));
    }
}
```

反向打印字符串
```java

/**
 * @Description: 递归实现字符串的逆序打印
 * @CreateDate: Created in 2023/7/25 22:06
 * @Author: lijie3
 */
public class ReversePrintString {

    public static void f(int n,String str){
        if(n ==str.length()){
            return;
        }
        f(n+1,str);
        //打印放在递归之后
        System.out.println(str.charAt(n));
    }

    public static void main(String[] args) {
        f(0,"abc");
    }
}

```

递归版本二分查找
```java
/**
 * @Description: 递归的二分查找
 * @CreateDate: Created in 2023/7/25 22:24
 * @Author: lijie3
 */
public class BinarySearch {

    public static int search(int[] a,int target){
        return f(a,target,0,a.length-1);
    }
    private static int f(int[] a,int target, int i,int j){
        if(i > j){
            return  -1;
        }
        //取中间值
        int m = (i + j) >>>1;
        if(target < a[m]){ //在左侧
            return f(a,target,i,m-1);
        }else if( a[m] < target){
            return f(a,target,m+1,j);
        }else{
            return m;
        }
    }

    public static void main(String[] args) {
         int[] a = {1,2,4,5,6,7,78,123};
        System.out.println(search(a,5));
    }
}
```
递归冒泡排序
基础版本冒泡
```java
/**
 * @Description: 递归实现冒泡排序
 * @CreateDate: Created in 2023/7/25 23:10
 * @Author: lijie3
 */
public class BubbleSort {

    public static void sort(int[] a){
        bubble(a, a.length-1);
    }

    /**
     * 递归函数，将最大值交换到最后
     * @param a
     * @param j
     */
    public static void bubble(int[] a,int j){
        if(j == 0){
            return;
        }
        for (int i = 0; i < j; i++) {
            if(a[i] > a[i + 1]){
                int t = a[i];
                a[i] = a[i+1];
                a[i+1] = t;
            }
        }
        bubble(a,j-1);
    }

    public static void main(String[] args) {
        int[] a = {3412,344,23,57,123,6546423,234235,4564,23423};
        sort(a);
        for (int i : a) {
            System.out.print(i + " ");
        }
    }
}
```
引入未排序边界的优化冒泡版本
```java
/**
 * @Description: 递归实现冒泡排序,改进版，引入未排序的边界
 * @CreateDate: Created in 2023/7/25 23:10
 * @Author: lijie3
 */
public class BubbleSort2 {

    public static void sort(int[] a){
        bubble(a, a.length-1);
    }

    /**
     * 递归函数，将最大值交换到最后
     * @param a
     * @param j
     */
    public static void bubble(int[] a,int j){
        if(j == 0){
            return;
        }
        //设置未排序的边界x
        int x = 0;
        for (int i = 0; i < j; i++) {
            if(a[i] > a[i + 1]){
                int t = a[i];
                a[i] = a[i+1];
                a[i+1] = t;
                x = i;
            }
        }
        //在递归时，x左边的是未排序的子序列
        bubble(a,x);
    }

    public static void main(String[] args) {
        int[] a = {3412,344,23,57,123,6546423,234235,4564,23423};
        sort(a);
        for (int i : a) {
            System.out.print(i + " ");
        }
    }
}
```

递归实现插入排序
```java
/**
 * @Description: 递归实现插入排序
 * @CreateDate: Created in 2023/7/26 08:40
 * @Author: lijie3
 */
public class InsertionSort {

    public static void sort(int[] a){
        insertion(a,1);
    }

    private static void insertion(int[] a ,int low){
        if(low == a.length){
            return;
        }
        int t = a[low];
        //已排序区域指针
        int i = low - 1;
//        从右向左找，如果找到比t小的第一个值，在其后面插入
        while(i >= 0 &&  a[i] > t){ //没有找到插入位置
            a[i + 1] = a[i];
            i --;
        }
        //找到插入位置,进行赋值,当找到的的i = -1时，则在索引0位置插入
        //当需要移动时才插入
        if(i+1 != low){
            a[i+1] = t;
        }
        insertion(a,low +1);
    }
    public static void main(String[] args) {
        int[] a = {3412,344,23,57,123,6546423,234235,4564,23423};
        sort(a);
        for (int i : a) {
            System.out.print(i + " ");
        }
    }
}
```

斐波那契数列递归实现,时间复杂度 O(1.618^n) 递归次数 = fin(n-1) * 2 -1
```java
public class Fibonacci {

    public static int finbonacci(int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        //多路递归
        return finbonacci(n - 1) + finbonacci(n - 2);
    }

    public static void main(String[] args) {
        // 0 1 1 2 3 5 8 13 21
        System.out.println(finbonacci(8));
    }
}
```

迭代解决兔子问题（斐波那契数列的应用）
```java
public class Fibonacci {

    public static int finbonacci(int n) {
        if (n == 1) {
            return 1;
        }
        if (n == 2) {
            return 1;
        }
        //多路递归
        return finbonacci(n - 1) + finbonacci(n - 2);
    }

    public static void main(String[] args) {
        // 0 1 1 2 3 5 8 13 21
        System.out.println(finbonacci(8));
    }
}
```
斐波那契递归优化
```java
/**
 * @Description: 斐波那契数列递归实现,优化时间复杂度，使用数组存储已经计算的前n次迭代 ，记忆法，使用备忘数组来解决重复计算的问题
 * @CreateDate: Created in 2023/7/26 08:57
 * @Author: lijie3
 */
public class Fibonacci2 {

    public static int finbonacci(int n) {
        //使用数组存储中间值
        int[] cache = new int[n+1];
        //填充初始值
        Arrays.fill(cache,-1);
        cache[0] = 0;
        cache[1] = 1;
        return f(n,cache);
    }

    public static int f(int n,int[] cache){
        if(cache[n] != -1){
            return cache[n];
        }
        //多路递归
        int x = f(n - 1,cache);
        int y = f(n - 2,cache);
        cache[n] = x + y;
        return cache[n];
    }
    public static void main(String[] args) {
        // 0 1 1 2 3 5 8 13 21
        System.out.println(finbonacci(8));
    }
}
```

递归引发的爆栈问题
递归求和，递归深度过大导致栈溢出：Exception in thread "main" java.lang.StackOverflowError
```java
public class Sum {

    public static int sum(int n){
        if(n == 1){
            return  1;
        }
        return sum(n-1) + n;
    }

    public static void main(String[] args) {
        System.out.println( sum(15000));
    }
}
```

如何解决爆栈
尾调用：在函数的最后一步是调用一个函数，一些语言的编译器能对尾调用做优化，优化后尾调用中不存在递归，内存可以及时释放
尾递归：在函数最后一步调用的函数是自己，是尾调用的一种，在scala中可以使用尾递归

使用循环解决爆栈,避免使用递归

```scala
/**
 * @Description: 使用scala中的尾递归解决爆栈问题
 * @CreateDate: Created in 2023/7/26 13:48 
 * @Author: lijie3
 */
object SumTailRec {

  def main(args: Array[String]): Unit = {
    println(sum(100,0));
  }

  @tailrec
  def sum(n:Long,accumulator:Long):Long ={
    if(n == 1){
      return  1 + accumulator;
    }
    return sum(n-1,n + accumulator)
  }

}
```

计算递归的时间复杂度
主定理：
T(n) = aT(n/b) + f(n)

aT(n/b) : 递归时间
f(n) ：递归之外的时间

上面求和函数递归不能使用主定理求解，使用展开求解，
递归求和的时间复杂度为O（n）
递归冒泡排序的时间复杂度为 O(n^2)

汉诺塔
移动一摞圆盘到另一个圆盘上

```java
/**
 * @Description: 汉诺塔移动圆盘
 * @CreateDate: Created in 2023/7/26 22:51
 * @Author: lijie3
 */
public class HanoiTower {

    //移动圆盘需要的三根柱子
    static LinkedList<Integer> a = new LinkedList<>();
    static LinkedList<Integer> b = new LinkedList<>();
    static LinkedList<Integer> c = new LinkedList<>();

    /**
     * 将圆盘从大到小依次放在a柱子上
     * @param n
     */
    static void init(int n){
        for(int i = n;i >= 1; i--){
            a.addLast(i);
        }
    }

    /**
     *
     * @param n 圆盘个数
     * @param a 原柱子
     * @param b 协助柱子
     * @param c 目标柱子
     */
    static void move(int n, LinkedList<Integer> a,LinkedList<Integer> b,LinkedList<Integer> c){
        if(n == 0){
            return;
        }
        //将n-1个圆盘从a移动到b，借助于c
        move(n-1,a,c,b);
        c.addLast(a.removeLast());
        print();
        //将n-1个圆盘从b移动到c，借助于a
        move(n-1,b,a,c);
    }

    public static void main(String[] args) {
        init(3);
        print();
        move(3,a,b,c);

    }
    private static void print() {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println("--------------------");
    }

}
```
时间复杂度： O(2^64) ，这个算法效率极低

杨辉三角
```
        1
      1    1
    1   2    1
  1   3    3   1

  1
  1 1
  1 2 1 
  1 3 3 1
```
简单实现
```java
/**
 * @Description: 递归求解杨辉三角
 * @CreateDate: Created in 2023/7/27 07:46
 * @Author: lijie3
 */
public class PascalTriangle {

    /**
     * 求第i行第j列的值
     * @param i
     * @param j
     * @return
     */
    private static int element(int i ,int j){
        if(j == 0 || i ==j){
            return 1;
        }
        return element(i -1,j-1) + element(i-1,j);
    }

    /**
     * 打印n阶杨辉三角
     * @param n
     */
    public static void print(int n){
        for (int i = 0; i < n ; i++) {
            printSpace(n,i);
            for (int j = 0; j <= i; j++) {
                System.out.printf("%-4d",element(i,j));
            }
            System.out.println();
        }
    }

    public static void printSpace(int n,int i){
        int num = (n-1-i) * 2;
        for (int j = 0; j < num; j++) {
            System.out.print(" ");
        }
    }

    public static void main(String[] args) {
       print(10);
    }
}
```
记忆法优化杨辉三角计算,使用二维数组记录
```java
/**
 * @Description: 递归求解杨辉三角,记忆法优化
 * @CreateDate: Created in 2023/7/27 07:46
 * @Author: lijie3
 */
public class PascalTriangle2 {

    /**
     * 求第i行第j列的值
     * @param i
     * @param j
     * @return
     */
    private static int element1(int[][] triange, int i ,int j){
        //每次递归进行判断，是否已经计算过对应位置的值
        if(triange[i][j] > 0){
            return triange[i][j];
        }
        if(j == 0 || i ==j){
            triange[i][j] = 1;
            return 1;
        }

        triange[i][j] = element1(triange,i -1,j-1) + element1(triange,i-1,j);
        return triange[i][j];
    }

    /**
     * 打印n阶杨辉三角
     * @param n
     */
    public static void print1(int n){
        int[][] triange = new int[n][];
        for (int i = 0; i < n ; i++) {
            triange[i] = new int[i+1];
            printSpace(n,i);
            for (int j = 0; j <= i; j++) {
                System.out.printf("%-4d",element1(triange,i,j));
            }
            System.out.println();
        }
    }

    public static void printSpace(int n,int i){
        int num = (n-1-i) * 2;
        for (int j = 0; j < num; j++) {
            System.out.print(" ");
        }
    }

    public static void main(String[] args) {
       print1(5);
//        int[][] a = new int[5][5];
//        for (int i = 0; i < 5; i++) {
//            for (int j = 0; j < 5; j++) {
//                System.out.println(a[i][j]);
//            }
//        }
    }
}
```
使用一维数组优化杨辉三角计算
```java
/**
 * @Description: 递归求解杨辉三角,记忆法优化，使用一维数组进行计算
 * @CreateDate: Created in 2023/7/27 07:46
 * @Author: lijie3
 */
public class PascalTriangle3 {


    /**
     * 使用一维数组，不存在递归，动态规划，使用前一项计算下一项
     * @param row
     * @param i
     */
    private static void createRow(int[] row,int i){
        if(i == 0){
            row[0] = 1;
            return;
        }
        for (int j = i; j > 0; j--) {
            row[j] = row[j] + row[j-1];
        }
    }

    /**
     * 打印n阶杨辉三角
     * @param n
     */
    public static void print2(int n){
        int[] row = new int[n];
        for (int i = 0; i < n ; i++) {
            createRow(row,i);
            printSpace(n,i);
            for (int j = 0; j <= i; j++) {
                System.out.printf("%-4d", row[j]);
            }
            System.out.println();
        }
    }

    public static void printSpace(int n,int i){
        int num = (n-1-i) * 2;
        for (int j = 0; j < num; j++) {
            System.out.print(" ");
        }
    }

    public static void main(String[] args) {
       print2(5);

    }
}
```

反转单项链表
1. 使用复制节点的方式实现
```java
/**
 * @Description: 单向链表反转，使用复制的方式
 * @CreateDate: Created in 2023/7/27 08:59
 * @Author: lijie3
 */
public class LinkedListReverse {

    /**
     * 使用while循环反转单向链表
     * @param o1
     * @return
     */
    public static ListNode reverseList(ListNode o1){
        ListNode n1 = null;
        ListNode p = o1;
        while ( p != null){
            n1 = new ListNode(p.val,n1);
            p = p.next;
        }
        return n1;
    }

    public static void main(String[] args) {
        ListNode o5 = new ListNode(5,null);
        ListNode o4 = new ListNode(4,o5);
        ListNode o3 = new ListNode(3,o4);
        ListNode o2 = new ListNode(2,o3);
        ListNode o1 = new ListNode(1,o2);
        print(o1);
        ListNode listNode = reverseList(o1);
        print(listNode);

    }

    static void print(ListNode node){
        ListNode p  = node;
        while ( p != null){
            System.out.print(p);
            p  = p.next;
        }
        System.out.println();
    }
}

```
2. 从原list中移除头节点，添加到新的list的头节点位置
```java
package com.steven.dataalg.recursion;

/**
 * @Description: 单向链表反转,方法2
 * @CreateDate: Created in 2023/7/27 08:59
 * @Author: lijie3
 */
public class LinkedListReverse02 {

    /**
     * 使用while循环反转单向链表
     * @param o1
     * @return
     */
    public static ListNode reverseList(ListNode head){
        List list1 = new List(head);
        List list2 = new List(null);
        while (true){
            ListNode first = list1.removeFirst();
            if(first == null){
                break;
            }
            list2.addFirst(first);
        }
        return list2.head;
    }

    static class List{
        ListNode head;

        public List(ListNode head) {
            this.head = head;
        }

        /**
         * 添加到头节点
         * @param first
         */
        public void addFirst(ListNode first){
            first.next = head;
            head = first;
        }

        /**
         * 移除头节点
         * @return
         */
        public ListNode removeFirst(){
            ListNode first = head;
            if(first != null){
                //将第二个节点作为头节点
                head = first.next;
            }
            return first;
        }
    }

    public static void main(String[] args) {
        ListNode o5 = new ListNode(5,null);
        ListNode o4 = new ListNode(4,o5);
        ListNode o3 = new ListNode(3,o4);
        ListNode o2 = new ListNode(2,o3);
        ListNode o1 = new ListNode(1,o2);
        print(o1);
        ListNode listNode = reverseList(o1);
        print(listNode);

    }

    static void print(ListNode node){
        ListNode p  = node;
        while ( p != null){
            System.out.print(p);
            p  = p.next;
        }
        System.out.println();
    }


}
```
3. 使用递归的方式实现
```java
package com.steven.dataalg.recursion;

/**
 * @Description: 单向链表反转,方式3，使用递归实现
 * @CreateDate: Created in 2023/7/27 08:59
 * @Author: lijie3
 */
public class LinkedListReverse03 {

    /**
     * 使用while循环反转单向链表
     * @param o1
     * @return
     */
    public static ListNode reverseList(ListNode p){
        //找到最后的节点
       if(p == null || p.next == null){
           return p;
       }
       ListNode last = reverseList(p.next);
       // 1-> 2 ->3 ->4 ->5
       //反转节点的指针
       p.next.next = p;
       //避免死循环
       p.next = null;
       return last;
    }


    public static void main(String[] args) {
        ListNode o5 = new ListNode(5,null);
        ListNode o4 = new ListNode(4,o5);
        ListNode o3 = new ListNode(3,o4);
        ListNode o2 = new ListNode(2,o3);
        ListNode o1 = new ListNode(1,o2);
        print(o1);
        ListNode listNode = reverseList(o1);
        print(listNode);

    }

    static void print(ListNode node){
        ListNode p  = node;
        while ( p != null){
            System.out.print(p);
            p  = p.next;
        }
        System.out.println();
    }


}
```
4. 使用两个指针，将链表的第二个节点断开，然后将这个节点移动到新的链表的头部
```java
package com.steven.dataalg.recursion;

/**
 * @Description: 单向链表反转,方式4，使用两个指针，将链表的第二个节点断开，然后将这个节点移动到新的链表的头部
 * @CreateDate: Created in 2023/7/27 08:59
 * @Author: lijie3
 */
public class LinkedListReverse04 {

    /**
     * 使用while循环反转单向链表
     * @param o1
     * @return
     */
    public static ListNode reverseList(ListNode o1){
        //边界条件
        if(o1 == null || o1.next == null){
            return o1;
        }
        //取第二个节点
        ListNode o2 = o1.next;
        //新链表的头部
        ListNode n1 = o1;
        while (o2 != null){
            // 2. 将o2 断开
            o1.next = o2.next;
            o2.next = n1;
            //切换o2为新链表的头
            n1 = o2;
            o2 = o1.next;
        }
        return n1;
    }


    public static void main(String[] args) {
        ListNode o5 = new ListNode(5,null);
        ListNode o4 = new ListNode(4,o5);
        ListNode o3 = new ListNode(3,o4);
        ListNode o2 = new ListNode(2,o3);
        ListNode o1 = new ListNode(1,o2);
        print(o1);
        ListNode listNode = reverseList(o1);
        print(listNode);

    }

    static void print(ListNode node){
        ListNode p  = node;
        while ( p != null){
            System.out.print(p);
            p  = p.next;
        }
        System.out.println();
    }
}
```
5. 与方法4类似，每次移动链表的头节点作为新链表的头节点
```java
package com.steven.dataalg.recursion;

/**
 * @Description: 单向链表反转,方式4，使用两个指针，循环将链表的第一个节点断开，然后将这个节点移动到新的链表的头部
 * @CreateDate: Created in 2023/7/27 08:59
 * @Author: lijie3
 */
public class LinkedListReverse05 {

    /**
     * 使用while循环反转单向链表
     * @param o1
     * @return
     */
    public static ListNode reverseList(ListNode o1){
        if(o1 == null || o1.next == null){
            return o1;
        }
        ListNode n1 = null;
        while(o1 != null){
            ListNode o2 = o1.next;
            o1.next = n1;
            n1 = o1;
            o1 = o2;
        }
        return n1;
    }


    public static void main(String[] args) {
        ListNode o5 = new ListNode(5,null);
        ListNode o4 = new ListNode(4,o5);
        ListNode o3 = new ListNode(3,o4);
        ListNode o2 = new ListNode(2,o3);
        ListNode o1 = new ListNode(1,o2);
        print(o1);
        ListNode listNode = reverseList(o1);
        print(listNode);

    }

    static void print(ListNode node){
        ListNode p  = node;
        while ( p != null){
            System.out.print(p);
            p  = p.next;
        }
        System.out.println();
    }


}
```
比较：
方法1:需要创建新的Node
方法2: 使用面向对象的思想来写
方法3: 使用递归，理解起来比较困难
方法4: 用一个链表模拟两个链表，移动Node
方法5: 与方法2类似，类似于面向过程

删除一个链表中的相同元素
算法1:while遍历删除
```java
package com.steven.dataalg.recursion;

/**
 * @Description: 移除链表中指定的相同元素
 * @CreateDate: Created in 2023/7/27 18:23
 * @Author: lijie3
 */
public class LinkedListRemove {
    /**
     * 删除链表指定节点
     * @param head
     * @param val
     * @return
     */
    public static ListNode removeElements(ListNode head,int val){

        //哨兵节点
        ListNode s = new ListNode(-1,head);
        ListNode p1 = s;
//        ListNode p2 = s.next;
//        while (p2 != null){
//            if(p2.val == val){
//                //删除，p2向后平移
//                p1.next = p2.next;
//                p2 = p2.next;
//
//            }else{
//                //p1 p2向后平移
//                p1 = p1.next;
//                p2 = p2.next;
//            }
//        }
        //优化版本,简化代码书写
        ListNode p2;
        while ( (p2 =p1.next) != null) {
            if (p2.val == val) {
                //删除，p2向后平移
                p1.next = p2.next;
            } else {
                //p1 p2向后平移
                p1 = p1.next;
            }
        }
        return s.next;
    }

    public static void main(String[] args) {
        ListNode o6= new ListNode(5,null);
        ListNode o5 = new ListNode(3,o6);
        ListNode o4 = new ListNode(4,o5);
        ListNode o3 = new ListNode(3,o4);
        ListNode o2 = new ListNode(2,o3);
        ListNode o1 = new ListNode(1,o2);
        print(o1);
        removeElements(o1,3);
        print(o1);
    }

    static void print(ListNode node){
        ListNode p  = node;
        while ( p != null){
            System.out.print(p);
            p  = p.next;
        }
        System.out.println();
    }
}
```
算法2:使用递归实现：
```java
package com.steven.dataalg.recursion;

/**
 * @Description: 移除链表中指定的相同元素2，使用递归实现
 * @CreateDate: Created in 2023/7/27 18:23
 * @Author: lijie3
 */
public class LinkedListRemove2 {
    public static ListNode removeElements2(ListNode p,int val){
        if(p == null){
            return null;
        }

        if(p.val == val){
            //如果相等，跳过当前元素，迭代下一个元素
            return removeElements2(p.next,val);
        }else{
           //如果不相等，将当前迭代的p的next指向下层递归之后的元素
            p.next = removeElements2(p.next,val);
            return p;
        }

    }

    public static void main(String[] args) {
        ListNode o6= new ListNode(5,null);
        ListNode o5 = new ListNode(3,o6);
        ListNode o4 = new ListNode(4,o5);
        ListNode o3 = new ListNode(3,o4);
        ListNode o2 = new ListNode(2,o3);
        ListNode o1 = new ListNode(1,o2);
        print(o1);
        removeElements2(o1,3);
        print(o1);
    }

    static void print(ListNode node){
        ListNode p  = node;
        while ( p != null){
            System.out.print(p);
            p  = p.next;
        }
        System.out.println();
    }
}

```


删除链表的倒数第n个元素
递归实现
```java

/**
 * @Description: 删除链表中的倒数第n个节点
 * @CreateDate: Created in 2023/7/27 18:23
 * @Author: lijie3
 */
public class LinkedListRemoveNthFromEnd {
    /**
     * 删除链表指定节点
     * @param head
     * @param val
     * @return
     */
    public static ListNode removeNthFromRnd(ListNode head,int n){
        //使用哨兵解决（第一个元素）的删除
        ListNode s  = new ListNode(-1,head);
        recursion(s,n);
        return head;
    }
    private static int recursion(ListNode p,int n){
        //倒数第0个节点
        if(p == null){
            return 0;
        }
        //下一个节点的倒数位置
        int nth = recursion(p.next,n);
//        System.out.println(p.val + " "+ nth);
        if(nth == n){
            //执行删除操作
            p.next = p.next.next;
        }
        //当前节点的倒数位置
        return nth+1;
    }

    public static void main(String[] args) {
        ListNode o6= new ListNode(5,null);
        ListNode o5 = new ListNode(3,o6);
        ListNode o4 = new ListNode(4,o5);
        ListNode o3 = new ListNode(3,o4);
        ListNode o2 = new ListNode(2,o3);
        ListNode o1 = new ListNode(1,o2);
        print(o1);
        removeNthFromRnd(o1,6);
        print(o1);
    }

    static void print(ListNode node){
        ListNode p  = node;
        while ( p != null){
            System.out.print(p);
            p  = p.next;
        }
        System.out.println();
    }
}
```

快慢指针法
```java
package com.steven.dataalg.recursion;

/**
 * @Description: 删除链表中的倒数第n个节点，使用快慢指针法
 * @CreateDate: Created in 2023/7/27 18:23
 * @Author: lijie3
 */
public class LinkedListRemoveNthFromEnd2 {
    /**
     * 删除链表指定节点
     *
     * @param head
     * @param val
     * @return
     */
    public static ListNode removeNthFromRnd(ListNode head, int n) {
        //使用哨兵解决（第一个元素）的删除
        ListNode s = new ListNode(-1, head);
        ListNode p1 = s;
        ListNode p2 = s;
        //将p2移动到n+1的位置
        for (int i = 0; i < n + 1; i++) {
            p2 = p2.next;
        }
        //将p1、p2同时移动，直到p2指向null，p1指向的是倒数第n+1个节点
        while (p2 != null) {
            p1 = p1.next;
            p2 = p2.next;
        }
        p1.next = p1.next.next;
        return s.next;
    }


    public static void main(String[] args) {
        ListNode o6 = new ListNode(5, null);
        ListNode o5 = new ListNode(3, o6);
        ListNode o4 = new ListNode(4, o5);
        ListNode o3 = new ListNode(3, o4);
        ListNode o2 = new ListNode(2, o3);
        ListNode o1 = new ListNode(1, o2);
        print(o1);
        ListNode head = removeNthFromRnd(o1, 6);
        print(head);
    }

    static void print(ListNode node) {
        ListNode p = node;
        while (p != null) {
            System.out.print(p);
            p = p.next;
        }
        System.out.println();
    }
}
```

删除有序链表中的重复节点
使用快慢指针法
```java
package com.steven.dataalg.leecode;

import com.steven.dataalg.recursion.ListNode;

/**
 * @Description: 删除有序链表中的重复节点,使用快慢指针法
 * @CreateDate: Created in 2023/7/27 22:31
 * @Author: lijie3
 */
public class DeleteDuplicates {

    public static ListNode deleteDuplicate(ListNode p){
        //节点数小于2
        if(p == null || p.next == null){
            return  p;
        }
        ListNode p1 = p;
        ListNode p2;
        while ((p2 = p1.next)!= null){
            if(p1.val  == p2.val){
                //删除重复
                p1.next = p2.next;
            }else{
                //向后平移
                p1 = p1.next;
            }
        }
        return p;
    }

    public static void main(String[] args) {
        ListNode o6 = new ListNode(5, null);
        ListNode o5 = new ListNode(5, o6);
        ListNode o4 = new ListNode(3, o5);
        ListNode o3 = new ListNode(3, o4);
        ListNode o2 = new ListNode(2, o3);
        ListNode o1 = new ListNode(1, o2);
        print(o1);
        ListNode head = deleteDuplicate(o1);
        print(head);
    }

    static void print(ListNode node) {
        ListNode p = node;
        while (p != null) {
            System.out.print(p);
            p = p.next;
        }
        System.out.println();
    }

}
```
有序链表去重 ---将重复元素全部去掉
使用递归实现
```java
package com.steven.dataalg.leecode;

import com.steven.dataalg.recursion.ListNode;

/**
 * @Description: 删除有序链表中的重复节点（1，1，2，3,删除后保留2，3）, 使用递归实现
 * @CreateDate: Created in 2023/7/27 22:31
 * @Author: lijie3
 */
public class DeleteDuplicates3 {

    public static ListNode deleteDuplicate(ListNode p) {
        if(p == null || p.next == null){
            return p;
        }
        if(p.val == p.next.val){
            ListNode x = p.next.next;
            while (x != null && x.val == p.val){
                x = x.next;
            }
            //当x与前面的节点不重复时，进行递归调用
            return deleteDuplicate(x);
        }else{
            p.next = deleteDuplicate(p.next);
            return p;
        }
    }

    public static void main(String[] args) {
        ListNode o6 = new ListNode(5, null);
        ListNode o5 = new ListNode(5, o6);
        ListNode o4 = new ListNode(3, o5);
        ListNode o3 = new ListNode(3, o4);
        ListNode o2 = new ListNode(2, o3);
        ListNode o1 = new ListNode(1, o2);
        print(o1);
        ListNode head = deleteDuplicate(o1);
        print(head);
    }

    static void print(ListNode node) {
        ListNode p = node;
        while (p != null) {
            System.out.print(p);
            p = p.next;
        }
        System.out.println();
    }

}
```
多个链表合并,分而治之
```java
/**
 * @Description: 合并多个List
 * @CreateDate: Created in 2023/7/31 08:37
 * @Author: lijie3
 */
public class MergeLists {

    /**
     * 合并两个List
     *
     * @param p1
     * @param p2
     * @return
     */
    public static ListNode mergerTwoLists(ListNode p1, ListNode p2) {
        //哨兵节点
        ListNode s = new ListNode(-1, null);
        ListNode p = s;
        while (p1 != null && p2 != null) {
            if (p1.val < p2.val) {
                p.next = p1;
                p1 = p1.next;
            } else {
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        if (p1 != null) {
            p.next = p1;
        }
        if (p2 != null) {
            p.next = p2;
        }
        return s.next;
    }

    public static ListNode mergeKList(ListNode[] lists) {
        if (lists.length == 0) {
            return null;
        }
        return split(lists, 0, lists.length - 1);
    }

    /**
     * 递归实现合并
     *
     * @param lists
     * @param i
     * @param j
     * @return
     */
    private static ListNode split(ListNode[] lists, int i, int j) {
        //递归结束条件
        if (i == j) {
            return lists[i];
        }
        //将数组一分为2
        int m = (i + j) >>> 1;
        ListNode left = split(lists, i, m);
        ListNode right = split(lists, m + 1, j);
        //合并左右两边
        return mergerTwoLists(left, right);
    }

    public static void main(String[] args) {
        ListNode[] lists = {
                ListNode.of(1, 4, 5),
                ListNode.of(1, 3, 4),
                ListNode.of(2, 6)
        };
        for (int i = 0; i < lists.length; i++) {
            ListNode.print(lists[i]);
        }
        ListNode m = mergeKList(lists);
        ListNode.print(m);
    }
}
```
查找链表的中间节点--使用快慢指针
```java
/**
 * @Description: 查找链表的中间节点，使用快慢指针实现
 * @CreateDate: Created in 2023/7/31 08:57
 * @Author: lijie3
 */
public class FindMiddle {

    public static ListNode findMiddle(ListNode head){
        ListNode p1 = head;

        ListNode p2 = head;

        while (p2!= null && p2.next != null){
            p1 = p1.next;
            p2 = p2.next;
            p2 = p2.next;
        }
        return p1;
    }

    public static void main(String[] args) {
        //奇数情况
        ListNode head1 = ListNode.of(1,2,3,4,5);
        System.out.println(findMiddle(head1).val);
        //偶数情况
        ListNode head2 = ListNode.of(1,2,3,4,5,6);
        System.out.println(findMiddle(head2).val);
    }
}
```
判断回文链表 --- 
首先使用快慢指针找出中间节点，然后反转后半个链表，与前半个链表进行对比
```java
package com.steven.dataalg.leecode;

import com.steven.dataalg.recursion.ListNode;

/**
 * @Description: 查找回文链表，先查找中间节点，然后反转链表
 * @CreateDate: Created in 2023/7/31 09:16
 * @Author: lijie3
 */
public class Palindrome {

    public static boolean isPalindrome(ListNode h1){
        //找到中间节点
        ListNode middle = middle(h1);
        //反转后面的列表
        ListNode h2 = reverse(middle);
        //比较是否相等
        while (h2 != null){
            if (h2.val != h1.val) {
                return false;
            }
            h1 = h1.next;
            h2 = h2.next;
        }
        return true;
    }

    /**
     * 反转链表
     * @param o1
     * @return
     */
    private static ListNode reverse(ListNode o1){
        //反转后的新的头节点
        ListNode n1 = null;
        while (o1 != null){
            ListNode o2 = o1.next;
            o1.next = n1;
            n1 = o1;
            o1 = o2;
        }
        return n1;
    }

    private static ListNode middle(ListNode head){
        ListNode p1 = head;
        ListNode p2 = head;
        while (p2 != null && p2.next != null){
            p1 = p1.next;
            p2 = p2.next;
            p2 = p2.next;
        }
        return p1;
    }

    public static void main(String[] args) {
         ListNode l1 = ListNode.of(1, 2, 3, 2, 1);
         ListNode l2 = ListNode.of(1, 2, 3,3, 2, 1,1);
        System.out.println(isPalindrome(l1));
        System.out.println(isPalindrome(l2));
    }
}
```
优化版本：在找中间节点的同事反转前半个链表
```java
package com.steven.dataalg.leecode;

import com.steven.dataalg.recursion.ListNode;

/**
 * @Description: 查找回文链表，先查找中间节点，然后反转链表，优化算法效率，反转前半个链表
 * @CreateDate: Created in 2023/7/31 09:16
 * @Author: lijie3
 */
public class Palindrome2 {

    public static boolean isPalindrome(ListNode h1){
        //找到中间节点
        ListNode p1 = h1;
        ListNode p2 = h1;
        //反转前半个链表
        //新的头节点
        ListNode n1 = null;
        //旧的头节点
        ListNode o1 = h1;
        while (p2 != null && p2.next != null){
            p1 = p1.next;
            p2 = p2.next;
            p2 = p2.next;
//            ListNode o2 = o1.next;
//            p1 = o1.next;
            o1.next = n1;
            //新链表头部
            n1 = o1;
            o1 = p1;
        }
        ListNode.print(n1);
        ListNode.print(p1);
        //处理节点数量为奇数的情况，需要将慢指针往后移动一格包含中间节点
        if(p2 != null){
            p1 = p1.next;
        }
        while (n1 != null){
            if(n1.val != p1.val){
                return false;
            }
            n1 = n1.next;
            p1 = p1.next;
        }
        return true;
    }

    public static void main(String[] args) {
         ListNode l1 = ListNode.of(1, 2, 3, 2, 1);
         ListNode l2 = ListNode.of(1, 2, 3,3, 2, 1,1);
        System.out.println(isPalindrome(l1));
        System.out.println(isPalindrome(l2));
    }
}
```

###  判断链表是否存在环，并找到环的入口
链表中存在某几个任意节点都存在下一个节点

使用龟兔赛跑的快慢指针算法，在有环的链表中，慢指针能追上快指针
```java
/**
 * @Description: 快慢指针检测链表是否有环，并确定环的入口,弗洛伊德龟兔赛跑算法
 * @CreateDate: Created in 2023/8/1 08:16
 * @Author: lijie3
 */
public class CircleLinkedList {

    /**
     * 检测是否有环
     * @param head
     * @return
     */
    public static boolean hasCycle(ListNode head){
        //快指针
        ListNode h = head;
        //慢指针
        ListNode t = head;
        while (h!= null && h.next != null){
            t = t.next;
            h = h.next.next;
            //慢指针追上了快指针
            if(h == t){
                return true;
            }
        }
        return false;
    }

    public static ListNode detectCycle(ListNode head){
        //快指针
        ListNode h = head;
        //慢指针
        ListNode t = head;
        while (h!= null && h.next != null){
            t = t.next;
            h = h.next.next;
            //慢指针追上了快指针
            if(h == t){
                t = head;
                //各走一步再相遇是环的入口
                while (true){
                    if(t == h){
                        return t;
                    }
                    t = t.next;
                    h = h.next;
                }
            }
        }
        return null;
    }

    public static void main(String[] args) {
        ListNode p = ListNode.of(1,2,3,4,5,6,7,8,9,10);
        //选择5作为入口
        ListNode enter = p.next.next.next.next;
        System.out.println(enter.val);
        ListNode end = enter.next.next.next.next.next;
        System.out.println(end.val);
//        end.next = enter;
        end.next  = p;
        //检测是否有环
        System.out.println(hasCycle(p));
        System.out.println(detectCycle(p).val);

    }
}
```
### 合并两个有序数列
方法1 ：使用递归实现
```java
public class SortedArrayMerge {

    /**
     * 使用递归可并
     * @param a1 要merge排序的数组
     * @param i  第一个有序区间的起点
     * @param iEnd  第一个有序区间的终点
     * @param j 第二个有序区间的起点
     * @param jEnd 第二个有序区间的终点
     * @param a2 要复制的目标数组
     * @param k 当前已经复制的目标数组指针
     */
    public static void merge(int[] a1,int i, int iEnd,int j,int jEnd,int[] a2,int k){
        if(i>iEnd){
            System.arraycopy(a1,j,a2,k,jEnd-j+1);
            return;
        }
        if(j > jEnd){
            System.arraycopy(a1,i,a2,k,iEnd-i+1);
            return;
        }
        if(a1[i] < a1[j]){
            a2[k] = a1[i];
            merge(a1,i+1,iEnd,j,jEnd,a2,k+1);
        }else{
            a2[k] = a1[j];
            merge(a1,i,iEnd,j+1,jEnd,a2,k+1);
        }
    }

    public static void main(String[] args) {
        int[] a1 =  {1,5,6,2,4,10,11};
        int[] a2 = new int[a1.length];
        merge(a1,0,2,3,6,a2,0);
        System.out.println(Arrays.toString(a2));
    }

}
```

方法2:使用非递归方式实现：
```java
    /**
     * 使用非递归方式实现
     * @param a1 要merge排序的数组
     * @param i  第一个有序区间的起点
     * @param iEnd  第一个有序区间的终点
     * @param j 第二个有序区间的起点
     * @param jEnd 第二个有序区间的终点
     * @param a2 要复制的目标数组
     */
    public static void merge2(int[] a1,int i, int iEnd,int j,int jEnd,int[] a2){
        int k= 0;
        while(i <=iEnd && j <=jEnd){
            if(a1[i] < a1[j]){
                a2[k] = a1[i];
                i++;
            }else{
                a2[k] = a1[j];
                j++;
            }
            k++;
            if (i > iEnd) {
                System.arraycopy(a1,j,a2,k,jEnd-j+1);
            }
            if(j >jEnd){
                System.arraycopy(a1,i,a2,k,iEnd-i+1);
            }
        }
    }
```

### 队列
以顺序的的方式维护一组数据集合，在一端添加数据（头），在另一个移除数据（尾）
队列接口定义
```java
package com.steven.dataalg.queue;

/**
 * @Description: 队列抽象接口
 * @CreateDate: Created in 2023/8/1 08:53
 * @Author: lijie3
 */
public interface Queue<E> {

    /**
     * 队尾插入元素
     * @param value
     * @return
     */
    boolean offer(E value);

    /**
     * 从队列头部获取值
     * @return
     */
    E poll();

    /**
     * 从队列头获取值，不删除
     * @return
     */
    E peek();

    /**
     * 检查是否为空
     * @return
     */
    boolean isEmpty();

    /**
     * 判断队列是否已满
     * @return
     */
    boolean isFull();
}

```
使用带哨兵的单向循环链表实现队列
```java
package com.steven.dataalg.queue;

import java.util.Iterator;

/**
 * @Description: 单向环形带哨兵链表方式来实现列表,控制队列容量
 * @CreateDate: Created in 2023/8/1 08:58
 * @Author: lijie3
 */
public class LinkedListQueue<E> implements Queue<E>,Iterable<E>{

    private static class Node<E>{
        E value;
        Node<E> next;

        public Node(E value, Node<E> next) {
            this.value = value;
            this.next = next;
        }
    }



    //哨兵节点
    Node<E> head = new Node<>(null,null);
    Node<E> tail = head;
    //节点数
    private int size;
//   设置容量
    private int capacity = Integer.MAX_VALUE;

    //头尾节点初始化，都指向哨兵
    {
        tail.next = head;
    }

    /**
     * 循环单向链表
     */
    public LinkedListQueue() {

    }

    public LinkedListQueue(int capacity) {
        this.capacity = capacity;
    }

    @Override
    public boolean offer(E value) {
        //队列满
        if(isFull()){
            return false;
        }
        Node<E> added = new Node<> (value,head);
        //tail指向新节点
        tail.next = added;
        //尾部改成新增的节点
        tail = added;
        size++;
        return false;
    }

    @Override
    public E poll() {
        if(isEmpty()){
            return null;
        }
        //获取并移除第一个节点
        Node<E> first = head.next;
        head.next = first.next;
//        当是尾节点时，要将尾部指向头
        if(first == tail){
            tail =head;
        }
        size --;
        return first.value;
    }

    /**
     * 获取第一个节点的值
     * @return
     */
    @Override
    public E peek() {
        if(isEmpty()){
            return null;
        }

        return head.next.value;
    }

    @Override
    public boolean isEmpty() {
        //当队头和队尾指针不相等时就是非空
        return head == tail;
    }

    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            Node<E> p = head.next;
            @Override
            public boolean hasNext() {
                //环形链表
                return p!= head;
            }

            @Override
            public E next() {
                E value = p.value;
                p = p.next;
                return value;
            }
        };
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }

    public static void main(String[] args) {
        LinkedListQueue<Integer>  queue = new LinkedListQueue<>(3);
        queue.offer(1);
        queue.offer(2);
        queue.offer(3);
        queue.offer(4);
        queue.offer(5);

        final Iterator<Integer> iterator = queue.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
        System.out.println(queue.poll());

    }
}
```
使用环形数组实现链表，让数组长度为容量大小+1的方式来判断队列的空满
```java
package com.steven.dataalg.queue;

import java.util.Iterator;

/**
 * @Description: 使用环形数组实现队列
 * @CreateDate: Created in 2023/8/2 09:10
 * @Author: lijie3
 */
public class ArrayQueue<E> implements Queue<E>, Iterable<E> {

    private E[] array;

    private int head = 0;

    private int tail = 0;

    public ArrayQueue(int capacity) {
        //数组长度为容量+1，方便判断队列空还是满
        array = (E[]) new Object[capacity + 1];
    }


    @Override
    public boolean offer(E value) {
        if (isFull()) {
            return false;
        }
        //向尾部添加
        array[tail] = value;
        tail = (tail + 1) % array.length;
        return true;
    }

    @Override
    public E poll() {
        if (isEmpty()) {
            return null;
        }
        final E value = array[head];
        head = (head + 1) % array.length;
        return value;
    }

    @Override
    public E peek() {
        if (isEmpty()) {
            return null;
        }
        return array[head];
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        //尾指针下标+1 模队列长度为头指针下标时，表示队列已经满了
        return (tail + 1) % array.length == head;
    }


    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            int p = head;

            @Override
            public boolean hasNext() {
                return p != tail;
            }

            @Override
            public E next() {
                E value = array[p];
                p = (p + 1) % array.length;
                return value;
            }
        };
    }
    public static void main(String[] args) {
        ArrayQueue<Integer>  queue = new ArrayQueue<>(3);
        queue.offer(1);
        queue.offer(2);
        queue.offer(3);
        queue.offer(4);
        queue.offer(5);

        final Iterator<Integer> iterator = queue.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
        System.out.println(queue.poll());

    }
}
```
使用环形数组实现链表，添加size变量来代表队列的空满
```java
package com.steven.dataalg.queue;

import java.util.Iterator;

/**
 * @Description: 使用环形数组实现队列,使用新的方式来判断空满
 * @CreateDate: Created in 2023/8/2 09:10
 * @Author: lijie3
 */
public class ArrayQueue2<E> implements Queue<E>, Iterable<E> {

    private E[] array;

    private int head = 0;

    private int tail = 0;

    //队列中的元素个数
    private int size = 0;

    public ArrayQueue2(int capacity) {
        //数组长度为容量+1，方便判断队列空还是满
        array = (E[]) new Object[capacity];
    }


    @Override
    public boolean offer(E value) {
        if (isFull()) {
            return false;
        }
        //向尾部添加
        array[tail] = value;
        tail = (tail + 1) % array.length;
        size++;
        return true;
    }

    @Override
    public E poll() {
        if (isEmpty()) {
            return null;
        }
        final E value = array[head];
        head = (head + 1) % array.length;
        size--;
        return value;
    }

    @Override
    public E peek() {
        if (isEmpty()) {
            return null;
        }
        return array[head];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        //尾指针下标+1 模队列长度为头指针下标时，表示队列已经满了
        return size == array.length;
    }


    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            int p = head;
            //使用迭代计数的方式判断是否还有下一个元素
            int count = 0;

            @Override
            public boolean hasNext() {
                return count < size;
            }

            @Override
            public E next() {
                E value = array[p];
                p = (p + 1) % array.length;
                count++;
                return value;
            }
        };
    }
    public static void main(String[] args) {
        ArrayQueue2<Integer> queue = new ArrayQueue2<>(3);
        queue.offer(1);
        queue.offer(2);
        queue.offer(3);
        queue.offer(4);
        queue.offer(5);

        final Iterator<Integer> iterator = queue.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
        System.out.println(queue.poll());

    }
}
```
使用环形数组实现3，使用head、tail单向自增来计算队列的空满
```java
package com.steven.dataalg.queue;

import java.util.Iterator;

/**
 * @Description: 使用环形数组实现队列, 使用head、tail来判断队列的空满，增加时不断自增
 * @CreateDate: Created in 2023/8/2 09:10
 * @Author: lijie3
 */
public class ArrayQueue3<E> implements Queue<E>, Iterable<E> {

    private final E[] array;

    private int head = 0;

    private int tail = 0;


    /**
     * 这种实现方式capacity 必须是2^n,这里使用一次转换
     *
     * @param capacity
     */
    public ArrayQueue3(int capacity) {
        //方式1：非2^n抛出异常
//        if ((capacity & capacity -1) != 0) {
//            throw new IllegalArgumentException("capacity 必须是2^n");
//        }
        //方式2 ：求对数然后左移
        int a = (int) (Math.log10(capacity - 1) / Math.log10(2)) + 1;
        //左移一位求2^n
        capacity = 1 << a;

        //数组长度为容量+1，方便判断队列空还是满
        array = (E[]) new Object[capacity];
    }


    @Override
    public boolean offer(E value) {
        if (isFull()) {
            return false;
        }
        //向尾部添加,tail只自增，每次添加自增,由于int可能出现溢出情况，可以使用这种方式进行Integer.toUnsignedLong包装
//        array[(int) Integer.toUnsignedLong(tail % array.length)] = value;
        //使用按位与运算避免tail溢出
        array[tail & (array.length - 1)] = value;
        tail = tail + 1;
        return true;
    }


    @Override
    public E poll() {
        if (isEmpty()) {
            return null;
        }
        final E value = array[head & (array.length - 1)];
        head++;
        return value;
    }

    @Override
    public E peek() {
        if (isEmpty()) {
            return null;
        }
        return array[head & (array.length - 1)];
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        //尾-头=数组长度，表示队列已经满了
        return tail - head == array.length;
    }


    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            int p = head;

            @Override
            public boolean hasNext() {
                return p != tail;
            }

            @Override
            public E next() {
                E value = array[p & (array.length - 1)];
                p++;
                return value;
            }
        };
    }

    public static void main(String[] args) {
        ArrayQueue3<Integer> queue = new ArrayQueue3<>(5);
        queue.offer(1);
        queue.offer(2);
        queue.offer(3);
        queue.offer(4);
        queue.offer(5);

        final Iterator<Integer> iterator = queue.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
        System.out.println(queue.poll());

    }

}

```
### 使用队列实现对二叉树的层序遍历
```java
public class BinaryTreeForEach {

    /**
     * 二叉树层序遍历
     * @param root
     * @return
     */
    public static List<List<Integer>>  levelOrder(TreeNode root){

        List<List<Integer>> result = new ArrayList<>();
        if(root == null){
            return result;
        }
        //创建队列
        LinkedListQueue<TreeNode> queue = new LinkedListQueue<>();

        queue.offer(root);
        //当前层的节点数
        int c1 =1;
        while (!queue.isEmpty()){
            List<Integer> level = new ArrayList<>();
            //下一层节点数
            int c2 = 0;
            for (int i = 0; i < c1; i++) {
                TreeNode n = queue.poll();
                System.out.print(n + " ");
                level.add(n.getVal());
                if(n.getLeft() != null){
                    queue.offer(n.getLeft());
                    c2++;
                }
                if(n.getRight() != null){
                    queue.offer(n.getRight());
                    c2++;
                }
            }
            result.add(level);
            //更新c1为新的层的节点
            c1 = c2;
            System.out.println();

        }
        return result;
    }

    public static void main(String[] args) {

        TreeNode root = new TreeNode(1,
                new TreeNode(2,new TreeNode(4),new TreeNode(5)),
                new TreeNode(3,new TreeNode(6),new TreeNode(7)));
        levelOrder(root);
    }
}
```
## 栈 --线性结构
从顶部插入数据，并且只能从顶部移除数据
栈接口定义
```java
package com.steven.dataalg.stack;

/**
 * @Description: 栈接口
 * @CreateDate: Created in 2023/8/3 13:44
 * @Author: lijie3
 */
public interface Stack<E> {

    /**
     * 从栈顶压入元素
     * @param value
     * @return
     */
    boolean push(E value);

    /**
     * 从栈顶弹出元素
     * @return
     */
    E pop();

    /**
     * 返回栈顶元素，不弹出
     * @return
     */
    E peek();

    /**
     * 判断栈是否为空
     * @return
     */
    boolean isEmpty();

    /**
     * 判断栈是否已满
     * @return
     */
    boolean isFull();
}
```
链表实现队列
```java
package com.steven.dataalg.stack;

import java.util.Iterator;

/**
 * @Description:
 * @CreateDate: Created in 2023/8/3 13:46
 * @Author: lijie3
 */
public class LinkedListStack<E> implements Stack<E>, Iterable<E> {

    private int capacity;

    private int size;

    public LinkedListStack(int capacity) {
        this.capacity = capacity;
    }



    private static class Node<E> {
        E value;
        Node<E> next;

        public Node(E value, Node<E> next) {
            this.value = value;
            this.next = next;
        }
    }

    //栈顶指针
    private Node<E> head = new Node<>(null, null);

    /**
     * 顶部添加元素  head -> 1-> null ,添加一个新节点 2  head ->2 ->1 -> null
     *
     * @param value
     * @return
     */
    @Override
    public boolean push(E value) {
        if (isFull()) {
            return false;
        }
        head.next = new Node<>(value, head.next);
        size++;
        return false;
    }

    @Override
    public E pop() {
        if (isEmpty()) {
            return null;
        }
        Node<E> first = head.next;
        head.next = first.next;
        size--;
        return first.value;
    }

    @Override
    public E peek() {
        if (isEmpty()) {
            return null;
        }
        return head.next.value;
    }

    @Override
    public boolean isEmpty() {
        //当head指向null时表示为空栈
//        return head.next == null;
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }

    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            Node<E> p = head.next;

            @Override
            public boolean hasNext() {
                return p != null;
            }

            @Override
            public E next() {
                E value = p.value;
                p = p.next;
                return value;
            }
        };
    }

    public static void main(String[] args) {
        LinkedListStack<Integer> stack = new LinkedListStack<>(3);
        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.push(4);
        stack.push(5);
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
    }
}

```

基于数组的实现
```java
package com.steven.dataalg.stack;

import java.util.Iterator;

/**
 * @Description:
 * @CreateDate: Created in 2023/8/3 13:59
 * @Author: lijie3
 */
public class ArrayStack<E> implements Stack<E>,Iterable<E> {

    private E[] array;

    /**          底部                  顶部
     * 栈顶指针   0     1       2       3
     */
    private int top;


    public ArrayStack(int capacity) {
        array = (E[]) new Object[capacity];
    }

    @Override
    public boolean push(E value) {
        if (isFull()) {
            return false;
        }
        array[top++] = value;
        return true;
    }

    @Override
    public E pop() {
        if (isEmpty()) {
            return null;
        }
        E value = array[top - 1];
        //top指针减一即可
        top --;
        return value;
    }

    @Override
    public E peek() {
        if (isEmpty()) {
            return null;
        }
        return array[top - 1];
    }

    @Override
    public boolean isEmpty() {
        return top == 0;
    }

    @Override
    public boolean isFull() {
        return top == array.length;
    }

    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            int p = top;
            @Override
            public boolean hasNext() {
                return top != 0;
            }

            @Override
            public E next() {
                return array[--p];
            }
        };
    }
}
```


### 使用栈判断括号语法匹配是否合法
```java
import com.steven.dataalg.stack.ArrayStack;

/**
 * @Description: 使用栈判断"(){}[]"是否成对出现
 * @CreateDate: Created in 2023/8/3 14:09
 * @Author: lijie3
 */
public class StackExpressionIsValid {

    /**
     * 检测(){}[] 顺序是否合法
     * @param s
     * @return
     */
    public static boolean isValid(String s){
        ArrayStack<Character> stack = new ArrayStack<>(s.length());
        for (int i = 0; i < s.length(); i++) {
            char c  = s.charAt(i);
            if(c == '('){
                stack.push(')');
            }else if(c =='['){
                stack.push(']');
            }else if(c =='{'){
                stack.push('}');
            } else{
                if(!stack.isEmpty() && c == stack.peek()){
                    stack.pop();
                }else{
                    return false;
                }
            }
        }
        //如果栈是空的，则表示匹配成功
        if(stack.isEmpty()){
            return true;
        }
        return false;
    }

    public static void main(String[] args) {
        System.out.println(isValid("([{}])")); //true
        System.out.println(isValid("({[]})"));//true
        System.out.println(isValid("({[(]}))"));//false
    }
}
```

使用linkedList求解逆波兰表达式
```java
import java.util.LinkedList;

/**
 * @Description: 使用栈求解逆波兰表达式
 * @CreateDate: Created in 2023/8/3 19:28
 * @Author: lijie3
 */
public class StackExepressionValue {

    /**
     * 求解逆波兰表达式
     * @param tokens
     * @return
     */
    public static int evalRPN(String[] tokens){
        LinkedList<Integer> stack = new LinkedList<>();
        for (String token : tokens) {
            switch (token){
                case "+": {
                    Integer b = stack.pop();
                    Integer a = stack.pop();
                    stack.push(a+b);
                    break;
                }
                case "-":{
                    Integer b = stack.pop();
                    Integer a = stack.pop();
                    stack.push(a-b);
                    break;
                }
                case "*":{
                    Integer b = stack.pop();
                    Integer a = stack.pop();
                    stack.push(a*b);
                    break;
                }
                case "/":{
                    Integer b = stack.pop();
                    Integer a = stack.pop();
                    stack.push(a/b);
                    break;
                }
                default:{
                    stack.push(Integer.parseInt(token));
                }
            }
        }
        return stack.pop();
    }

    public static void main(String[] args) {
        System.out.println(evalRPN(new String[]{"2","1","+","3","*"}));
    }
}
```
将中缀表达式转换为后缀表达式
```java
package com.steven.dataalg.leecode;

import java.util.LinkedList;

/**
 * @Description: 中缀表达式转后缀表达式，带括号的处理，左括号优先级设置成最低，遇到右括号时将栈中到左括号为止的所有运算符全部出栈
 * @CreateDate: Created in 2023/8/4 09:11
 * @Author: lijie3
 */
public class StackInfixToSuffixExp2 {

    /**
     * 优先级判断
     *
     * @param c
     * @return
     */
    public static int proority(char c) {
        switch (c) {
            case '*':
            case '/':
                return 2;
            case '+':
            case '-':
                return 1;
            case '(':
                return 0;
            default:
                throw new IllegalArgumentException("非法运算符");
        }
    }

    /**
     * 中缀表达式转后缀表达式
     *
     * @param exp
     * @return
     */
    public static String infixToSuffix(String exp) {
        LinkedList<Character> stack = new LinkedList<>();
        StringBuilder sb = new StringBuilder(exp.length());
        for (int i = 0; i < exp.length(); i++) {
            char c = exp.charAt(i);
            switch (c) {
                case '*':
                case '/':
                case '+':
                case '-': {
                    if (stack.isEmpty()) {
                        stack.push(c);
                    } else {
                        if (proority(c) > proority(stack.peek())) {
                            stack.push(c);
                        } else {
                            while (!stack.isEmpty() && proority(stack.peek()) >= proority(c)) {
                                sb.append(stack.pop());
                            }
                            stack.push(c);
                        }
                    }
                    break;
                }
                case '(': {
                    stack.push(c);
                    break;
                }
                case ')': {
                    while (!stack.isEmpty() && stack.peek() != '(') {
                        sb.append(stack.pop());
                    }
                    //移除左括号
                    stack.pop();
                    break;
                }
                default:
                    sb.append(c);
            }
        }
        while (!stack.isEmpty()) {
            sb.append(stack.pop());
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        String exp1 = "a+b";
        String exp2 = "a+b-c";
        String exp3 = "a+b*c";
        String exp4 = "a*b-c";
        String exp5 = "a*b-c+d";
        String exp6 = "a*(b-c)+d";
        String exp7 = "a*(b-c+d)";

        System.out.println(infixToSuffix(exp1));
        System.out.println(infixToSuffix(exp2));
        System.out.println(infixToSuffix(exp3));
        System.out.println(infixToSuffix(exp4));
        System.out.println(infixToSuffix(exp5));
        System.out.println(infixToSuffix(exp6));
        System.out.println(infixToSuffix(exp7));
    }

}
```
使用两个栈模拟一个队列
```java
package com.steven.dataalg.leecode;

import com.steven.dataalg.stack.ArrayStack;

/**
 * @Description: 使用两个栈模拟一个队列
 * @CreateDate: Created in 2023/8/4 13:43
 * @Author: lijie3
 */
public class StackQueue {

    ArrayStack<Integer> s1 = new ArrayStack<>(100);
    ArrayStack<Integer> s2 = new ArrayStack<>(100);
    /**
     * push时从s2顶部push
     * pop时先将s2的元素pop出来，放入s1，然后再从s1中pop
     *
     * s1                   s2
     * 顶部   底部    底部    顶部
     */

    //添加,通过s2进行添加
    public void push(int x){
        s2.push(x);
    }
    //移除
    public int pop(){
        if(s1.isEmpty()){
            while (!s2.isEmpty()){
                 Integer v = s2.pop();
                 s1.push(v);
            }
        }
        return s1.pop();
    }

    public int peek(){
        if(s1.isEmpty()){
            while (!s2.isEmpty()){
                Integer v = s2.pop();
                s1.push(v);
            }
        }
        return s1.peek();
    }
    public boolean isEmpty(){
        return s1.isEmpty() && s2.isEmpty();
    }

}
```

用队列实现一个栈
```java
package com.steven.dataalg.leecode;

import com.steven.dataalg.queue.ArrayQueue3;

/**
 * @Description: 使用队列模拟栈
 * @CreateDate: Created in 2023/8/4 13:55
 * @Author: lijie3
 */
public class QueueStack {

    ArrayQueue3<Integer> queue = new ArrayQueue3<>(100);

    private int size = 0;
    /**
     * 栈顶               栈底
     * a        b      c    d
     * 队列头             队列尾
     *
     */

    /**
     *
     * @param x
     */
    public void push(int x){
        queue.offer(x);
        for (int i = 0; i < size - 1; i++) {
            queue.offer(queue.poll());
        }
        size ++;
    }

    public int pop(){
        size --;
        return queue.poll();
    }

    public int top(){
        return queue.peek();
    }

    public boolean isEmpty(){
        return queue.isEmpty();
    }
}
```

## 双端队列 
两端都可以删除、添加
### 基于链表实现双端队列
```java
package com.steven.dataalg.queue;

import java.util.Iterator;

/**
 * @Description: 双向环形链表实现双端队列
 * @CreateDate: Created in 2023/8/4 16:16
 * @Author: lijie3
 */
public class LinkedListDeque<E> implements Deque<E>, Iterable<E> {

    private static class Node<E> {
        Node<E> prev;
        E value;
        Node<E> next;

        public Node(Node<E> prev, E value, Node<E> next) {
            this.prev = prev;
            this.value = value;
            this.next = next;
        }
    }

    private final Node<E> sentinel = new Node<>(null, null, null);

    private int capacity = Integer.MAX_VALUE;
    private int size = 0;

    public LinkedListDeque(int capacity) {
        this.capacity = capacity;
        sentinel.next = sentinel;
        sentinel.prev = sentinel;
    }

    @Override
    public boolean offerFirst(E e) {
        if (isFull()) {
            return false;
        }
        Node<E> a = sentinel;
        Node<E> b = sentinel.next;
        Node<E> added = new Node<>(a, e, b);
        a.next = added;
        b.prev = added;
        size++;
        return true;
    }

    @Override
    public boolean offerLast(E e) {
        if (isFull()) {
            return false;
        }
        Node<E> b = sentinel;
        Node<E> a = sentinel.prev;
        Node<E> added = new Node<>(a, e, b);
        a.next = added;
        b.prev = added;
        size++;
        return true;
    }

    @Override
    public E pollFirst() {
        if(isEmpty()){
            return null;
        }
        Node<E> a = sentinel;
        Node<E> removed = sentinel.next;
        Node<E> b = removed.next;
        a.next = b;
        b.prev = a;
        size--;
        return removed.value;
    }

    @Override
    public E pollLast() {
        if(isEmpty()){
            return null;
        }
        Node<E> b = sentinel;
        Node<E> removed = sentinel.prev;
        Node<E> a = removed.prev;
        a.next = b;
        b.prev = a;
        size --;
        return removed.value;
    }

    @Override
    public E peekFirst() {
        if(isEmpty()){
            return null;
        }
        //不需要移除直接返回哨兵之后的第一个元素
        return sentinel.next.value;
    }

    @Override
    public E peekLast() {
        if(isEmpty()){
            return null;
        }
        return sentinel.prev.value;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }

    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {

            Node<E> p = sentinel.next;

            @Override
            public boolean hasNext() {
                return p != sentinel;
            }

            @Override
            public E next() {
                E value = p.value;
                p = p.next;
                return value;
            }
        };
    }

    public static void main(String[] args) {
        LinkedListDeque<Integer> deque = new LinkedListDeque<>(5);
        deque.offerFirst(1);
        deque.offerFirst(2);
        deque.offerFirst(3);
        deque.offerLast(4);
        deque.offerLast(5);
        System.out.println( deque.offerFirst(6));
        Iterator<Integer> iterator = deque.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }

    }
}
```
### 基于循环数组实现双端队列
```java
package com.steven.dataalg.queue;

import java.util.Iterator;

/**
 * @Description: 数组实现双端队列，
 * @CreateDate: Created in 2023/8/4 16:59
 * @Author: lijie3
 */
public class ArrayDeque1<E> implements Deque<E>,Iterable<E> {

    E[] array;

    int head;
    int tail;


    public ArrayDeque1(int capacity) {
        this.array = (E[]) new Object[capacity +1];
    }

    /**
     * 处理tail数组下标越界的问题
     * @param i
     * @param length
     * @return
     */
    static int inc(int i, int length){
        if(i +1 >= length){
            return 0;
        }
        return i+1;
    }

    /**
     * 处理head 数组下标越界的情况
     * @param i
     * @param length
     * @return
     */
    static int dec(int i,int length){
        if(i -1 < 0){
            return length -1;
        }
        return  i -1;
    }

    @Override
    public boolean offerFirst(E e) {
        if(isFull()){
            return false;
        }
        head = dec(head,array.length);
        array[head] = e;
        return true;
    }

    @Override
    public boolean offerLast(E e) {
        if(isFull()){
            return false;
        }
        array[tail] = e;
        tail = inc(tail,array.length);
        return true;
    }

    /**
     * 头部移除，如果是引用类型，需要考虑内存释放
     * @return
     */
    @Override
    public E pollFirst() {
        if(isEmpty()){
            return null;
        }
        E value = array[head];
        //清除内存数据
        array[head] = null;
        head  = inc(head,array.length);
        return value;
    }

    @Override
    public E pollLast() {
        if(isEmpty()){
            return null;
        }
        tail=  dec(tail,array.length);
        E e = array[tail];
        //清除内存数据
        array[tail] = null;
        return e;
    }

    @Override
    public E peekFirst() {
        if(isEmpty()){
            return null;
        }
        return array[head];
    }

    @Override
    public E peekLast() {
        if(isEmpty()){
            return null;
        }
        return array[tail -1];
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        //分两种情况计算
        if(tail > head){
            return tail -head == array.length -1;
        }
        if(tail < head){
            return head-tail == 1;
        }
        return false;
    }

    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            int p = head;
            @Override
            public boolean hasNext() {

                return p != tail;
            }

            @Override
            public E next() {
                E e = array[p];
                p = inc(p, array.length);
                return e;
            }
        };
    }
}
```

## 优先级队列
按队列中元素优先级来进行出队，优先级高的先出队
### 基于无序数组的实现
```java
package com.steven.dataalg.queue;

/**
 * @Description: 优先级队列，基于数组实现
 * @CreateDate: Created in 2023/8/5 21:12
 * @Author: lijie3
 */
public class PriorityQueue1<E extends Priority> implements Queue<E> {

    Priority[] array;
    int size;

    public PriorityQueue1(int capacity) {
        array = new Priority[capacity];
    }

    @Override
    public boolean offer(E value) {
        if(isFull()){
            return false;
        }
        array[size] = value;
        size ++;
        return true;
    }

    /**
     * 返回优先级最高的索引值
     * @return
     */
    private int selectMax(){
        int max = 0;
        for (int i = 1; i < size; i++) {
            if(array[i].priority() > array[max].priority()){
                max = i;
            }
        }
        return max;
    }

    @Override
    public E poll() {
        if(isEmpty()){
            return null;
        }
        int max = selectMax();
        E value = (E) array[max];
        remove(max);
        return value;
    }

    /**
     * 删除元素
     * @param index
     */
    private void remove(int index){
        if(index < size-1){
            System.arraycopy(array,index +1,array,index,size-index -1);
        }
        size --;

    }

    @Override
    public E peek() {
        if(isEmpty()){
            return null;
        }
        int max = selectMax();
        return (E) array[max];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == array.length;
    }

    static class Entry implements Priority {
         int priority;
         String name;

        public Entry( String name,int priority) {
            this.priority = priority;
            this.name = name;
        }

        @Override
        public int priority() {
            return priority;
        }
    }
    public static void main(String[] args) {
        PriorityQueue1<Entry> queue1 = new PriorityQueue1<Entry>(5);
        queue1.offer(new Entry("task1",4));
        queue1.offer(new Entry("task2",3));
        queue1.offer(new Entry("task3",5));
        queue1.offer(new Entry("task4",2));
        queue1.offer(new Entry("task5",1));
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);

    }
}
```
### 基于有序数组的实现
```java
package com.steven.dataalg.queue;

/**
 * @Description: 优先级队列，基于数组实现,使用有序数组
 * @CreateDate: Created in 2023/8/5 21:12
 * @Author: lijie3
 */
public class PriorityQueue2<E extends Priority> implements Queue<E> {

    Priority[] array;
    int size;

    public PriorityQueue2(int capacity) {
        array = new Priority[capacity];
    }

    /**
     * 插入时需要按照优先级进行排序
     * @param value
     * @return
     */
    @Override
    public boolean offer(E value) {
        if(isFull()){
            return false;
        }

        insert(value);
        return true;
    }

    private void insert(E value){
        int i = size -1;
        while (i >= 0 && array[i].priority() > value.priority()){
            array[i + 1] = array[i];
            i --;
        }
        array[i + 1] = value;
        size ++;
    }

    /**
     * 返回优先级最高的索引值
     * @return
     */
    private int selectMax(){
        int max = 0;
        for (int i = 1; i < size; i++) {
            if(array[i].priority() > array[max].priority()){
                max = i;
            }
        }
        return max;
    }

    @Override
    public E poll() {
        if(isEmpty()){
            return null;
        }
        E value = (E) array[size -1];
        size--;
        //针对内存回收的优化
        array[size] = null;
        return value;
    }

    /**
     * 删除元素
     * @param index
     */
    private void remove(int index){
        if(index < size-1){
            System.arraycopy(array,index +1,array,index,size-index -1);
        }
        size --;

    }

    @Override
    public E peek() {
        if(isEmpty()){
            return null;
        }

        return (E) array[size -1];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == array.length;
    }

    static class Entry implements Priority {
         int priority;
         String name;

        public Entry( String name,int priority) {
            this.priority = priority;
            this.name = name;
        }

        @Override
        public int priority() {
            return priority;
        }
    }
    public static void main(String[] args) {
        PriorityQueue2<Entry> queue1 = new PriorityQueue2<Entry>(5);
        queue1.offer(new Entry("task1",4));
        queue1.offer(new Entry("task2",3));
        queue1.offer(new Entry("task3",5));
        queue1.offer(new Entry("task4",2));
        queue1.offer(new Entry("task5",1));
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);

    }
}
```
### 使用堆实现优先级队列
堆：本质上是一种树，一般使用完全二叉树实现（树除了最后一层，其他层都是填满的）

堆的特性：
* 使用完全二叉树实现（树除了最后一层，其他层都是填满的）
* 在堆中，每个节点都满足堆属性，即父节点的值总是大于或小于其子节点的值，具体取决于是最大堆还是最小堆。
* 堆支持插入和删除元素，通常是插入一个元素后对堆进行重新调整以保持堆属性。另外，堆还支持获取最大或最小元素的操作，这可以在 O(1) 时间内完成。
* 父节点和子节点之间的关系可以通过数组来表示。具体来说，对于节点 i，其左子节点位于 2i+1，右子节点位于 2i+2。同样，对于节点 i，其父节点位于 (i-1)/2。

大顶堆： 父节点的值更大，子节点小
小顶堆： 父节点的值比自节点更小
最顶层的节点称为根节点
非线形数据结构，可以使用线性的数据结构来存储节点数据

使用大顶堆实现优先级队列
```java
package com.steven.dataalg.queue;

/**
 * @Description: 优先级队列，基于大顶堆实现
 * @CreateDate: Created in 2023/8/5 21:12
 * @Author: lijie3
 */
public class PriorityQueue3<E extends Priority> implements Queue<E> {

    Priority[] array;
    int size;

    public PriorityQueue3(int capacity) {
        array = new Priority[capacity];
    }

    /**
     * 插入时需要按照优先级进行排序
     * @param value
     * @return
     */
    @Override
    public boolean offer(E value) {
        if(isFull()){
            return false;
        }
        //平衡二叉数的插入节点调整
        int child = size ++;
        int parent = (child-1)/2;
        while(child > 0 && value.priority() > array[parent].priority()){
            array[child] = array[parent];
            child = parent;
            parent = (child-1)/2;
        }
        array[child] = value;

        return true;
    }



    /**
     * 返回优先级最高的索引值
     * @return
     */
    private int selectMax(){
        int max = 0;
        for (int i = 1; i < size; i++) {
            if(array[i].priority() > array[max].priority()){
                max = i;
            }
        }
        return max;
    }

    //移除堆元素，将最小元素与根元素进行交换，然后将堆顶元素往下移动
    @Override
    public E poll() {
        if(isEmpty()){
            return null;
        }
        swap(0,size -1);
        size --;
        E value = (E) array[size];
        //针对内存回收的优化
        array[size] = null;
        //下潜根节点
        down(0);
        return value;
    }

    private void down(int parent){
        int left = 2 * parent +1;
        int right = left + 1;
        //假设父元素最大
        int max = parent;
        if(left < size && array[left].priority() > array[max].priority()){
            max = left;
        }
        if(right < size && array[right].priority() > array[right].priority()){
            max = right;
        }
        if(max != parent){
            swap(parent,max);
            down(max);
        }
    }

    private void swap(int i,int j){
        Priority t = array[i];
        array[i] = array[j];
        array[j] = t;
    }



    //返回堆顶元素
    @Override
    public E peek() {
        if(isEmpty()){
            return null;
        }
        return (E) array[0];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == array.length;
    }

    static class Entry implements Priority {
         int priority;
         String name;

        public Entry( String name,int priority) {
            this.priority = priority;
            this.name = name;
        }

        @Override
        public int priority() {
            return priority;
        }
    }
    public static void main(String[] args) {
        PriorityQueue3<Entry> queue1 = new PriorityQueue3<Entry>(5);
        queue1.offer(new Entry("task1",4));
        queue1.offer(new Entry("task2",3));
        queue1.offer(new Entry("task3",5));
        queue1.offer(new Entry("task4",2));
        queue1.offer(new Entry("task5",1));
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);
        System.out.println(queue1.poll().name);

    }
}
```
合并多个有序链表
使用小顶堆实现的优先级队列实现
小顶堆实现
```java
package com.steven.dataalg.tree.heap;

import com.steven.dataalg.queue.Priority;
import com.steven.dataalg.recursion.ListNode;

/**
 * @Description: 小顶堆，完全二叉树，根节点最小
 * @CreateDate: Created in 2023/8/8 08:49
 * @Author: lijie3
 */
public class MinHeap {

    ListNode[] array;

    int size;

    public MinHeap(int capacity) {
        array = new ListNode[capacity];
    }

    /**
     * 参考大顶堆实现的队列 PriorityQueue3
     * @param offered
     * @return
     */
    public boolean offer(ListNode offered){
        if(isFull()){
            return false;
        }
        //平衡二叉数的插入节点调整
        int child = size ++;
        int parent = (child-1)/2;
        while(child > 0 && offered.val < array[parent].val){
            array[child] = array[parent];
            child = parent;
            parent = (child-1)/2;
        }
        array[child] = offered;

        return true;
    }

    /**
     * 参考大顶堆实现的队列 PriorityQueue3
     * @return
     */
    public ListNode poll(){
        if(isEmpty()){
            return null;
        }
        swap(0,size -1);
        size --;
        ListNode value =  array[size];
        //针对内存回收的优化
        array[size] = null;
        //下潜根节点
        down(0);
        return value;
    }

    private void down(int parent){
        //完全二叉树固定计算公式
        int left = 2 * parent +1;
        int right = left + 1;
        //假设父元素最大
        int min = parent;
        if(left < size && array[left].val < array[min].val){
            min = left;
        }
        if(right < size && array[right].val < array[right].val){
            min = right;
        }
        if(min != parent){
            swap(parent,min);
            down(min);
        }
    }

    private void swap(int i,int j){
        ListNode t = array[i];
        array[i] = array[j];
        array[j] = t;
    }



    public boolean isEmpty(){
        return size ==0;
    }

    public boolean isFull(){
        return size == array.length;
    }
}
```
使用小顶堆实现多个链表合并
```java
package com.steven.dataalg.leecode;

import com.steven.dataalg.recursion.ListNode;
import com.steven.dataalg.tree.heap.MinHeap;

/**
 * @Description: 合并多个List，使用小顶堆实现
 * @CreateDate: Created in 2023/7/31 08:37
 * @Author: lijie3
 */
public class MergeLists2 {


    public static ListNode mergeKList(ListNode[] lists) {
        if (lists.length == 0) {
            return null;
        }
        MinHeap heap = new MinHeap(lists.length);
        //1. 将链表头节点加入小顶堆
        for(ListNode h :lists){
            if(h != null){
                heap.offer(h);
            }
        }

        //2. 不断从堆顶移除元素
        //使用哨兵
        ListNode s = new ListNode(-1 ,null);
        ListNode t = s;
        while (!heap.isEmpty()){
            //取堆顶的最小原属
            ListNode min = heap.poll();
            //将最小元素放入链表
            t.next = min;
            //更新t元素
            t = min;
            //将min 的下一个节点加入堆中
            if(min.next != null){
                heap.offer(min.next);
            }
        }
        return s.next;
    }


    public static void main(String[] args) {
        ListNode[] lists = {
                ListNode.of(1, 4, 5),
                ListNode.of(1, 3, 4),
                ListNode.of(2, 6)
        };
        for (int i = 0; i < lists.length; i++) {
            ListNode.print(lists[i]);
        }
        ListNode m = mergeKList(lists);
        ListNode.print(m);
    }
}
```
## 阻塞队列
解决生产者消费者的多线程访问问题
使用单锁实现阻塞队列
使用ReentrantLock和condition实现线程的阻塞和唤醒
```java
package com.steven.dataalg.queue;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Description: 使用单锁实现阻塞队列
 * @CreateDate: Created in 2023/8/12 12:01
 * @Author: lijie3
 */
public class TestThreadUnsafe {

    private final String[] array = new String[10];
    //队列
    private int tail = 0;
    //队列元素大小
    private int size = 0;

    ReentrantLock lock = new ReentrantLock();

    //条件变量对象，集合
    Condition tailWaits = lock.newCondition();


    /**
     * 添加元素
     * @param e
     * @throws InterruptedException
     */
    public void offer(String e) throws InterruptedException{
        lock.lockInterruptibly();
        try {
          //存在线程安全问题，如果只是使用if判断，则可能线程A在await，线程B执行了上面的lock.lockInterruptibly();拿到了锁，继续执行完成后线程A被唤醒继续从tailWaits.await();处执行，而这时队列可能已经又被B填满了，这时就出现了线程不安全的问题
            // if(isFull()){
            //改成while条件判断避免虚假唤醒
            while(isFull()){
                //当队列满了时，让当前的线程暂停处于阻塞状态，线程的锁会被释放
                //当前线程加入tailwatis,使用tailWaits.signal()唤醒一个等待线程
                tailWaits.await();

            }
            array[tail] = e;
            if(++tail == array.length){
                tail = 0;
            }
            size ++;
        }finally {
            lock.unlock();
        }
    }

    private boolean isFull(){
        return size == array.length;
    }

    public static void main(String[] args) throws InterruptedException {
        TestThreadUnsafe queue = new TestThreadUnsafe();
        for (int i = 0; i < 10; i++) {
            queue.offer("e"+i);
        }
        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName() + "添加元素前");
                queue.offer("e10");
                System.out.println(Thread.currentThread().getName() + "添加元素后");
            }catch (InterruptedException e){
                throw new RuntimeException();
            }
        },"t1").start();
        new Thread(()->{
            System.out.println("开始唤醒");
            try {
                queue.lock.lockInterruptibly();
                queue.tailWaits.signal();
            }catch (InterruptedException e){
                throw new RuntimeException();
            }finally {
                queue.lock.unlock();
            }
        },"t2").start();
    }
}
```

阻塞队列实现,单锁实现条件唤醒
```java
package com.steven.dataalg.queue;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Description:
 * @CreateDate: Created in 2023/8/12 12:44
 * @Author: lijie3
 */
public class BlockingQueue1<E> implements BlockingQueue<E> {

    private final E[] array;

    private int head;
    //队列尾
    private int tail;

    private int size;

    public BlockingQueue1(int capacity) {
        array = (E[]) new Object[capacity];
    }

    private ReentrantLock lock = new ReentrantLock();
    //头条件变量，poll用
    private Condition headWaits = lock.newCondition();
    //尾条件变量，offer用
    private Condition tailWaits = lock.newCondition();

    @Override
    public void offer(E e) throws InterruptedException {
        lock.lockInterruptibly();
        try {
            while (isFull()) {
                //等待队列空出位置
                tailWaits.wait();
            }
            array[tail] = e;
            if (++tail == array.length) {
                tail = 0;
            }
            size++;
            //添加后唤醒消费者
            headWaits.signal();
        } finally {
            lock.unlock();
        }
    }

    @Override
    public boolean offer(E e, long timeout) throws InterruptedException {
        lock.lockInterruptibly();
        try {
            long t = TimeUnit.MILLISECONDS.toNanos(timeout);
            while (isFull()) {
                if (t <= 0) {
                    return false;
                }
                //最多等待多少纳秒,返回值代表剩余时间
                t = tailWaits.awaitNanos(t);
            }
            array[tail] = e;
            if (++tail == array.length) {
                tail = 0;
                size++;
            }
            //添加后唤醒消费者
            headWaits.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }

    @Override
    public E poll() throws InterruptedException {
        lock.lockInterruptibly();
        try {
            while (isEmpty()) {
                headWaits.await();
            }
            E e = array[head];
            //垃圾回收
            array[head] = null;
            if (++head == array.length) {
                head = 0;
            }
            size--;
            //唤醒生产者
            tailWaits.signal();
            return e;
        } finally {
            lock.unlock();
        }
    }

    private boolean isEmpty() {
        return size == 0;
    }

    private boolean isFull() {
        return size == array.length;
    }

    @Override
    public String toString() {
        return Arrays.toString(array);
    }

    public static void main(String[] args) throws InterruptedException {
        BlockingQueue1<String> queue = new BlockingQueue1<>(3);
        Thread t = new Thread(()->{
            try {
                System.out.println(System.currentTimeMillis() + " begin");
                queue.offer("任务1");
                System.out.println(queue);
                queue.offer("任务2");
                System.out.println(queue);
                queue.offer("任务3");
                System.out.println(queue);
                queue.offer("任务4",10000);
                System.out.println(queue);
                System.out.println(System.currentTimeMillis() + " end");

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"生产者");
        t.start();
        Thread.sleep(2000);
        queue.poll();
    }
}  
```
存在的问题：
由于offer、poll使用的是同一把锁，所以offer和poll的线程在执行时不能同时运行，必须等一个线程执行结束之后下一个线程才能执行
### 使用双锁实现阻塞队列
```java
package com.steven.dataalg.queue;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Description: 使用两把锁实现阻塞队列,offer和poll线程互不影响,提高队列性能
 * @CreateDate: Created in 2023/8/12 12:44
 * @Author: lijie3
 */
public class BlockingQueue2<E> implements BlockingQueue<E> {

    private final E[] array;

    private int head;
    //队列尾
    private int tail;

    private AtomicInteger size  = new AtomicInteger();

    public BlockingQueue2(int capacity) {
        array = (E[]) new Object[capacity];
    }


    //尾指针锁
    private ReentrantLock tailLock = new ReentrantLock();
    //头指针锁
    private ReentrantLock headLock = new ReentrantLock();

    //头条件变量，poll用
    private Condition headWaits = headLock.newCondition();
    //尾条件变量，offer用
    private Condition tailWaits = tailLock.newCondition();

    @Override
    public void offer(E e) throws InterruptedException {
        //添加前的元素个数
        int c;
        tailLock.lockInterruptibly();
        try {
            while (isFull()) {
                //等待队列空出位置
                tailWaits.wait();
            }
            //不满则入队
            array[tail] = e;
            if (++tail == array.length) {
                tail = 0;
            }
            //修改size，直接使用size++是线程不安全的，这里使用了多把锁，无法同时锁住offer、poll两个线程的操作

            c = size.getAndIncrement();
            //添加后唤醒消费者
//            headLock.lock();
//            try {
//                headWaits.signal();
//            }finally {
//                headLock.unlock();
//            }
        } finally {
            tailLock.unlock();
        }
        //不使用锁嵌套的逻辑，避免死锁的出现，唤醒poll线程
        //减少offer线程使用headlock锁的加锁次数，使用级联控制
        if(c == 0){
            headLock.lock();
            try {
                headWaits.signal();
            }finally {
                headLock.unlock();
            }
        }
    }

    @Override
    public boolean offer(E e, long timeout) throws InterruptedException {
        boolean r;
        tailLock.lockInterruptibly();
        try {
            long t = TimeUnit.MILLISECONDS.toNanos(timeout);
            while (isFull()) {
                if (t <= 0) {
                    r= false;
                }
                //最多等待多少纳秒,返回值代表剩余时间
                t = tailWaits.awaitNanos(t);
            }
            array[tail] = e;
            if (++tail == array.length) {
                tail = 0;
                size.getAndIncrement();
            }
            //添加后唤醒消费者,这里唤醒必须要先获取正确的锁
            //这种方式可能会产生死锁，这里有两把锁，有多个线程同时竞争，很容易出现死锁
//            headLock.lock();
//            try {
//                headWaits.signal();
//            }finally {
//                headLock.unlock();
//            }
            r= true;
        } finally {
            tailLock.unlock();
        }
        headLock.lock();
        try {
            headWaits.signal();
        }finally {
            headLock.unlock();
        }
        return r;

    }

    @Override
    public E poll() throws InterruptedException {
        E e;
        headLock.lockInterruptibly();
        try {
            while (isEmpty()) {
                headWaits.await();
            }
            e = array[head];
            //垃圾回收
            array[head] = null;
            if (++head == array.length) {
                head = 0;
            }
            size.getAndDecrement();
            //唤醒生产者
//            tailLock.lock();
//            try {
//                tailWaits.signal();
//            }finally {
//                tailLock.unlock();
//            }

        } finally {
            headLock.unlock();
        }
        //平级加锁,避免死锁
        tailLock.lock();
        try {
            tailWaits.signal();
        }finally {
            tailLock.unlock();
        }
        return e;
    }

    private boolean isEmpty() {
        return size.get() == 0;
    }

    private boolean isFull() {
        return size.get() == array.length;
    }

    @Override
    public String toString() {
        return Arrays.toString(array);
    }

    public static void main(String[] args) throws InterruptedException {
        BlockingQueue2<String> queue = new BlockingQueue2<>(3);
        Thread t = new Thread(()->{
            try {
                System.out.println(System.currentTimeMillis() + " begin");
                queue.offer("任务1");
                System.out.println(queue);
                queue.offer("任务2");
                System.out.println(queue);
                queue.offer("任务3");
                System.out.println(queue);
                queue.offer("任务4",10000);
                System.out.println(queue);
                System.out.println(System.currentTimeMillis() + " end");

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"生产者");
        t.start();
        Thread.sleep(2000);
        new Thread(()->{
            try {
                System.out.println(queue.poll());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```
双锁相互唤醒，阻塞队列的相互唤醒，由offer线程1来唤醒其他offer线程，有poll线程1 来唤醒其他poll线程，当队列中可以再加入元素或弹出元素时
```java
package com.steven.dataalg.queue;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Description: 使用两把锁实现阻塞队列,offer和poll线程互不影响,提高队列性能
 * @CreateDate: Created in 2023/8/12 12:44
 * @Author: lijie3
 */
public class BlockingQueue3<E> implements BlockingQueue<E> {

    private final E[] array;

    private int head;
    //队列尾
    private int tail;

    private AtomicInteger size  = new AtomicInteger();

    public BlockingQueue3(int capacity) {
        array = (E[]) new Object[capacity];
    }


    //尾指针锁
    private ReentrantLock tailLock = new ReentrantLock();
    //头指针锁
    private ReentrantLock headLock = new ReentrantLock();

    //头条件变量，poll用
    private Condition headWaits = headLock.newCondition();
    //尾条件变量，offer用
    private Condition tailWaits = tailLock.newCondition();

    @Override
    public void offer(E e) throws InterruptedException {
        //添加前的元素个数
        int c;
        tailLock.lockInterruptibly();
        try {
            while (isFull()) {
                //等待队列空出位置
                tailWaits.wait();
            }
            //不满则入队
            array[tail] = e;
            if (++tail == array.length) {
                tail = 0;
            }
            //修改size，直接使用size++是线程不安全的，这里使用了多把锁，无法同时锁住offer、poll两个线程的操作

            c = size.getAndIncrement();
            //通过当前offer线程唤醒其他offer线程
            if(c +1 < array.length){
                tailWaits.signal();
            }

        } finally {
            tailLock.unlock();
        }
        //不使用锁嵌套的逻辑，避免死锁的出现，唤醒poll线程
        //减少offer线程使用headlock锁的加锁次数，使用级联控制
        if(c == 0){
            headLock.lock();
            try {
                headWaits.signal();
            }finally {
                headLock.unlock();
            }
        }
    }

    @Override
    public boolean offer(E e, long timeout) throws InterruptedException {
        boolean r;
        int c;
        tailLock.lockInterruptibly();
        try {
            long t = TimeUnit.MILLISECONDS.toNanos(timeout);
            while (isFull()) {
                if (t <= 0) {
                    r= false;
                }
                //最多等待多少纳秒,返回值代表剩余时间
                t = tailWaits.awaitNanos(t);
            }
            array[tail] = e;
            if (++tail == array.length) {
                tail = 0;
                size.getAndIncrement();
            }
            //添加后唤醒消费者,这里唤醒必须要先获取正确的锁
            //这种方式可能会产生死锁，这里有两把锁，有多个线程同时竞争，很容易出现死锁
//            headLock.lock();
//            try {
//                headWaits.signal();
//            }finally {
//                headLock.unlock();
//            }
            r= true;
        } finally {
            tailLock.unlock();
        }
        //使用一个offer线程唤醒poll线程
        headLock.lock();
        try {
            headWaits.signal();
        }finally {
            headLock.unlock();
        }
        return r;

    }

    @Override
    public E poll() throws InterruptedException {
        E e;
        int c;
        headLock.lockInterruptibly();
        try {
            while (isEmpty()) {
                headWaits.await();
            }
            e = array[head];
            //垃圾回收
            array[head] = null;
            if (++head == array.length) {
                head = 0;
            }
            c = size.getAndDecrement();
            //当队列中还有其他元素时，唤醒其他poll线程
            if(c > 1){
                headWaits.signal();
            }
        } finally {
            headLock.unlock();
        }
        //平级加锁
        //通过判断队列本次是否poll之前是否时满的，如果时满的情况下获取一个之后则有空位，则唤醒一个offer线程
        if(c  == array.length){
            tailLock.lock();
            try {
                tailWaits.signal();
            }finally {
                tailLock.unlock();
            }
        }
        return e;
    }

    private boolean isEmpty() {
        return size.get() == 0;
    }

    private boolean isFull() {
        return size.get() == array.length;
    }

    @Override
    public String toString() {
        return Arrays.toString(array);
    }

    public static void main(String[] args) throws InterruptedException {
        BlockingQueue3<String> queue = new BlockingQueue3<>(3);
        Thread t = new Thread(()->{
            try {
                System.out.println(System.currentTimeMillis() + " begin");
                queue.offer("任务1");
                System.out.println(queue);
                queue.offer("任务2");
                System.out.println(queue);
                queue.offer("任务3");
                System.out.println(queue);
                queue.offer("任务4",10000);
                System.out.println(queue);
                System.out.println(System.currentTimeMillis() + " end");

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"生产者");
        t.start();
        Thread.sleep(2000);
        new Thread(()->{
            try {
                System.out.println(queue.poll());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}

```

## 堆
大顶堆： 父节点的值大于左右两个子节点
小顶堆： 父节点小于所有的字节点
堆的操作
**建堆（heapify）**
使用弗洛伊德建堆算法，时间复杂度为 O(n)
* 找到最后一个非叶子节点 索引为：size/2 -1
* 从后向前为每个节点执行下潜

**获取堆顶元素**
**移除堆顶元素**
**在堆数组尾部添加新元素**
**删除指定位置元素**
```java
package com.steven.dataalg.heap;

import java.util.Arrays;

/**
 * @Description:
 * @CreateDate: Created in 2023/8/22 07:47
 * @Author: lijie3
 */
public class MaxHeap {

    int[] array;
    int size;

    public MaxHeap(int capacity) {
        this.array = new int[capacity];
    }

    public MaxHeap(int[] array){
        this.array = array;
        this.size = array.length;
        //建堆
        heapify();
    }

    /**
     * 建堆，使用弗洛伊德算法
     */
    private void heapify(){
        //1.找到最后一个非叶子节点  size/2 -1
        for(int i = size /2 -1; i>=0 ; i-- ){
            //2.对几点进行下潜
            down(i);
        }
    }

    /**
     * 下潜，将parent索引处的元素下潜，与两个孩子较大者交换，直到没有孩子或孩子没它大
     * @param parent
     */
    private void down(int parent){
        //左孩子节点index
        int left = parent * 2 +1;
        //右孩子节点index
        int right = left +1;
        int max = parent;
        if(left < size && array[left] > array[max]){
            max = left;
        }
        if(right < size && array[right] > array[max]){
            max = right;
        }
        if(max != parent){ //找到了更大的孩子
            swap(max,parent);
            //递归下潜
            down(max);
        }
    }
    //交换
    private void swap(int i ,int j){
        int t = array[i];
        array[i]  = array[j];
        array[j] = t;
    }

    /**
     * 获取堆顶元素
     * @return
     */
    public int peek(){
        return array[0];
    }

    //移除堆顶元素
    public int poll(){
        int top = array[0];
        //将最后一个元素与第一个元素交换
        swap(0,size-1);
        size--;
        //下潜索引0 位置的元素
        down(0);
        return top;
    }

    /**
     * 删除指定位置的元素
     * @param index
     * @return
     */
    public int poll(int index){
        int deleted = array[index];
        swap(index,size -1);
        size --;
        down(index);
        return deleted;
    }

    /**
     * 替换堆顶元素
     * @param replaced
     */
    public void replace(int replaced){
        array[0] = replaced;
        down(0);
    }

    /**
     * 添加元素到堆的尾部
     * @param offered
     */
    public boolean offer(int offered){
        if(size == array.length){
            return false;
        }
        up(offered);
        size ++;
        return true;
    }

    /**
     * 将offered元素上浮，直到offered小于父元素或到堆顶
     * @param offered
     */
    private void up(int offered){
        int child  = size;
        while (child > 0){
            int parent = (child -1)/2;
            if(offered > array[parent]){
                //将父元素上浮
                array[child] = array[parent];
            }else{
                break;
            }
            child = parent;
        }
        array[child] = offered;
    }

    public static void main(String[] args) {
        int[] array = {1,2,3,4,5,6,7};
        //建堆测试
        MaxHeap maxHeap = new MaxHeap(array);
        System.out.println(Arrays.toString(maxHeap.array));
    }
}
```
### 堆排序--使用堆实现排序
思路：
1. 使用heapify建立大顶堆
2. 将堆顶与堆低交换，缩小并下潜调整堆
3. 重复第二部直到堆里剩一个元素
```java
public class HeapSorted {

    public static void main(String[] args) {
        int[] array = {2,1,4,8,6,3,5};
        MaxHeap heap = new MaxHeap(array);
        System.out.println(Arrays.toString(array));
        while(heap.size > 1){
            //将堆顶元素移除
            heap.swap(0, heap.size-1);
            heap.size --;
            //下潜堆顶元素
            heap.down(0);
        }
        System.out.println(Arrays.toString(array));
    }
}
```
### 求数组中第key大的元素
小顶堆实现
```java
package com.steven.dataalg.heap;

import java.util.Arrays;

/**
 * @Description:
 * @CreateDate: Created in 2023/8/22 08:37
 * @Author: lijie3
 */
public class MinHeap {
    int[] array;
    int size;

    public MinHeap(int capacity) {
        this.array = new int[capacity];
    }

    public MinHeap(int[] array){
        this.array = array;
        this.size = array.length;
        //建堆
        heapify();
    }

    /**
     * 建堆，使用弗洛伊德算法
     */
    private void heapify(){
        //1.找到最后一个非叶子节点  size/2 -1
        for(int i = size /2 -1; i>=0 ; i-- ){
            //2.对几点进行下潜
            down(i);
        }
    }

    /**
     * 下潜，将parent索引处的元素下潜，与两个孩子较大者交换，直到没有孩子或孩子没它大
     * @param parent
     */
    public void down(int parent){
        //左孩子节点index
        int left = parent * 2 +1;
        //右孩子节点index
        int right = left +1;
        int min = parent;
        if(left < size && array[left] < array[min]){
            min = left;
        }
        if(right < size && array[right] < array[min]){
            min = right;
        }
        if(min != parent){ //找到了更大的孩子
            swap(min,parent);
            //递归下潜
            down(min);
        }
    }
    //交换
    public void swap(int i ,int j){
        int t = array[i];
        array[i]  = array[j];
        array[j] = t;
    }

    /**
     * 获取堆顶元素
     * @return
     */
    public int peek(){
        return array[0];
    }

    //移除堆顶元素
    public int poll(){
        int top = array[0];
        //将最后一个元素与第一个元素交换
        swap(0,size-1);
        size--;
        //下潜索引0 位置的元素
        down(0);
        return top;
    }

    /**
     * 删除指定位置的元素
     * @param index
     * @return
     */
    public int poll(int index){
        int deleted = array[index];
        swap(index,size -1);
        size --;
        down(index);
        return deleted;
    }

    /**
     * 替换堆顶元素
     * @param replaced
     */
    public void replace(int replaced){
        array[0] = replaced;
        down(0);
    }

    /**
     * 添加元素到堆的尾部
     * @param offered
     */
    public boolean offer(int offered){
        if(size == array.length){
            return false;
        }
        up(offered);
        size ++;
        return true;
    }

    /**
     * 将offered元素上浮，直到offered小于父元素或到堆顶
     * @param offered
     */
    private void up(int offered){
        int child  = size;
        while (child > 0){
            int parent = (child -1)/2;
            if(offered < array[parent]){
                //将父元素上浮
                array[child] = array[parent];
            }else{
                break;
            }
            child = parent;
        }
        array[child] = offered;
    }

    public static void main(String[] args) {
        int[] array = {1,2,3,4,5,6,7};
        //建堆测试
        MaxHeap maxHeap = new MaxHeap(array);
        System.out.println(Arrays.toString(maxHeap.array));
    }
}
```
求第k大的元素
```java
public class FindKthlargest {


    public static int findKthlargest(int[] numbers,int k){
        MinHeap heap = new MinHeap(k);
        //添加数组最头部的两个元素
        for (int i = 0; i < k; i++) {
            heap.offer(numbers[i]);
        }
        for (int i = k; i < numbers.length; i++) {
            if(numbers[i] > heap.peek()){
                heap.replace(numbers[i]);
            }
        }
        return heap.peek();
    }

    public static void main(String[] args) {
        System.out.println(findKthlargest(new int[]{2,3,5,6,1,4},4));
    }
}
```

求数据流中的第k大的元素
```java
public class FindKthLargest2 {

    private MinHeap heap;

    public FindKthLargest2(int k,int[] nums){
        heap = new MinHeap(k);
        for (int num : nums) {
            add(num);
        }
    }

    public int add(int val){
        if(!heap.isFull()){
            heap.offer(val);
        }else{
            //替换堆顶元素
            if(val > heap.peek()){
                heap.replace(val);
            }
        }
        //返回堆顶元素
        return heap.peek();
    }
    public static void main(String[] args) {
        FindKthLargest2 largest2 = new FindKthLargest2(3, new int[]{4,5,8,2});
        System.out.println(largest2.add(3));
        System.out.println(largest2.add(10));
        System.out.println(largest2.add(8));
        System.out.println(largest2.add(9));

    }
}
```

**堆的动态扩容**
使用数组的动态扩容
```java
    /**
     * 添加元素到堆的尾部
     * @param offered
     */
    public boolean offer(int offered){
        if(size == array.length){
            //进行扩容
            grow();
        }
        up(offered);
        size ++;
        return true;
    }

    /**
     * 扩容
     */
    private void grow(){
        //扩容1.5倍
        int capacity = size + (size >> 1);
        int[] newArray = new int[capacity];
        System.arraycopy(array,0,newArray,0,size);
        array = newArray;
    }
```

## 二叉树
最多有两个字节点的树结构
大顶堆是一种完全二叉树，除了最后一层以外，其他层都是被填满的树
二叉树可以使用数组（大顶堆）和树节点来表示
### 二叉树遍历
广度优先遍历：尽可能访问距离根节点最近的节点（层序遍历）
深度优先遍历：
  * 先序遍历 ： 先遍历根节点，再遍历子节点，先左后右
  * 中序遍历：  先遍历左节点，再遍历父节点，最后遍历右节点
  * 后序遍历：  先遍历左节点，再遍历右节点，最后遍历父节点
三种遍历实现
递归实现
```java
public class TreeTraversal {

    public static void main(String[] args) {
        //定义一棵树
        TreeNode root = new TreeNode(
                1,
                new TreeNode(2,new TreeNode(4),null),
                new TreeNode(3,new TreeNode(5),new TreeNode(6))
        );
        //前序遍历
//        preOrder(root);
        //中序遍历
        inOrder(root);
    }

    /**
     * 前序遍历
     * @param node
     */
    static void preOrder(TreeNode node){
        if(node == null){
            return;
        }
        //当前节点值
        System.out.print(node.getVal() + "\t");
        //左子树
        preOrder(node.getLeft());
        //右子树
        preOrder(node.getRight());
    }

    /**
     * 中序遍历
     * @param node
     */
    static void inOrder(TreeNode node){
        if(node == null){
            return;
        }
        //左子树
        inOrder(node.getLeft());
        //当前节点值
        System.out.print(node.getVal() + "\t");
        //右子树
        inOrder(node.getRight());
    }

    /**
     * 后序遍历
     * @param node
     */
    static void postOrder(TreeNode node){
        if(node == null){
            return;
        }
        //左子树
        postOrder(node.getLeft());
        //右子树
        postOrder(node.getRight());
        //当前节点值
        System.out.print(node.getVal() + "\t");
    }
}
```
非递归实现
```java
package com.steven.dataalg.tree.binary;

import com.steven.dataalg.stack.LinkedListStack;

import java.util.LinkedList;

/**
 * @Description: 实现树的遍历，非递归实现,使用栈记录遍历返回的路径,绕树一圈
 * @CreateDate: Created in 2023/8/24 08:33
 * @Author: lijie3
 */
public class TreeTraversal2 {

    public static void main(String[] args) {
        //定义一棵树
        TreeNode root = new TreeNode(
                1,
                new TreeNode(2,new TreeNode(4),null),
                new TreeNode(3,new TreeNode(5),new TreeNode(6))
        );
        preOrder(root);
        inOrder(root);
        postOrder(root);

    }

    /**
     * 前序遍历
     * @param node
     */
    static void preOrder(TreeNode node){
        commonOrder(node,1);
    }

    /**
     * 中序遍历
     * @param node
     */
    static void inOrder(TreeNode node) {
        commonOrder(node,2);
    }
    /**
     * 后序遍历
     * @param node
     */
    static void postOrder(TreeNode node){
        commonOrder(node,3);
    }

    /**
     * 遍历方法
     * @param node
     * @param orderType
     */
    static void commonOrder(TreeNode node,int orderType){
        LinkedList<TreeNode> stack = new LinkedList<>();
        TreeNode curr = node;
        //最近一次弹出栈的元素
        TreeNode pop = null;
        while (curr != null || !stack.isEmpty()){
            if(curr != null){
                //通过栈记录返回的路径
                stack.push(curr);
                //前序遍历
                if(orderType == 1){
                    System.out.println("前："+ curr.getVal());
                }
                //处理柚子树
                curr = curr.getLeft();
            }else{
                //不弹出栈顶元素
                final TreeNode peek = stack.peek();
                //没有右子树
                if(peek.getRight() == null){
                    if(orderType == 2){
                        System.out.println("中："+ peek.getVal());
                    }
                    pop = stack.pop();
                    if(orderType == 3) {
                        System.out.println("后：" + pop.getVal());
                    }
                    //右子树处理完成
                }else if( peek.getRight() == pop){
                    pop = stack.pop();
                    if(orderType == 3) {
                        System.out.println("后：" + pop.getVal());
                    }
                    //待处理的右子树
                }else{
                    if(orderType == 2) {
                        System.out.println("中：" + peek.getVal());
                    }
                    curr = peek.getRight();

                }
            }
        }
    }
}
```


检查二叉树是否对称
```java
public class SymmetryTree {
    public static boolean  isSymmetryTree(TreeNode root){
        return check(root.getLeft(),root.getRight());
    }

    private static boolean check(TreeNode left, TreeNode right) {
        if(left == null && right == null){
            return true;
        }
        //上一个判断已经确定了left和right必然有一个不能为null
        // left和right不能同时为null
        if(left == null || right ==null){
            return false;
        }
//        if(left != null && right == null){
//            return false;
//        }
//        if(left == null && right != null){
//            return false;
//        }
        if(left.getVal() != right.getVal()){
            return false;
        }
        return check(left.getLeft(),right.getRight())&& check(left.getRight(),right.getLeft());

    }

    public static void main(String[] args) {
        //定义一棵树
        TreeNode root = new TreeNode(
                1,
                new TreeNode(2,new TreeNode(4),null),
                new TreeNode(3,new TreeNode(5),new TreeNode(6))
        );
        TreeNode root2 = new TreeNode(
                1,
                new TreeNode(2,new TreeNode(4),null),
                new TreeNode(2,null,new TreeNode(4))
        );
        System.out.println(isSymmetryTree(root2));
    }
}
```




## 搜索二叉树 Binary Search Tree ，BST
特点：
* 节点结构： 每个节点最多有两个子节点，称为左子节点和右子节点。
* 节点值： 对于每个节点，其值大于其左子树中的所有节点值，且小于其右子树中的所有节点值。这个特性使得二叉搜索树具有自组织和快速查找的能力。
* 中序遍历： 通过对二叉搜索树进行中序遍历，可以得到一个递增的节点值序列。
## 平衡二叉树
是一棵空树或它的左右两个子树的高度差的绝对值不超过1，且左右两个子树都是一颗平衡二叉树。

### 红黑树
红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，它在插入和删除操作时会自动进行平衡调整，以保持树的高度较低，从而保持了较快的查找、插入和删除操作的性能。红黑树的一个重要应用是在各种编程语言的标准库中，用于实现诸如集合、映射等数据结构，以保持高效的操作。
红黑树自平衡：
> 节点是红色或黑色。
> 根是黑色。
> 所有叶子都是黑色（叶子是NIL节点）。
> 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
> 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）
java中的HashMap
HashMap 使用了红黑树来优化查找操作。具体来说，当 HashMap 中的某个桶（bucket）中的链表（或链表的长度达到一定阈值）变得过长时，会将链表转换为红黑树，以保持查找操作的性能。
以下是 HashMap 使用红黑树的一般过程：
* 插入元素： 当往 HashMap 中插入元素时，首先会根据元素的键（Key）计算哈希值，并确定将元素放入哪个桶中。如果该桶中已经有元素存在，就需要在链表或红黑树中进行插入操作。
* 链表转换： 当某个桶中的链表长度达到一定阈值（默认是8），HashMap 会将链表转换为红黑树。这样做是为了提高查找操作的性能，因为红黑树的查找复杂度是 O(log n)，而链表的查找复杂度是 O(n)。
* 平衡调整： 在插入元素或进行其他操作时，红黑树会根据红黑树的性质自动进行平衡调整，以保持树的平衡状态。
* 查找元素： 在查找元素时，HashMap 首先计算键的哈希值，然后根据哈希值找到对应的桶。如果该桶中是链表，就进行链表的线性查找；如果是红黑树，就进行红黑树的查找操作。
需要注意的是，虽然红黑树能够提高查找操作的性能，但它的插入和删除操作的开销相对较大。因此，在元素数量较少或频繁进行插入和删除操作的情况下，链表可能更加高效。HashMap 在设计时综合考虑了这些因素，根据实际情况选择使用链表或红黑树，以达到较好的性能平衡。


红黑树简单实现
```java
public class RedBlackTree<Key extends Comparable<Key>, Value> {
    private static final boolean RED = true;
    private static final boolean BLACK = false;

    private Node root;

    private class Node {
        Key key;
        Value value;
        Node left, right;
        boolean color;

        Node(Key key, Value value) {
            this.key = key;
            this.value = value;
            this.color = RED;
        }
    }

    private boolean isRed(Node node) {
        if (node == null) return false;
        return node.color == RED;
    }

    private Node rotateLeft(Node node) {
        Node x = node.right;
        node.right = x.left;
        x.left = node;
        x.color = node.color;
        node.color = RED;
        return x;
    }

    private Node rotateRight(Node node) {
        Node x = node.left;
        node.left = x.right;
        x.right = node;
        x.color = node.color;
        node.color = RED;
        return x;
    }

    private void flipColors(Node node) {
        node.color = RED;
        node.left.color = BLACK;
        node.right.color = BLACK;
    }

    public void put(Key key, Value value) {
        root = put(root, key, value);
        root.color = BLACK;
    }

    private Node put(Node node, Key key, Value value) {
        if (node == null) return new Node(key, value);

        int cmp = key.compareTo(node.key);
        if (cmp < 0) node.left = put(node.left, key, value);
        else if (cmp > 0) node.right = put(node.right, key, value);
        else node.value = value;

        if (isRed(node.right) && !isRed(node.left)) node = rotateLeft(node);
        if (isRed(node.left) && isRed(node.left.left)) node = rotateRight(node);
        if (isRed(node.left) && isRed(node.right)) flipColors(node);

        return node;
    }

    // 其他操作如查找、删除等可以继续实现

    public static void main(String[] args) {
        RedBlackTree<Integer, String> rbTree = new RedBlackTree<>();
        rbTree.put(3, "Three");
        rbTree.put(1, "One");
        rbTree.put(5, "Five");

        System.out.println(rbTree.root.key);  // Output: 3
    }
}
```

### 求二叉树最大深度
```java
package com.steven.dataalg.tree.binary;

import java.util.LinkedList;
import java.util.Queue;

/**
 * @Description:
 * @CreateDate: Created in 2023/8/30 09:22
 * @Author: lijie3
 */
public class TreeMaxDeep {

    /**
     * 递归方式
     * @param node
     * @return
     */
    public static int maxDepth(TreeNode node){
        if(node == null){
            return 0;
        }
        if(node.getLeft() == null && node.getRight() == null){
            return 1;
        }
        int d1 = maxDepth(node.getLeft());
        int d2 = maxDepth(node.getRight());
        return Integer.max(d1,d2) + 1;
    }


    /**
     * 使用非递归的方式实现,使用后序遍历实现,借助与栈来实现后序遍历
     * @param root
     * @return
     */
    public static int maxDepth2(TreeNode root){
        TreeNode curr = root;

        TreeNode pop = null;

        LinkedList<TreeNode> stack = new LinkedList<>();
        int max = 0;
        while(curr != null || !stack.isEmpty()){
            if(curr != null){
                stack.push(curr);
                final int size = stack.size();
                if(size > max){
                    max = size;
                }
                curr = curr.getLeft();
            }else{
                final TreeNode peek = stack.peek();
                //右子树处理完成
                if(peek.getRight() == null || peek.getRight()  == pop){
                    pop = stack.pop();
                }else{
                    curr = peek.getRight();
                }
            }
        }
        return max;
    }

    /**
     * 使用层序遍历计算最大深度
     * @param node
     * @return
     */
    public static int maxDepth3(TreeNode node){
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(node);
//        int c1 = 1;
        int depth = 0;
        while (!queue.isEmpty()){
            //queue.size();
//            int c2 = 0;
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode poll = queue.poll();
                if(poll.getLeft()!= null){
                    queue.offer(poll.getLeft());
//                    c2 ++;
                }
                if(poll.getRight()!=null){
                    queue.offer(poll.getRight());
//                    c2 ++;
                }
            }
//            c1 = c2;
//            System.out.println();
            depth++;
        }
        return depth;
    }



    public static void main(String[] args) {
        TreeNode root = new TreeNode(
                1,
                new TreeNode(2,new TreeNode(4),null),
                new TreeNode(3,new TreeNode(5),new TreeNode(6))
        );
        System.out.println(maxDepth(root));
        System.out.println(maxDepth2(root));
        System.out.println(maxDepth3(root));
    }

}

```
查找叶子节点最小深度
```java
package com.steven.dataalg.tree.binary;

import java.util.LinkedList;
import java.util.Queue;

/**
 * @Description: 求二叉树的最小深度,叶子节点的最小层数
 * @CreateDate: Created in 2023/8/30 13:22
 * @Author: lijie3
 */
public class TreeMinDeep {

    /**
     * 求二叉树的最小深度，使用后序遍历的方式实现，递归
     * @param node
     * @return
     */
    public static int minDepth(TreeNode node){
        if(node == null){
            return 0;
        }

        int d1 = minDepth(node.getLeft());
        int d2 = minDepth(node.getRight());
        //当右子树为null时，返回左子树深度+1
        if(d2 == 0){
            return d1 +1;
        }
        if(d1 == 0){
            return d2 + 1;
        }
        return Integer.min(d1,d2) + 1;
    }

    /**
     * 使用层序遍历的方式取最小深度
     * @param node
     * @return
     */
    public static int minDepth2(TreeNode node){
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(node);
//        int c1 = 1;
        int depth = 0;
        while (!queue.isEmpty()){
            int size = queue.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode poll = queue.poll();
                if(poll.getLeft() == null && poll.getRight() == null){
                    return depth;
                }
                if(poll.getLeft()!= null){
                    queue.offer(poll.getLeft());
                }
                if(poll.getRight()!=null){
                    queue.offer(poll.getRight());
                }
            }
        }
        return depth;
    }

    public static void main(String[] args) {
        TreeNode root = new TreeNode(
                1,
                new TreeNode(2,new TreeNode(4),null),
                new TreeNode(3,new TreeNode(5),new TreeNode(6))
        );
        System.out.println(minDepth(root));
        System.out.println(minDepth2(root));
    }
}
```
翻转二叉树
```java
package com.steven.dataalg.tree.binary;

/**
 * @Description: 翻转二叉树
 * @CreateDate: Created in 2023/8/30 13:48
 * @Author: lijie3
 */
public class TreeInvert {

    /**
     * 翻转二叉树
     *
     * @param node
     * @return
     */
    public static TreeNode invertTree(TreeNode node) {
        fn(node);
        return node;
    }

    private static void fn(TreeNode node) {
        if(node == null){
            return;
        }
        TreeNode t = node.getLeft();
        node.setLeft(node.getRight());
        node.setRight(t);
        fn(node.getLeft());
        fn(node.getRight());
    }
}
```

使用二叉树构建逆波兰表达式
```java
    /**
     * 树实现后缀表达式-逆波兰表达式，二叉树的后序遍历
     *
     * @param tokens
     * @return
     */
    public TreeNodeC<String> constructExpressionTree(String[] tokens) {
        LinkedList<TreeNodeC<String>> stack = new LinkedList<>();
        for (String token : tokens) {
            switch (token) {
                case "+":
                case "-":
                case "*":
                case "/": {
                    //遇到符号将左右两边的数值弹出
                    TreeNodeC<String> right = stack.pop();
                    TreeNodeC<String> left = stack.pop();
                    TreeNodeC<String> root = new TreeNodeC<>(token);
                    root.setLeft(left);
                    root.setRight(right);
                    stack.push(root);
                    break;
                }
                default: {
                    //遇到数字则将数值压入栈顶
                    stack.push(new TreeNodeC(token));
                }
            }
        }
        return stack.pop();
    }
```
已知前序中序遍历，求解树
```java
public static TreeNode buildTree(int[] preOrder,int[] inOrder){
        if(preOrder.length == 0 || inOrder.length == 0){
            return null;
        }
        int rootValue = preOrder[0];
        //根节点
        TreeNode root = new TreeNode(rootValue);

        for (int i = 0; i < inOrder.length; i++) {
            //找到在中序遍历中的根节点
            if(inOrder[i] == rootValue){
                //左子树
                int[] inLeft = Arrays.copyOfRange(inOrder,0,i);
                int[] inRight = Arrays.copyOfRange(inOrder,i+1,inOrder.length);
                int[] preLeft = Arrays.copyOfRange(preOrder, 1, i + 1);
                int[] preRight = Arrays.copyOfRange(preOrder,i+1,inOrder.length);
                root.setLeft(buildTree(preLeft,inLeft));
                root.setRight(buildTree(preRight,inRight));
                //找到根节点后停止
                break;
            }
        }
        return root;
    }
```
根据中序后序遍历求解树
```java
 /**
     * 根据中序后序遍历求解树，所有节点的值不会重复
     * inOrder  = [4,2,1,6,3,7]
     * postOrder = [4,2,6,7,3,1] 后序遍历的最后一个值是根节点
     * @return
     */
    public static TreeNode buildTree2(int[] inOrder,int[] postOrder){
        if(inOrder.length == 0 || postOrder.length == 0){
            return null;
        }
        //根肌诶单
        int rootValue = postOrder[postOrder.length -1];
        TreeNode root = new TreeNode(rootValue);
        //切分左右子树
        for (int i = 0; i < inOrder.length; i++) {s
            if(inOrder[i] == rootValue){
                int[] inLeft = Arrays.copyOfRange(inOrder,0,i);
                int[] inRight = Arrays.copyOfRange(inOrder,i+1,inOrder.length);
                int[] postLeft = Arrays.copyOfRange(postOrder,0,i);
                int[] postRight =  Arrays.copyOfRange(postOrder,i,inOrder.length);
                break;
            }
        }
        return root;
    }
```

### 二叉搜索树
实现快速查找
在加入元素时就已经将元素排好序
特征：
* 树节点上增加一个key属性，用来比较谁大谁小，key不可以重复
* 对于任意一个树节点，他的key比左子树的key都大，同时比右子树的key都小
* 任意节点的左右子树也是一颗二叉搜索树

#### 二叉搜索树的实现
```java
package com.steven.dataalg.tree.binarysearchtree;

import com.steven.dataalg.tree.binary.TreeNode;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * @Description: 二叉搜索树
 * @CreateDate: Created in 2023/9/1 08:52
 * @Author: lijie3
 */
public class BSTTree2<T extends Comparable<T>, V> {

    //根节点
    BSTNode<T, V> root;

    /**
     * 根据key找到节点对应的值,使用递归方式实现
     * 从根节点开始，对key进行比较查找
     *
     * @param key
     * @return
     */
//    public Object get(int key){
//        return doGet(root,key);
//    }
    private V doGet(BSTNode<T, V> node, T key) {
        //没找到返回null
        if (node == null) {
            return null;
        }
        int result = key.compareTo(node.key);
        if (result < 0) {
            //向左找,尾递归时可以转化为非递归形式
            return doGet(node.left, key);
        } else if (result > 0) {
            //向右找
            return doGet(node.right, key);
        } else {
            return node.value;
        }
    }

    /**
     * 使用非递归的方式实现
     *
     * @param key
     * @return
     */
    public V get(T key) {
        BSTNode<T, V> node = root;
        while (node != null) {
            int result = key.compareTo(node.key);
            if (result < 0) {
                node = node.left;
            } else if (result > 0) {
                node = node.right;
            } else {
                return node.value;
            }
        }
        return null;
    }


    /**
     * 获得最小key关联的值,向左走查找最小的子节点
     *
     * @return
     */
//    public V min(){
//        return doMin(root);
//    }
    public V doMin(BSTNode<T, V> node) {
        if (root == null) {
            return null;
        }
        if (node.left == null) {
            return node.value;
        }
        //尾递归，可转化为非递归
        return doMin(node.left);
    }

    /**
     * 非递归实现
     *
     * @return
     */
    public V min() {

        return min(root);
    }

    /**
     * 从某一节点查找最小值
     *
     * @param node
     * @return
     */
    private V min(BSTNode<T, V> node) {
        if (node == null) {
            return null;
        }
        BSTNode<T, V> p = root;
        while (p.left != null) {
            p = p.left;
        }
        return p.value;
    }

    /**
     * 获得最大key关联的值,找最右边的子树
     *
     * @return
     */
    public Object max() {

        return max(root);
    }

    /**
     * 查找从某一节点开始的最大值
     *
     * @param node
     * @return
     */
    private V max(BSTNode<T, V> node) {
        if (node == null) {
            return null;
        }
        BSTNode<T, V> p = root;
        while (p.right != null) {
            p = p.right;
        }
        return p.value;
    }

    /**
     * 存储关键字对应的值
     *
     * @param key
     * @param value
     */
    public void put(T key, V value) {
        //1. key存在，则更新
        BSTNode<T, V> node = root;
        BSTNode<T, V> parent = null;
        while (node != null) {
            //记录父节点，父节点是叶子节点
            parent = node;
            int result = key.compareTo(node.key);
            if (result < 0) {
                node = node.left;
            } else if (result > 0) {
                node = node.right;
            } else {
                //更新key对应的value
                node.value = value;
                return;
            }
        }
        //2. key不存在，新增，父节点是叶子节点
        BSTNode<T, V> newNode = new BSTNode<>(key, value);
        if (parent == null) {
            root = newNode;
        }
        int result = parent.key.compareTo(key);
        if (result > 0) {
            parent.left = newNode;
        } else {
            parent.right = newNode;
        }

    }


    /**
     * 找到关键字的前驱值
     * 方式1：对二叉树进行中序遍历就是对二叉树的key值进行排序，效率较低
     * 方式2：当存在左子树时，前任节点时左子树中的最大值，当不存在左子树时，如果离他最近的祖先从左而来，则该祖先节点就是前驱节点
     * 这里使用方式2
     *
     * @param key
     * @return
     */
    public V succesor(T key) {
        //查找当前节点
        BSTNode<T, V> p = root;
        BSTNode<T, V> ancestorFromLeft = null;
        while (p != null) {
            int result = key.compareTo(p.key);
            if (result < 0) {
                p = p.left;
            } else if (result > 0) {
                ancestorFromLeft = p;
                p = p.right;
            } else {
                break;
            }
        }
        //没有找到节点
        if (p == null) {
            return null;
        }
        //1.存在左子树时
        if (p.left != null) {
            return max(p.left);
        }
        //2. 不存在左子树的情况
        return ancestorFromLeft != null ? ancestorFromLeft.value : null;
    }

    /**
     * 找到关键字的后继值
     * 1.当节点存在右子树时，后继节点为右子树的最小值
     * 2.节点没有右子树，离它最近的祖先自右而来，为后继节点
     *
     * @param key
     * @return
     */
    public V predecessor(T key) {
        //查找当前节点
        BSTNode<T, V> p = root;
        BSTNode<T, V> ancestorFromRight = null;
        while (p != null) {
            int result = key.compareTo(p.key);
            if (result < 0) {
                ancestorFromRight = p;
                p = p.left;
            } else if (result > 0) {
                p = p.right;
            } else {
                break;
            }
        }
        //没有找到节点
        if (p == null) {
            return null;
        }
        //1.存在右子树时,右子树最小值
        if (p.right != null) {
            return min(p.right);
        }
        //2. 不存在右子树的情况，右子树中离他最近的，自右而来的节点
        return ancestorFromRight != null ? ancestorFromRight.value : null;
    }

    /**
     * 删除关键字对应的值
     * 1. 删除的节点没有左孩子，将右子树托孤给parent
     * 2. 删除的节点没有右孩子，将左子树托孤给parent
     * 3. 删除节点左右孩子都没有（在1，2的情况中能处理）
     * 4. 删除左右孩子都有，选择后任节点（首先要找到后任节点，将后任节点顶上去，再将后任节点的子节点放到后任节点的副节点）
     *
     * @param key
     * @return
     */
    public V delete(T key) {
        BSTNode<T, V> p = root;
        BSTNode<T, V> parent = null;
        while (p != null) {
            int result = key.compareTo(p.key);
            if (result < 0) {
                parent = p;
                p = p.left;
            } else if (result > 0) {
                parent = p;
                p = p.right;
            } else {
                //找到parent不记录
                break;
            }
        }
        if (p == null) {
            return null;
        }
        //删除情况
        if (p.left == null) {
            //1. 无左孩子
            shift(parent, p, p.right);
        } else if (p.right == null) {
            //2. 无右孩子
            shift(parent, p, p.left);
        } else {
            //3.当左右孩子都有时
            //先找右边的后继节点
            BSTNode<T, V> s = p.right;
            BSTNode<T,V> sParent = p;// 后继节点的父节点
            while (s.left != null) {
                sParent = s;
                s = s.left;
            }
            //当后继节点不相邻时
            if(sParent != p){
                shift(sParent,s,s.right); //后继节点不可能有左孩子
                s.right = p.right;
            }
            //将后继节点顶上去
            shift(parent,p,s);
            s.left = p.left;
        }
        return p.value;
    }

    /**
     * parent 被删除节点父节点
     * deleted 被删除节点
     * child 被顶上去的节点
     * 托孤操作
     */
    private void shift(BSTNode<T, V> parent, BSTNode<T, V> deleted, BSTNode<T, V> child) {
        if (parent == null) {
            //如果时根节点，则直接将孩子节点作为根节点
            root = child;
        } else if (deleted == parent.left) {
            //如果删除节点没有右子树，则将child直接作为父节点的左节点
            parent.left = child;
        } else {
            //如果删除节点没有左子树，则将child直接作为父节点的右节点
            parent.right = child;
        }

    }

    /**
     * 删除递归版本
     * @param key
     * @return
     */
    public V delete2(T key) {
        ArrayList<V> result = new ArrayList<>();
        root = doDelete(root,key,result);
        //没找到
        if(result.isEmpty()){
            return null;
        }
        return result.get(0);
    }

    public BSTNode<T,V> doDelete(BSTNode<T,V> node,T key,ArrayList<V> result){
        if(node == null){
            return null;
        }
        int compare = key.compareTo(node.key);

        if(compare < 0){
            node.left = doDelete(node.left,key,result);
        }
        if(compare > 0){
            node.right = doDelete(node.right,key,result);
        }
        result.add(node.value);
        //只有右孩子的情况
        if(node.left == null){
            return  node.right;
        }

        //只有左孩子的情况
        if(node.right == null){
            return node.left;
        }
        //存在左右孩子时，先找到后继节点
        BSTNode<T,V> s= node.right;
        while (s.left != null){
            s = s.left;
        }
        //对后继节点递归删除，让后继节点取代被删除节点
        s.right = doDelete(node.right,s.key,new ArrayList<>());
        //对后继节点的左右孩子重新赋值
        s.left = node.left;
        return s;
    }

    /**
     * 查找小于某一节点的范围值列表
     * 中序遍历能得到树节点的升序
     * @param key
     * @return
     */
    public List<V> less(T key){
        ArrayList<V> result = new ArrayList<>();
        BSTNode<T,V> p = root;
        LinkedList<BSTNode<T,V>> stack = new LinkedList<>();
        while (p != null || !stack.isEmpty()){
            if(p != null){
                stack.push(p);
                //左
                p = p.left;
            }else{
                //值
                BSTNode<T, V> pop = stack.pop();
                //处理值
                int compare = pop.key.compareTo(key);
                if(compare < 0){
                    result.add(pop.value);
                }else{
                    //由于中序遍历结果是升序，这里不需要再比较
                    break;
                }
                //右
                p = pop.right;
            }
        }
        return result;
    }


    /**
     * 查找大于key的节点列表
     * @param key
     * @return
     */
    public List<V> greater(T key){
        ArrayList<V> result = new ArrayList<>();
        BSTNode<T,V> p = root;
        LinkedList<BSTNode<T,V>> stack = new LinkedList<>();
        while (p != null || !stack.isEmpty()){
            if(p != null){
                stack.push(p);
                //左
                p = p.left;
            }else{
                //值
                BSTNode<T, V> pop = stack.pop();
                //处理值
                int compare = pop.key.compareTo(key);
                //中序遍历是升序，找右边的
                if(compare > 0){
                    result.add(pop.value);
                }
                //右
                p = pop.right;
            }
        }
        return result;
    }

    /**
     * 使用反向中序遍历查找大于key的节点列表
     * @param key
     * @return
     */
    public List<V> greater2(T key){
        ArrayList<V> result = new ArrayList<>();
        BSTNode<T,V> p = root;
        LinkedList<BSTNode<T,V>> stack = new LinkedList<>();
        while (p != null || !stack.isEmpty()){
            if(p != null){
                stack.push(p);
                //右
                p = p.right;
            }else{
                //值
                BSTNode<T, V> pop = stack.pop();
                //处理值
                int compare = pop.key.compareTo(key);
                //中序遍历是升序，找右边的
                if(compare > 0){
                    result.add(pop.value);
                }else{
                    break;
                }
                //左
                p = pop.left;
            }
        }
        return result;
    }

    /**
     * 查在key1 key2之间的节点
     * @param key1
     * @param key2
     * @return
     */
    public List<V> between(T key1,T key2){
        ArrayList<V> result = new ArrayList<>();
        BSTNode<T,V> p = root;
        LinkedList<BSTNode<T,V>> stack = new LinkedList<>();
        while (p != null || !stack.isEmpty()){
            if(p != null){
                stack.push(p);
                //左
                p = p.left;
            }else{
                //值
                BSTNode<T, V> pop = stack.pop();
                //处理值
                int compare1 = pop.key.compareTo(key1);
                int compare2 = pop.key.compareTo(key2);
                if(compare1 >= 0 && compare2 <=0){
                    result.add(pop.value);
                }else{
                    break;
                }
                //右
                p = pop.right;
            }
        }
        return result;
    }



    /**
     * 节点类
     */
    static class BSTNode<T, V> {
        //节点key
        T key;
        //节点值
        V value;
        //左孩子
        BSTNode<T, V> left;
        //右孩子
        BSTNode<T, V> right;

        public BSTNode(T key) {
            this.key = key;
        }

        public BSTNode(T key, V value) {
            this.key = key;
            this.value = value;
        }

        public BSTNode(T key, V value, BSTNode<T, V> left, BSTNode<T, V> right) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }
}

```

#### 二叉搜索树合法判断
```java
package com.steven.dataalg.tree.binarysearchtree;

import java.util.LinkedList;

/**
 * @Description: 二叉搜索树中的算法
 * @CreateDate: Created in 2023/9/4 08:54
 * @Author: lijie3
 */
public class BSTTreeAlg {


    /**
     * 判断二叉搜索树是不是合法的
     * 使用中序遍历来判断是不是符合升序特性，使用非递归方式
     *
     * @param node
     * @return
     */
    public static boolean isValidBST(BSTTree2.BSTNode<Integer, Integer> node) {
        BSTTree2.BSTNode<Integer, Integer> p = node;

        LinkedList<BSTTree2.BSTNode<Integer, Integer>> stack = new LinkedList<>();
        //上一个节点的key,这里使用Long 的最小值
        long prev = Long.MIN_VALUE;
        while (p != null || !stack.isEmpty()) {
            if (p != null) {
                stack.push(p);
                p = p.left;
            } else {
                BSTTree2.BSTNode<Integer, Integer> pop = stack.pop();
                //处理值
                if (prev >= pop.key) {
                    return false;
                }
                prev = pop.key;
                p = pop.right;
            }
        }
        return true;
    }

    /**
     * 判断树是否是合法BST树，使用递归方式实现，使用中序遍历
     *
     * @param node
     * @return
     */
    static long prev = Long.MIN_VALUE;

    public static boolean isValidBST2(BSTTree2.BSTNode<Integer, Integer> node) {
        if (node == null) {
            return true;
        }
        boolean a = isValidBST2(node.left);
        if (!a) {
            return false;
        }
        //比较值
        if (prev >= node.key) {
            return false;
        }
        prev = node.key;
        return isValidBST2(node.right);
    }


    /**
     * 判断树是否是合法的BST
     *
     * @param node
     * @return
     */
    public static boolean isValidBST3(BSTTree2.BSTNode<Integer, Integer> node) {
        return doValid3(node, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private static boolean doValid3(BSTTree2.BSTNode<Integer, Integer> node, long min, long max) {
        if (node == null) {
            return true;
        }
        if (node.key <= min || node.key >= max) {
            return false;
        }
        //分别判断左右孩子
        boolean a = doValid3(node.left, min, node.key);
        boolean b = doValid3(node.right, node.key, max);
        return a && b;
    }
}
```
#### 求BST树中范围内的节点求和
```java
    /**
     * 中序遍历非递归的方式对BST树中某一个范围的节点值求和
     * @param node
     * @return
     */
    public static int rangeSumBST(BSTTree2.BSTNode<Integer, Integer> node,int low,int high){
        BSTTree2.BSTNode<Integer, Integer> p = node;
        LinkedList<BSTTree2.BSTNode<Integer, Integer>> stack = new LinkedList<>();
        int sum = 0;
        //上一个节点的key,这里使用Long 的最小值
        long prev = Long.MIN_VALUE;
        while (p != null || !stack.isEmpty()) {
            if (p != null) {
                stack.push(p);
                p = p.left;
            } else {
                BSTTree2.BSTNode<Integer, Integer> pop = stack.pop();
                //大于hight时直接break
                if(pop.value > high){
                    break;
                }
                //处理值
               if(pop.key >= low){
                   sum +=pop.value;
               }
                p = pop.right;
            }
        }
        return sum;
    }

        /**
     * 对BST树中某一个范围的节点值求和,使用递归方式，从根节点开始比较判断，然后递归求左右子树
     * @param node
     * @param low
     * @param high
     * @return
     */
    public static int rangeSumBST2(BSTTree2.BSTNode<Integer, Integer> node,int low,int high){
        if(node == null){
            return 0;
        }
        if(node.value < low){
            return rangeSumBST2(node, low, high);
        }
        if(node.value > high){
            return rangeSumBST2(node, low, high);
        }
       return node.value + rangeSumBST2(node.left,low,high) + rangeSumBST2(node.right,low,high);
    }
```

#### 已知前序遍历，构建BST树
```java
    /**
     * 8，5，，1，7，10，12
     * 使用前序遍历的数组还原搜索二叉树，数组无重复值，长度大于1,nO(n)
     * @param preorder
     * @return
     */
    public BSTTree2.BSTNode<Integer,Integer> bstFromPreOrder(int[] preorder){
        //根节点
        BSTTree2.BSTNode<Integer,Integer> root = new BSTTree2.BSTNode<>(preorder[0],preorder[0]);
        for (int i = 1; i < preorder.length; i++) {
            int key = preorder[i];
            insert(root,key);
        }
        return root;
    }

    /**
     * 在bst树上插入节点
     * @param node
     * @param key
     * @return
     */
    private BSTTree2.BSTNode<Integer,Integer> insert(BSTTree2.BSTNode<Integer,Integer> node,int key){
        if(node == null){
            return new BSTTree2.BSTNode<Integer,Integer>(key,key);
        }
        if(key < node.key){
            node.left = insert(node.left, key);
        }else if(node.key <key){
            node.right = insert(node.right,key);
        }
        return node;
    }


    /**
     * 使用前序遍历的数组还原搜索二叉树 O(n)
     * 使用上限法，每个节点若成功创建，都有左孩子上线右孩子上线
     * @param preorder
     * @return
     */
    public BSTTree2.BSTNode<Integer,Integer> bstFromPreOrder2(int[] preorder){
        return insert2(preorder,Integer.MAX_VALUE);
    }

    /**
     * max 左右孩子的上限
     */
    int i = 0;
    private BSTTree2.BSTNode<Integer,Integer> insert2(int[] preOrder,int max){
        if(i == preOrder.length){
            return null;
        }
        int val = preOrder[i];
        //超过上限，返回null作为孩子
        if(val > max){
            return null;
        }
        //没有超过，创建节点
        BSTTree2.BSTNode<Integer, Integer> node = new BSTTree2.BSTNode<>(val, val);
        i++;
        node.left = insert2(preOrder,val);
        node.right = insert2(preOrder,max);
        return node;
    }

       /**
     * 已知前序遍历，分治法求解二叉树
     * @param preorder
     * @return
     */
    public BSTTree2.BSTNode<Integer,Integer> bstFromPreOrder3(int[] preorder){
        return partition(preorder,0,preorder.length-1);
    }

    /**
     * 分治函数
     * @param preorder
     * @param start
     * @param end
     * @return
     */
    private BSTTree2.BSTNode<Integer,Integer> partition(int[] preorder,int start ,int end){
        //结束条件
        if(start > end){
            return null;
        }
        BSTTree2.BSTNode<Integer, Integer> root = new BSTTree2.BSTNode<>(preorder[start], preorder[start]);
        int index = start + 1;
        while (index <= end){
            //index是右子树的起点
            if(preorder[index] > preorder[start]){
                break;
            }
            index++;
        }
        //左子树值递归处理
        root.left = partition(preorder,start+1,index -1);
        //右子树值递归处理
        root.right = partition(preorder,index,end);
        return root;
    }
```

#### 求BST树上的最近公共祖先（包括节点自身）
规律：待查找的节点 p q在某一节点的两侧，则这个节点就是最近的公共祖先
```java
   /**
     * 查找两个节点的最近公共祖先（包括自身）
     * 规律：待查找的节点 p q在某一节点的两侧，则这个节点就是最近的公共祖先
     * @param root
     * @param p
     * @param q
     * @return
     */
    public BSTTree2.BSTNode<Integer,Integer> lowestCommonAncestor(BSTTree2.BSTNode<Integer,Integer> root,BSTTree2.BSTNode<Integer,Integer> p,BSTTree2.BSTNode<Integer,Integer> q){
        BSTTree2.BSTNode<Integer,Integer> a = root;
        //节点在同侧时继续循环
        while ((p.key < a.key && q.key < a.key) || (a.key < p.key && a.key < q.key)){
            //判断节点是不是在当前的左侧
            if(p.key < a.key){
                a= a.left;
            }else{
                a = a.right;
            }
        }
        return a;
    }
```

## AVL树--平衡二叉搜索树
当BST出现了不平衡（节点的左右孩子的高度差超过1），可以通过旋转的方式将BST树转化为左右孩子的高度差为1或0的搜索二叉树

* BST树在插入和删除时，节点可能失衡
* 如果在插入和删除时，通过旋转，始终让二叉搜索树保持平衡，称为自平衡的二叉搜索树
* AVL树是二叉搜索树的实现之一

四种BST失衡的情况：
* LL （左左） --一次右旋能解决
失衡节点左边更高
失衡节点的左孩子的bf >=0  即左孩子这边也是左边更高或者等高

* LR （左右） -- 左子树先向左旋转，然后整棵树向右旋转
失衡节点左边更高，bf> 1
失衡节点的左孩子的bf <0 即左孩子是右边更高

* RL（右左） -- 右子树先向右旋，然后整棵树向左旋
失衡节点左边更高
失衡节点的右孩子的bf >=0  即右孩子这边是左边更高或者等高
* RR(右右)  --一次左旋能解决
失衡节点右边更高
失衡节点的右孩子的bf <=0  即右孩子这边也是右边更高或者等高

avl树实现
涉及操作：
1. 节点高度计算
2. 节点自平衡
3. 树左旋、右旋、左右旋、右左旋
4. 添加节点
5. 删除节点
```java
package com.steven.dataalg.tree.binarysearchtree;

/**
 * @Description:
 * @CreateDate: Created in 2023/9/6 08:44
 * @Author: lijie3
 */
public class AVLTree {

    private AVLNode root;

    static class AVLNode {
        int key;

        Object val;

        AVLNode left;

        AVLNode right;
        //节点高度
        int height = 1;

        public AVLNode(int key, Object val) {
            this.key = key;
            this.val = val;
        }

        public AVLNode(int key, Object val, AVLNode left, AVLNode right) {
            this.key = key;
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    /**
     * 求节点高度
     *
     * @param node
     * @return
     */
    private int height(AVLNode node) {
        return node == null ? 0 : node.height;
    }

    /**
     * 更新节点高度
     *
     * @param node
     */
    private void updateHeight(AVLNode node) {
        //求左右孩子的高度的大的一个，再+1
        node.height = Integer.max(height(node.left), height(node.right)) + 1;

    }

    /**
     * 求左右子树高度差
     *
     * @param node
     * @return 返回0 -1 1 表示树是平衡的 bf >1 左子树太高  bf < -1 右子树太高
     */
    //平衡因子（blance factor） =  左子树 高度 - 右子树高度
    private int bf(AVLNode node) {
        return height(node.left) - height(node.right);
    }

    /**
     * 右旋
     *
     * @param red 要旋转的节点
     * @return
     */
    private AVLNode rightRotate(AVLNode red) {
        AVLNode yellow = red.left;
        //绿色节点换爹
        AVLNode green = yellow.right;
        red.left = green;
        //可以使用一行代码实现
//        red.left = yellow.right;
        //黄色节点上位
        yellow.right = red;
        //旋转之后高度需要更新,需要更新红黄，不能更改更新顺序
        updateHeight(red);
        updateHeight(yellow);
        return yellow;
    }

    /**
     * 左旋
     *
     * @param red 要旋转的节点
     * @return
     */
    private AVLNode leftRotate(AVLNode red) {
        AVLNode yellow = red.right;
        AVLNode green = yellow.left;
        yellow.left = red;
        red.right = green;
        //旋转之后高度需要更新,需要更新红黄，不能更改更新顺序
        updateHeight(red);
        updateHeight(yellow);
        return yellow;
    }

    /**
     * 先左旋左子树，再右旋根节点
     *
     * @param node
     * @return
     */
    private AVLNode leftRightRotate(AVLNode node) {
        //传入节点左孩子先左旋
        node.left = leftRotate(node.left);
        //根节点右旋
        return rightRotate(node);

    }

    /**
     * 先左旋右子树，再左旋根节点
     *
     * @param node
     * @return
     */
    private AVLNode rightLeftRotate(AVLNode node) {
        node.right = rightRotate(node.right);
        return leftRotate(node);
    }

    /**
     * 检查节点是否失衡，重新平衡代码
     *
     * @param node
     * @return
     */
    private AVLNode balance(AVLNode node) {
        if (node == null) {
            return null;
        }
        int bf = bf(node);
        //不平衡的四种情况
        //失衡节点左边更高,且左子树左边更高 ,LL
        if (bf > 1 && bf(node.left) >= 0) {
            //只需要右旋
            return rightRotate(node);
            //失衡节点左边更高,且左子树右边更高 ,LR
        } else if (bf > 1 && bf(node.left) < 0) {
            //左右旋
            return leftRightRotate(node);
            //失衡节点右边更高,且右子树左边更高 ,RL
        } else if (bf < -1 && bf(node.right) > 0) {
            //右左旋
            return rightLeftRotate(node);
            //失衡节点右边更高,且右子树右边更高 ,RR
        } else if (bf < -1 && bf(node.right) <= 0) {
            //只需要左旋
            return leftRotate(node);
        }
        return node;
    }

    /**
     * 插入元素
     *
     * @param key
     * @param value
     */
    public void put(int key, Object value) {
        root = doPut(root, key, value);
    }

    private AVLNode doPut(AVLNode node, int key, Object value) {
        //1. 找到空位，创建新节点
        if (node == null) {
            return new AVLNode(key, value);
        }
        //2.可以已经存在，更新
        if (key == node.key) {
            node.val = value;
        }
        //3. 继续查找
        if (key < node.key) {
            //向左找
            node.left = doPut(node.left, key, value);
        } else {
            //向右找
            node.right = doPut(node.right, key, value);
        }
        //更新节点高度
        updateHeight(node);
        //调整节点平衡
        return balance(node);
    }

    /**
     * 删除元素
     *
     * @param key
     */
    public void remove(int key) {
        root = doRemove(root, key);
    }

    private AVLNode doRemove(AVLNode node, int key) {
        //1.node为空返回
        if (node == null) {
            return null;
        }
        //2.没找到key时继续递归
        if (key < node.key) {
            node.left = doRemove(node.left, key);
        } else if (node.key < key) {
            node.right = doRemove(node.right, key);
        } else {
            //3. 找到了key， 分几种情况：没有孩子、有一个孩子、有两个孩子
            if (node.left == null && node.right == null) {
                return null;
            } else if (node.left == null) {
                node = node.right;
            } else if (node.right == null) {
                node = node.left;
            } else {
                //先找到后继节点
                AVLNode s = node.right;
                while (s.left !=null){
                    s = s.left;
                }
                //s是后继节点,删除当前结点，后继节点左右孩子赋值
                s.right = doRemove(node.right,s.key);
                s.left = node.left;
                node = s;
            }
            //
        }
        //4. 更新高度
        updateHeight(node);
        //5. 检查失衡
        return balance(node);

    }
}

```

### 红黑树 自平衡二叉搜索树
与AVL的区别：判断平衡的依据不一样
插入和删除时红黑树的旋转次数更少
特点：
* 所有节点都有两种颜色：红和黑
* 所有的null视为黑色
* 红色节点不能相邻
* 根节点时黑色
* 从根到任意一个叶子节点，路径中的黑色节点数目时一样的（黑色完美平衡）

部分实现
```java
package com.steven.dataalg.tree.binarysearchtree;

/**
 * @Description: 红黑树
 * @CreateDate: Created in 2023/9/7 21:41
 * @Author: lijie3
 */
public class ReadBlackTree {

    private Node root;


    //判断红色,当节点为null时，节点为黑色
    public boolean isRed(Node node) {
        return node != null && node.color == Color.RED;
    }

    //判断黑色
    public boolean isBlack(Node node) {
        return node == null || node.color == Color.BLACK;
    }

    /**
     * 右旋，
     * 1. parent的处理
     * 2. 旋转后的新根的父子关系
     *
     * @param pink
     */
    private void rightRotate(Node pink) {
        Node parent = pink.parent;
        //左孩子
        Node yellow = pink.left;
        //左孩子的右孩子
        Node green = yellow.right;
        if (green != null) {
            green.parent = pink;
        }
        //旋转
        yellow.right = pink;
        yellow.parent = pink.parent;
        pink.left = green;
        pink.parent = yellow;
        if (parent == null) {
            root = yellow;
            //处理parent的关系
        } else if (parent.left == pink) {
            parent.left = yellow;
        } else {
            parent.right = yellow;
        }
    }


    //左旋,与右旋对称
    private void leftRotate(Node pink) {
//        Node parent = pink.parent;
//        //左孩子
//        Node yellow = pink.left;
//        //左孩子的右孩子
//        Node green = yellow.right;
//        if (green != null) {
//            green.parent = pink;
//        }
//        //旋转
//        yellow.right = pink;
//        yellow.parent = pink.parent;
//        pink.left = green;
//        pink.parent = yellow;
//        if (parent == null) {
//            root = yellow;
//            //处理parent的关系
//        } else if (parent.left == pink) {
//            parent.left = yellow;
//        } else {
//            parent.right = yellow;
//        }
    }

    /**
     * 插入或更新
     *
     * @param key
     * @param value
     */
    public void put(int key, Object value) {
        Node p = root;
        Node parent = null;
        while (p != null) {
            parent = p;
            if (key < p.key) {

                p = p.left;
            } else if (p.key < key) {
                p = p.right;
            } else {
                //更新
                p.value = value;
            }
        }
        Node inserted = new Node(key, value);
        //找爹
        if (parent == null) {
            root = inserted;
        } else if (key < parent.key) {
            parent.left = inserted;
            inserted.parent = parent;
        } else {
            parent.right = inserted;
            inserted.parent = parent;
        }
        //调整颜色
        fixRedRed(inserted);

    }

    /**
     * 调整颜色
     */
    private void fixRedRed(Node x) {
        //当插入的是根节点时
        if (x == root) {
            x.color = Color.BLACK;
            return;
        }
        //插入节点的父亲时黑色，无需任何调整
        if (isBlack(x.parent)) {
            return;
        }
        //插入节点为红色
        Node parent = x.parent;
        Node uncle = x.ancle();
        Node grandparent = parent.parent;
        //插入节点副节点为红色
        //叔叔为红色，修改颜色

        if (isRed(uncle)) {
            parent.color = Color.BLACK;
            uncle.color = Color.BLACK;
            grandparent.color = Color.RED;
            fixRedRed(grandparent);
            return;
        }
        //叔叔为黑色，需要进行旋转
        //左左
        if (parent.isLeftChild() && x.isLeftChild()) {
            parent.color = Color.BLACK;
            grandparent.color = Color.RED;
            //祖父右旋
            rightRotate(grandparent);
            //左右
        } else if (parent.isLeftChild() && !x.isLeftChild()) {
            leftRotate(parent);
            x.color = Color.BLACK;
            grandparent.color = Color.RED;
            rightRotate(grandparent);
            //右右
        } else if (!parent.isLeftChild() && !x.isLeftChild()) {
            parent.color = Color.BLACK;
            leftRotate(grandparent);
            //右左
        } else {
            rightRotate(parent);
            x.color = Color.BLACK;
            grandparent.color = Color.RED;
            leftRotate(grandparent);
        }
    }

    /**
     * 删除
     *
     * @param key
     */
    public void remove(int key) {
        Node deleted = find(key);
        if (deleted == null) {
            return;
        }
        doRemove(deleted);
    }

    /**
     * 用到李代桃僵的方式，遇到黑黑不平衡进行调整
     * 删除黑色节点会失衡，删除红色节点会失衡
     *
     * @param deleted
     */
    private void doRemove(Node deleted) {
        Node replaced = findReplaced(deleted);
        Node parent = deleted.parent;
        //没有孩子
        if (replaced == null) {
            //删除的节点是根节点
            if (deleted == null) {
                root = null;
            } else {
                //先调整，后删除
                if(isBlack(deleted)){
                    //复杂调整
                    fixDoubleBlack(deleted);
                }else{
                    //红色不需要处理
                }
                if (deleted.isLeftChild()) {
                    parent.left = null;
                } else {
                    parent.right = null;
                }
                deleted.parent = null;
            }
            return;
        }
        //有一个孩子的情况
        if (deleted.left == null || deleted.right == null) {
            //删除的是根节点，有一个孩子
            if (deleted == root) {
                root.key = replaced.key;
                root.value = replaced.value;
                root.left = root.right = null;
            }else{
                if(deleted.isLeftChild()){
                    parent.left = replaced;
                }else{
                    parent.right = replaced;
                }
                replaced.parent = parent;
                deleted.left = deleted.right = deleted.parent = null;
                if(isBlack(deleted) && isBlack(replaced)){
                    //复杂调整，先删除后调整
                    fixDoubleBlack(replaced);
                }else{
                    replaced.color = Color.BLACK;
                }
            }
            return;
        }
        //有两个孩子的情况
        //交换两个节点,转化为有一个孩子或没有孩子的节点删除情况
        int t = deleted.key;
        deleted.key = replaced.key;
        replaced.key = t;

        Object v = deleted.value;
        deleted.value = replaced.value;
        replaced.value = v;
        doRemove(replaced);
    }

    private void fixDoubleBlack(Node x){
        if(x ==root){
            return;
        }
        Node parent = x.parent;
        Node sibling = x.sibling();
        if(isRed(sibling)){
            if(x.isLeftChild()){
                leftRotate(parent);
            }else{
                rightRotate(parent);
            }
            parent.color = Color.RED;
            sibling.color = Color.BLACK;
            fixDoubleBlack(x);
            return;
        }
    }

    /**
     * 查找节点
     *
     * @param key
     * @return
     */
    Node find(int key) {
        Node p = root;
        while (p != null) {
            if (key < p.key) {
                p = p.left;
            } else if (p.key < key) {
                p = p.right;
            } else {
                return p;
            }
        }
        return null;
    }

    //查找删除后的后继节点
    Node findReplaced(Node deleted) {
        if (deleted.left == null && deleted.right == null) {
            return null;
        }
        if (deleted.left == null) {
            return deleted.right;
        }
        if (deleted.right == null) {
            return deleted.left;
        }
        //查找后继节点
        Node s = deleted.right;
        while (s.left != null) {
            s = s.left;
        }
        return s;
    }


    //颜色枚举
    enum Color {
        RED, BLACK;
    }

    private static class Node {

        int key;

        Object value;

        Node left;

        Node right;
        //父节点
        Node parent;

        Color color;

        public Node(int key, Object value) {
            this.key = key;
            this.value = value;
        }

        //是否是左孩子
        boolean isLeftChild() {
            return parent != null && parent.left == this;
        }

        //找叔叔
        public Node ancle() {
            //没有父亲或没有爷爷
            if (parent == null || parent.parent == null) {
                return null;
            }
            if (parent.isLeftChild()) {
                return parent.parent.right;
            } else {
                return parent.parent.left;
            }
        }

        //找兄弟
        Node sibling() {
            if (parent == null) {
                return null;
            }
            if (this.isLeftChild()) {
                return parent.right;
            } else {
                return parent.left;
            }
        }
    }
}
```


### B-树
自平衡的树形结构，用于解决磁盘存储器上的数据管理问题，B-树的设计目标是减少磁盘IO操作的次数
100万的数据，用AVL来存储，树的高度是20，用B-树存储，树的高度大约是3，树的高度越低，磁盘IO次数越少
描述B树的两个名词：
度： degree，指树中节点孩子数
阶：order,指的是所有节点孩子数最大值

B-树的特性：
每个节点最多有m个孩子，称为树的阶数
孩子数： ceil(m/2)~m
关键字数： ceil(m/2)-1 ~ m-1
* 每个节点最多有m个孩子，其中m称为B-树的阶
* 除根节点和叶子节点以外，其他每个节点至少有ceil(m/2)个孩子

自平衡性：B-树是自平衡的数据结构，这意味着在插入和删除操作后，它会自动重新平衡，以保持树的高度相对较小，从而保持高效的查找性能。
多路搜索树：每个节点可以包含多个子节点，这就是B-树名称中的"B"的含义。这意味着每个节点可以存储多个关键字和对应的值，而不仅仅是二叉树中的两个子节点。
有序性：B-树的关键字在每个节点中是有序的，这使得范围查询非常高效，因为你可以在树中沿着有序的路径移动，而不需要全局排序。
高度平衡：B-树的高度相对较小，通常是平衡二叉树的高度的一个常数倍。这意味着查找、插入和删除操作的平均时间复杂度是O(log n)，其中n是树中节点的数量。
多级索引：B-树通常用于数据库系统中的索引结构。根节点到叶子节点的路径上的每个节点都可以看作是一个索引层级，这使得数据库能够快速定位和检索数据。
支持动态操作：B-树是一种适合频繁插入和删除操作的数据结构。由于其自平衡特性，即使在数据动态变化的情况下，也能保持高效的性能。
磁盘友好：B-树的设计考虑了磁盘存储的特点，因此它能够最小化磁盘访问次数，提高磁盘IO的效率。这使得B-树非常适合用于文件系统和数据库管理。


### hash表
给每个数据分配一个编号，放入表格
建立编号与表格的索引的关系，将来就可以i通过编号快速查找数据

存在的问题：
理想情况下编号为宜，数组能容纳所有数据
现实是不能为了容纳所有数据创建一个超大的数组，而且编号也有可能出现重复的情况

解决方案：
* 有限长度的数组，以拉链的方式存储数据（拉链法）
* 允许编号适当重复，通过数据自身来进行区分

按位与求hash码
* 计算哈希码使用按位与&替换求模运算%，这样做是因为按位与运算效率更高，而使用求模运算的前提是数组长度是2^n
* 在扩容时也需要保证数组长度是2^n
* HashTable的没有使用2^n的数组长度，数组初始长度为11
* jdk 的HashMap在链表长度过长时会转换为红黑树，避免由于冲突过多导致长度过长的问题，一般情况下HashMap中链表的长度不会超过8，长度超过8的情况可能是由于恶意攻击产生大量冲突会导致HashMap性能下降

```java
package com.steven.dataalg.hash;

/**
 * @Description: hash表
 * @CreateDate: Created in 2023/9/17 15:47
 * @Author: lijie3
 */
public class HashTable {

    /**
     * 节点类
     */
    static class Entry{
        int hash;

        Object key;

        Object value;

        Entry next;

        public Entry(int hash, Object key, Object value) {
            this.hash = hash;
            this.key = key;
            this.value = value;
        }
    }
    //选择2^n作为容量
    Entry[] table = new Entry[16];
    //元素个数
    int size = 0;
    //负载因子
    float loadFactor = 0.75f;
    //默认阈值 12
    int threshold = (int) (loadFactor * table.length);


    //计算哈希码使用按位与&替换求模运算%，这样做是因为按位与运算效率更高，而使用求模运算的前提是数组长度是2^n
    //与数组长度 -1 按位与

    /**
     * 查询方法
     * @param hash
     * @param key
     * @return
     */
    Object get(int hash,Object key){
        int index = hash & (table.length -1);
        if(table[index] == null){
            return null;
        }
        Entry p = table[index];
        while (p != null){
            if(p.key.equals(key)){
                return p.value;
            }
            p = p.next;
        }
        return null;
    }

    Object get(Object key){
        int hash = getHash(key);
        return get(hash,key);
    }



    /**
     * 插入,使用尾插法，JDK的hashtable使用的头插法
     * @param hash
     * @param key
     * @param value
     */
    void put(int hash,Object key,Object value){
        //计算index
        int index = hash & (table.length -1);

        if(table[index] == null){
            table[index] = new Entry(hash,key,value);

        }else{
            Entry p = table[index];
            while(true){
                if(p.key.equals(key)){
                    //更新
                    p.value = value;
                    return;
                }
                if(p.next == null){
                    break;
                }
                p = p.next;
            }
            //新增
            p.next  = new Entry(hash,key,value);
        }
        //更新size
        size++;
        if(size > threshold){
            resize();
        }
    }

    void put(Object key,Object value){
        int hash = getHash(key);
        put(hash,key,value);
    }

    /**
     * hash表扩容
     */
    private void resize() {
        //扩大为原来的两倍
        Entry[] newTable = new Entry[table.length << 1];

        for (int i = 0; i < table.length; i++) {
            //拿到索引头
            Entry p = table[i];
            if(p != null){
                //拆分链表，移动到新数组
                /**
                 * 拆分规律
                 * 旧数组中的一个链表被拆分成两个新的链表
                 * hash & table.length ==0 的一组， 索引位置原位置不懂
                 * hash & table.length !=0 的一组，索引位置为原索引+旧数组长度
                 */
                //拆分的链表
                Entry a = null;
                Entry b = null;
                //链表的头指针
                Entry aHead = null;
                Entry bHead = null;
                while (p != null){
                    if((p.hash & table.length) == 0){
                        if(a != null){
                            a.next = p;
                        }else{
                            aHead = p;
                        }
                        a  = p;

                    }else{
                        if(b != null){
                            b.next = p;
                        } else{
                            bHead = p;
                        }
                        b = p;
                    }
                    p = p.next;
                }
                if(a != null){
                    a.next = null;
                    newTable[i] = aHead;
                }
                if(b != null){
                    b.next = null;
                    newTable[i + table.length] = bHead;
                }
            }
        }
        table = newTable;
        threshold = (int) (loadFactor * newTable.length);
    }

    /**
     * 根据hash码删除
     * @param hash
     * @param key
     * @return
     */
    Object remove(int hash,Object key){
        int index = hash &  (table.length -1);
        if(table[index] == null){
            return null;
        }
        Entry p = table[index];
        Entry prev = null;
        while (p != null){
            if(p.key.equals(key)){
                //找到了删除
                if(prev == null){
                    //删除链表头
                    table[index] = p.next;
                }else{
                    prev.next = p.next;
                }
                size --;
                return p.value;
            }
            prev = p;
            p = p.next;
        }
        return null;
    }

    /**
     * 使用自定义的hash算法
     * @param key
     * @return
     */
    Object remove(Object key){
        int hash = getHash(key);
        return remove(hash,key);
    }

    private int getHash(Object key) {
        //使用jdk的object.hashcode
        return key.hashCode();
    }

}
```

#### hash算法
将任意长度的数据换成固定长度的算法，常见的hash算法有md5，sha1，sha256，sha512，crc32等

摘要算法
散列算法
生成hash码的方式
* 使用jdk的hashcode方法

与hash表相关的leecode算法题
```java
package com.steven.dataalg.hash;

import java.util.*;
import java.util.stream.Collectors;

/**
 * @Description: hash表相关的一些算法
 * @CreateDate: Created in 2023/9/19 09:55
 * @Author: lijie3
 */
public class HashAlg {

    /**
     * 输入nums = [2,3,x,x,x,],target = 9,求数组中两个数只和为9的两个数
     * <p>
     * 使用hashtable实现
     * 遍历数组，拿到每个数字x
     * 以target-x作为key到hash表查找
     * 没有找到则将x作为key，
     * 找到了返回x和它配对数的索引
     *
     * @param nums
     * @param target
     * @return
     */
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int x = nums[i];
            int y = target - x;
            if (map.containsKey(y)) {
                return new int[]{i, map.get(y)};
            } else {
                map.put(x, i);
            }
        }
        return null;
    }

    /**
     * 找出不含重复字符的最长子串长度
     *
     * @param s
     * @return
     */
    public static int lengthOfLongestSubstring(String s) {
        int begin = 0;
        int maxLength = 0;
        HashMap<Character, Integer> map = new HashMap<>();
        for (int end = 0; end < s.length(); end++) {
            char c = s.charAt(end);
            //出现重复
            if (map.containsKey(c)) {
                begin = Math.max(map.get(c) + 1, begin);
                map.put(c, end);
            } else {
                map.put(c, end);
            }
            System.out.println(s.substring(begin, end + 1));
            maxLength = Math.max(maxLength, end - begin + 1);
        }
        return maxLength;
    }

    /**
     * 求字母异位词，字母中只有小写字母
     * tea ate eat 互为字母异位词
     *
     * @param strs
     * @return
     */
    public static List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> map = new HashMap<>();
        for (String str :
                strs) {
            char[] chars = str.toCharArray();
            //对字符串进行排序
            Arrays.sort(chars);
            String key = new String(chars);
            List<String> list = map.get(key);
            map.computeIfAbsent(key, k -> new ArrayList<>());
//            if(list == null){
//                list = new ArrayList<>();
//                //存储到hash表中
//                map.put(key,list);
//            }
            list.add(str);
        }
        return new ArrayList<>(map.values());
    }

    /**
     * 求字母异位词，字母中只有小写字母
     * 使用长度为26的整数数组作为的key,字母相同的放在同一个key中
     * tea ate eat 互为字母异位词
     *
     * @param strs
     * @return
     */
    public static List<List<String>> groupAnagrams2(String[] strs) {
        HashMap<ArrayKey, List<String>> map = new HashMap<>();
        for (String str : strs) {
            ArrayKey key = new ArrayKey(str);
            List<String> list = map.computeIfAbsent(key, k -> new ArrayList<>());
            list.add(str);
        }
        return new ArrayList<>(map.values());
    }

    static class ArrayKey {
        int[] key = new int[26];

        public ArrayKey(String str) {

            for (int i = 0; i < str.length(); i++) {
                char ch = str.charAt(i);
                //找到索引位置
                key[ch - 97]++;
            }
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (!(o instanceof ArrayKey)) {
                return false;
            }
            ArrayKey arrayKey = (ArrayKey) o;
            return Arrays.equals(key, arrayKey.key);
        }

        @Override
        public int hashCode() {
            return Arrays.hashCode(key);
        }
    }

    /**
     * 判断是否存在重复元素
     * 重复返回true
     *
     * @param nums
     * @return
     */
    public boolean containsDuplicate(int[] nums) {
        //使用hashmap
//        HashMap<Integer,Integer> hashMap = new HashMap<>(nums.length * 2);
//        for (int key:nums){
//            Integer put = hashMap.put(key, key);
//            if(put != null){
//                return true;
//            }
//        }
//        return false;
        //使用hashset
        HashSet<Integer> set = new HashSet<>();
        for (int key : nums) {
            if (!set.add(key)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 找出没有重复的数字,数字最多重复一次
     * [2 2 1]
     *
     * @param nums
     * @return
     */
    public int singleNumber(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for (int num :
                nums) {
            if (!set.add(num)) {
                set.remove(num);
            }
        }
        return set.toArray(new Integer[0])[0];
    }

    /**
     * 使用异或
     * 相同数字异或结果是0
     * 任何数字与0异或结果都是数字本身
     * @param nums
     * @return
     */
    public int singleNumber2(int[] nums) {
        int num = nums[0];
        for (int i = 1; i < nums.length; i++) {
            //    * 相同数字异或结果是0
            //     * 任何数字与0异或结果都是数字本身
            num = num ^ nums[i];
        }
        return num;
    }

    /**
     * 判断两个字符串是否是字母异位词
     * @param s
     * @param t
     * @return
     */
    public boolean isAnagram(String s,String t){

        return Arrays.equals(getkey2(s),getkey2(t));
    }

    private int[] getkey(String s){
        int[] array = new int[26];
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i); //'a' -97 = 0;
            array[ch-97]++;
        }
        return array;
    }

    /**
     * 生成key效率更高
     * @param s
     * @return
     */
    private int[] getkey2(String s){
        int[] array = new int[26];
        final char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            char ch = chars[i]; //'a' -97 = 0;
            array[ch-97]++;
        }
        return array;
    }

    /**
     * 查找字符串中的第一个不重复的字符
     * @param s
     * @return
     */
    private int firstUniqChar(String s){
        int[] array  = new int[26];
        char[] chars = s.toCharArray();
        //将次数放入hash表中
        for (char ch : chars) {
            array[ch - 97]++;
        }
        for (int i = 0; i < chars.length; i++) {
            final char ch = chars[i];
            //遇到第一个的就返回
            if(array[ch-97] == 1){
                return i;
            }
        }
        return  -1;
    }

    /**
     * 查找出现最多的单词
     * @param paragraph
     * @param banned 禁用词
     * @return
     */
    public String mostCommonWord(String paragraph,String[] banned){
        final Set<String> set = Arrays.stream(banned).collect(Collectors.toSet());
        //截取
        String[] split = paragraph.toLowerCase().split("[^A-Za-z]+");
        HashMap<String,Integer> map = new HashMap<>();
        for (String key :
                split) {
//            Integer value = map.get(key);
//            if(value == null){
//                value = 0;
//            }
//            map.put(key,value +1);
            //简化代码
            //不在禁用词中的加入到map中
            if(!set.contains(key)){
                map.compute(key,(k,v) -> v == null ?1: v +1);
            }

        }
        System.out.println(map);
        Optional<Map.Entry<String, Integer>> max = map.entrySet().stream().max(Map.Entry.comparingByValue());
        return max.map(Map.Entry::getKey).orElse(null);
    }

    public static void main(String[] args) {
//        System.out.println(lengthOfLongestSubstring("abcabcbb"));
        String[] strs = {"eat", "tea", "tan", "ate", "nat", "bat"};
        final List<List<String>> lists = groupAnagrams(strs);
    }
}
```

### HashMap的底层原理
jdk7中使用数组和链表实现，在插入链表元素时，使用头插法，使用&位运算确定key的table下标
HashMap线程不安全，允许存放key为null的键，存放在数组的index=0的位置
HashTable线程安全，方法上使用synchronized，效率低，不允许存放key为null的键

HashMap的实现方式：
* 无序存放
* 基于数组+链表+红黑树实现

使用hash算法提高key的查找效率
当出现hash冲突时，在1.7时使用的是链表来解决hash之后的key冲突的问题，通过单项链表来解决key hash之后 冲突的问题
Object的hashCode方法是native方法
当链表长度变大时，遍历链表的效率会变低，在1.8时，当链表长度大于8时，链表会被转换为红黑树
当数组长度大于64，链表长度大于等于8时，链表会转化为红黑树，当出现扩容时链表长度小于8时，红黑树会退化为链表

hashmap的扩容
在 JDK 8 中，HashMap 的扩容是通过以下步骤完成的：
当 HashMap 中的元素个数超过了负载因子（load factor）所定义的阈值时，就会触发扩容操作。负载因子是一个表示 HashMap 在何时进行扩容的比例因子。
扩容操作会创建一个新的数组，其大小通常是原数组大小的两倍。新数组的长度始终为2的幂，这是为了保持哈希算法的高效性。
然后，HashMap 会遍历旧数组中的每个元素，并重新计算它们在新数组中的位置，然后将其放置在新的位置上。这个过程确保了相同的元素仍然在相同的索引位置，而不同的元素也能够正确地散列到新的位置上。
在重新分配元素的过程中，可能会出现多个元素散列到新数组的同一个位置上。为了解决这种冲突，每个位置上都会维护一个链表（JDK 8 中采用的是链表，而在后续版本中可能会采用红黑树），将冲突的元素存储在链表中。
需要注意的是，在扩容过程中，HashMap 需要重新计算每个元素的哈希值，并根据新数组的长度来确定它们在新数组中的位置。这是因为新数组的长度不同，所以之前计算的哈希值对新数组可能不再适用。
总的来说，JDK 8 中的 HashMap 扩容通过创建新数组、重新计算元素位置以及处理冲突来完成，从而保证了 HashMap 的高效性能和散列均匀性。

如何高效的将一万个key放入hashMap中
将要存储的数据 10000/0.75 负载因子得到初始化时的大小，避免扩容
* 使用HashMap中提供了一个指定初始化大小的构造方法
* hashmap并不是直接使用构造方法中指定的这个初始化大小，而是经过计算将数值转化为2的n次方，这样在数据存放的过程中可以尽量避免扩容导致效率降低


ConcurrentHashMap 
1.7实现
使用的时分段锁实现 线程安全
使用双层数组
一个数组的元素称为一个segment，一个segment中包含一个数组
对segment进行加锁，只对当前操作的这个segment进行加锁
默认情况下segment能允许16个线程并发

1.8的实现 
node节点使用 cas+synchronized锁的实现
1.8中concurrentHashMap也是由table+链表+红黑树来实现
ConcurrentHashMap的并发安全是使用对Node节点来加锁保证线程安全性
锁的粒度是数组中的某一个节点
引入红黑树降低查询的复杂度 O（log(n)）
当数组长度不够需要扩容时，concurrentHashMap使用了多线程并发扩容，多个线程对原始数据进行数据迁移
size方法
由于多线程并发的操作可能会导致数据累加的结果不准，只是一个估算值
当竞争不激烈时，使用cas实现元素递增计算
当线程竞争激烈，使用数组来维护元素个数，增加总元素个数，直接从数组中随机选择一个，再通过cas算法实现原子递增，分散资源竞争

为什么ConcurrentHashMap不允许key和value为空
避免多线程环境下的判断键值对是否存在的问题可能会出现歧义，当一个线程从ConcurrentHashMap中获取一个值时，如果返回的值时null，可能是因为map中不存在而返回null或因为value就是null，这样就会产生歧义，同样，判断key是否存在时也会出现这样的歧义，这样的歧义会导致线程安全的问题


## 排序算法

### 冒泡排序 
稳定算法，时间复杂度 O(n^2)
递归实现与非递归实现
```java
 /**
     * 递归实现冒泡排序
     * @param a
     */
    public static void sort(int[] a){
        bubble(a, a.length-1);
    }

    /**
     * 递归函数，将最大值交换到最后
     * @param a
     * @param j
     */
    public static void bubble(int[] a,int j){
        if(j == 0){
            return;
        }
        //设置未排序的边界x
        int x = 0;
        for (int i = 0; i < j; i++) {
            if(a[i] > a[i + 1]){
                int t = a[i];
                a[i] = a[i+1];
                a[i+1] = t;
                x = i;
            }
        }
        //在递归时，x左边的是未排序的子序列
        bubble(a,x);
    }

   
    /**
     * 非递归实现冒泡排序
     * @param a
     */
    public static void bubble(int[] a){
        int j = a.length -1;
        while(true){
            //设置未排序的边界x
            int x = 0;
            for (int i = 0; i < j; i++) {
                if(a[i] > a[i + 1]){
                    int t = a[i];
                    a[i] = a[i+1];
                    a[i+1] = t;
                    x = i;
                }
            }
            j = x;
            if(j == 0){
                break;
            }
        }
    } 
```

### 选择排序
交换次数较少，时间复杂度 O(n^2)
在每一轮中选出最小或者最大元素，放在未排序数组的最右边或最左边

```java

public class SelectSort {
    public static void sort(int[] a){
        //1.选择轮数 a.length -1
        for (int right = a.length - 1; right > 0 ; right--) {
            int max = right;
            for (int i = 0; i < right; i++) {
                if(a[i] > a[max]){
                    max = i;
                }
            }
            //2. 交换的索引位置 初始 a.length -1 ,每次递减
            if(max != right){
                swap(a,max,right);
            }
        }
    }

    private static void swap(int[] a,int i ,int j){
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
}
```
### 堆排序
建立一个二叉大顶堆，每次将堆顶的元素移动到数组最右边
时间复杂度 O(logn) ,不稳定的排序算法
算法实现
```java
package com.steven.dataalg.sort;

/**
 * @Description: 堆排序：建立一个大顶堆，每次将堆顶的元素移动到数组最右边,时间复杂度 O(logn) ,不稳定的排序算法
 *               建立二叉大顶堆
 * @CreateDate: Created in 2023/9/21 13:59
 * @Author: lijie3
 */
public class HeapSort {


    public static void sort(int[] a){
        heapify(a,a.length);
        for (int right = a.length -1; right > 0; right --) {
            swap(a,0,right);
            down2(a,0,right);
        }
    }


    /**
     * 建堆，使用弗洛伊德算法
     */
    private static void heapify(int[] array,int size){
        //1.找到最后一个非叶子节点  size/2 -1
        for(int i = size /2 -1; i>=0 ; i-- ){
            //2.对节点进行下潜
            down2(array,i,size);
        }
    }

    /**
     * 下潜，使用递归方式，将parent索引处的元素下潜，与两个孩子较大者交换，直到没有孩子或孩子没它大
     * @param parent
     */
    public static void down(int[] array,int parent,int size){
        //左孩子节点index
        int left = parent * 2 +1;
        //右孩子节点index
        int right = left +1;
        int max = parent;
        if(left < size && array[left] > array[max]){
            max = left;
        }
        if(right < size && array[right] > array[max]){
            max = right;
        }
        if(max != parent){ //找到了更大的孩子
            swap(array,max,parent);
            //递归下潜
            down(array,max,size);
        }
    }

    /**
     * 下潜非递归实现,效率更高
     * @param array
     * @param parent
     * @param size
     */
    public static void down2(int[] array,int parent,int size){
        while (true){
            //左孩子节点index
            int left = parent * 2 +1;
            //右孩子节点index
            int right = left +1;
            int max = parent;
            if(left < size && array[left] > array[max]){
                max = left;
            }
            if(right < size && array[right] > array[max]){
                max = right;
            }
            //没有找到更大的孩子
            if(max == parent){
                break;
            }
            //找到了更大的孩子
            swap(array,max,parent);
            parent = max;
        }

    }
    //交换
    public static void swap(int[] array,int i ,int j){
        int t = array[i];
        array[i]  = array[j];
        array[j] = t;
    }
}
```

#### 插入排序
插入排序，从index为1的元素开始，与前面的元素对比，找到第一个小于当前元素的元素，在该元素后面进行插入
时间复杂度 O（n^2） 适合数据量较小的
```java
package com.steven.dataalg.sort;

/**
 * @Description: 插入排序 时间复杂度 O（n^2） 适合数据量较小的
 * @CreateDate: Created in 2023/9/22 09:53
 * @Author: lijie3
 */
public class InsertionSort {


    /**
     *
     * @param a
     */
    public static void sort(int[] a){
//        insertion(a,1);
        insertion2(a);
    }

    /**
     * 使用递归的方式进行插入
     * @param a
     * @param low
     */
    private static void insertion(int[] a ,int low){
        if(low == a.length){
            return;
        }
        int t = a[low];
        //已排序区域指针
        int i = low - 1;
//        从右向左找，如果找到比t小的第一个值，在其后面插入
        while(i >= 0 &&  a[i] > t){ //没有找到插入位置
            a[i + 1] = a[i];
            i --;
        }
        //找到插入位置,进行赋值,当找到的的i = -1时，则在索引0位置插入
        //当需要移动时才插入
        if(i+1 != low){
            a[i+1] = t;
        }
        insertion(a,low +1);
    }

    /**
     * 非递归方式
     * @param a
     */
    private static void insertion2(int[] a ){
        for (int low = 1; low < a.length-1; low++) {
            int t = a[low];
            //已排序区域指针
            int i = low - 1;
//        从右向左找，如果找到比t小的第一个值，在其后面插入
            while(i >= 0 &&  a[i] > t){ //没有找到插入位置
                a[i + 1] = a[i];
                i --;
            }
            //找到插入位置,进行赋值,当找到的的i = -1时，则在索引0位置插入
            //当需要移动时才插入
            if(i+1 != low){
                a[i+1] = t;
            }
        }
    }
    public static void main(String[] args) {
        insertion2(new int[]{2,3,52,43,1,3});
    }
}
```

### 希尔排序
* 分组实现插入，每个元素间隙称为gap
* 每一轮排序后gap逐渐变小，知道gap为1完成排序
* 是对插入排序的优化，让元素更快交换到最终位置
代码实现
```java
package com.steven.dataalg.sort;

import java.util.Arrays;

/**
 * @Description: 希尔排序
 * * 分组实现插入，每个元素间隙称为gap
 * * 每一轮排序后gap逐渐变小，知道gap为1完成排序
 * * 是对插入排序的优化，让元素更快交换到最终位置
 * @CreateDate: Created in 2023/9/26 09:45
 * @Author: lijie3
 */
public class ShellSort {

    public static void sort(int[] a){
        for (int gap = a.length >> 1; gap >= 1; gap = gap >> 1) {
            for (int low = gap; low < a.length-1; low++) {
                int t = a[low];
                //已排序区域指针
                int i = low - gap;
//        从右向左找，如果找到比t小的第一个值，在其后面插入
                while(i >= 0 &&  a[i] > t){ //没有找到插入位置
                    a[i + gap] = a[i];
                    i -= gap;
                }
                //找到插入位置,进行赋值,当找到的的i = -1时，则在索引0位置插入
                //当需要移动时才插入
                if(i+gap != low){
                    a[i+gap] = t;
                }
            }
        }

    }

    public static void main(String[] args) {
        int[] a = {9,3,7,2,5,8,1,4};
        System.out.println(Arrays.toString(a));
        sort(a);
        System.out.println(Arrays.toString(a));
    }
}

```

### 归并排序
* 分而治之

#### 递归实现
```java
package com.steven.dataalg.sort;

import java.util.Arrays;

/**
 * @Description: 归并排序
 * @CreateDate: Created in 2023/9/27 09:39
 * @Author: lijie3
 */
public class MergeSort {


    public static void sort(int[] a1){
        int[] a2 = new int[a1.length];
        split(a1,0,a1.length-1,a2);
    }

    private static void split(int[] a1,int left,int right,int[] a2){
        int[] ints = Arrays.copyOfRange(a1, left, right + 1);
//        System.out.println(Arrays.toString(ints));
        //2. 治
        if(left == right){
            return;
        }
        //1. 分
        int m = (left + right) >>> 1;
        split(a1,left,m,a2);
        split(a1,m+1,right,a2);
        //合并两个有序数组并将数组重新排序
        merge(a1,left,m,m+1,right,a2);
        System.arraycopy(a2,left,a1,left,right -left + 1);
    }

    /**
     *
     * @param a1 原始数组
     * @param i
     * @param iEnd  第一个有序范围
     * @param j
     * @param jEnd  第二个有序范围
     * @param a2  临时数组
     */
    public static void merge(int[] a1,int i,int iEnd,int j,int jEnd,int[] a2){
        int k= i;
        while(i <=iEnd && j <=jEnd){
            if(a1[i] < a1[j]){
                a2[k] = a1[i];
                i++;
            }else{
                a2[k] = a1[j];
                j++;
            }
            k++;
            if (i > iEnd) {
                System.arraycopy(a1,j,a2,k,jEnd-j+1);
            }
            if(j >jEnd){
                System.arraycopy(a1,i,a2,k,iEnd-i+1);
            }
        }
    }

    public static void main(String[] args) {
        int[] a1 = {9,3,7,2,8,5,1,4};
        sort(a1);
        System.out.println(Arrays.toString(a1));
    }
}
```
#### 非递归实现

```java
package com.steven.dataalg.sort;

import java.util.Arrays;

/**
 * @Description: 归并排序，非递归实现
 * @CreateDate: Created in 2023/9/27 10:00
 * @Author: lijie3
 */
public class MergeSort2 {


    public static void sort(int[] a1){
        int n = a1.length;
        int[] a2 = new int[a1.length];
        for (int width = 1; width < n; width = width * 2) {
            for (int left = 0; left < n; left += 2 * width) {
                int right = Math.min(left + 2 * width -1,n -1);
                int m = Math.min(left + width -1,n-1);
                merge(a1,left,m,m+1,right,a2);
            }
            System.arraycopy(a2,0,a1,0,n);
        }
    }
    /**
     *
     * @param a1 原始数组
     * @param i
     * @param iEnd  第一个有序范围
     * @param j
     * @param jEnd  第二个有序范围
     * @param a2  临时数组
     */
    public static void merge(int[] a1,int i,int iEnd,int j,int jEnd,int[] a2){
        int k= i;
        while(i <=iEnd && j <=jEnd){
            if(a1[i] < a1[j]){
                a2[k] = a1[i];
                i++;
            }else{
                a2[k] = a1[j];
                j++;
            }
            k++;
            if (i > iEnd) {
                System.arraycopy(a1,j,a2,k,jEnd-j+1);
            }
            if(j >jEnd){
                System.arraycopy(a1,i,a2,k,iEnd-i+1);
            }
        }
    }

    public static void main(String[] args) {
        int[] a1 = {9,3,7,2,8,5,1,4};
        System.out.println(Arrays.toString(a1));
        sort(a1);
        System.out.println(Arrays.toString(a1));
    }

}
```

组合归并排序和插入排序，实现排序效率的进一步提升(在治的阶段使用插入排序)
```java
/**
 * @Description: 归并排序(数据量大时适合) + 插入排序（数量小时适合）
 * @CreateDate: Created in 2023/10/7 09:09
 * @Author: lijie3
 */
public class MergeSort3 {

    public static void sort(int[] a1){
        int[] a2 = new int[a1.length];
        split(a1,0,a1.length-1,a2);
    }

    private static void split(int[] a1,int left,int right,int[] a2){
        //2. 治
        //治的阶段使用插入排序
        if(right - left <=32){
            insertion(a1,left,right);
            return;
        }
        //1. 分
        int m = (left + right) >>> 1;
        split(a1,left,m,a2);
        split(a1,m+1,right,a2);
        //3. 合并两个有序数组并将数组重新排序
        merge(a1,left,m,m+1,right,a2);
        System.arraycopy(a2,left,a1,left,right -left + 1);
    }



    /**
     * 非递归方式的插入排序
     * @param a
     */
    private static void insertion(int[] a,int left,int right){
        for (int low = left + 1; low <= right; low++) {
            int t = a[low];
            //已排序区域指针
            int i = low - 1;
//        从右向左找，如果找到比t小的第一个值，在其后面插入
            while(i >= left &&  a[i] > t){ //没有找到插入位置
                a[i + 1] = a[i];
                i --;
            }
            //找到插入位置,进行赋值,当找到的的i = -1时，则在索引0位置插入
            //当需要移动时才插入
            if(i+1 != low){
                a[i+1] = t;
            }
        }
    }

    /**
     *
     * @param a1 原始数组
     * @param i
     * @param iEnd  第一个有序范围
     * @param j
     * @param jEnd  第二个有序范围
     * @param a2  临时数组
     */
    public static void merge(int[] a1,int i,int iEnd,int j,int jEnd,int[] a2){
        int k= i;
        while(i <=iEnd && j <=jEnd){
            if(a1[i] < a1[j]){
                a2[k] = a1[i];
                i++;
            }else{
                a2[k] = a1[j];
                j++;
            }
            k++;
            if (i > iEnd) {
                System.arraycopy(a1,j,a2,k,jEnd-j+1);
            }
            if(j >jEnd){
                System.arraycopy(a1,i,a2,k,iEnd-i+1);
            }
        }
    }

    public static void main(String[] args) {
        int[] a1 = {9,3,7,2,8,5,1,4};
        System.out.println(Arrays.toString(a1));
        sort(a1);
        System.out.println(Arrays.toString(a1));
    }
}
```

#### 快速排序
核心思想：每一轮找个一个基准点元素，把比他小的放到它的左边，比它大的放到它的右边，这称为分区
最简单的lomuto单边循环快速排序
1. 选择最右边元素作为基准点元素
2. j找比基准点小的元素，i找比基准点大的元素，一旦找到，二者进行交换
3. 最后基准点与i交换，i即为基准点最终索引

```java
package com.steven.dataalg.sort;

import java.util.Arrays;

/**
 * @Description: 快速排序，找到基准点数，小于基准点的放在左边，大于基准点的放在右边
 * 单边循环快排，选择最右侧的数据作为基准点
 * @CreateDate: Created in 2023/10/7 09:18
 * @Author: lijie3
 */
public class QuickSort {


    public static void sort(int[] a){
        quick(a,0,a.length-1);
    }

    private static void quick(int[] a, int left, int right) {
        if(left >= right){
            return;
        }
        int p = partition(a,left,right); //p代表基准点元素索引
        quick(a,left,p-1);
        quick(a,p+1,right);
    }



    /**
     * 分区方法
     * @param a
     * @param left
     * @param right
     * @return
     */
    private static int partition(int[] a, int left, int right) {
        int pv = a[right]; //基准点元素的值
        int i = left;
        int j = left;
        while (j < right){
            //j找到了比基准点小的元素
            if(a[j] < pv){
                if(i != j){
                    swap(a,i,j);
                }
                i++;
            }
            j++;
        }
        swap(a,i,right);
        return i;

    }

    //交换
    public static void swap(int[] array,int i ,int j){
        int t = array[i];
        array[i]  = array[j];
        array[j] = t;
    }

    public static void main(String[] args) {
        int[] a1 = {9,3,7,2,8,5,1,4};
        System.out.println(Arrays.toString(a1));
        sort(a1);
        System.out.println(Arrays.toString(a1));
    }
}
```

双边循环快排
将i、j的分别从left，right处进行遍历
```java
package com.steven.dataalg.sort;

import java.util.concurrent.ThreadLocalRandom;

/**
 * @Description: 双边循环快速排序
 * @CreateDate: Created in 2023/10/7 18:19
 * @Author: lijie3
 */
public class QuickSort2 {

    public static void sort(int[] a) {
        quickSort(a, 0, a.length - 1);
    }
    //实现快速排序算法
    public static void quickSort(int[] a, int left, int right) {
        if (left < right) {
            int pivot = partition(a, left, right);
            quickSort(a, left, pivot - 1);
            quickSort(a, pivot + 1, right);
        }
    }
    //快排分区
    public static int partition(int[] a, int left, int right) {
        //基准点元素的值，这里最好使用随机值
        int index = ThreadLocalRandom.current().nextInt(right-left+1)+left;
        swap(a, index, left);
        int pv = a[left];
        int i = left;
        int j = right;
        while (i < j) {
            //注意i和j的顺序不能随便调整
            //1.j从右向左找基准点小的值
            while (i < j && a[j] > pv) {
                j--;
            }
            //2. i从左向右找比基准点大的值
            while (i < j && a[i] <= pv) {
                i++;
            }
            //3.交换
            swap(a, i, j);
        }
        //交换基准点
        swap(a, left, i);
        return i;
    }
    //实现数组元素交换
    public static void swap(int[] array, int i, int j) {
        int t = array[i];
        array[i] = array[j];
        array[j] = t;
    }
    //定义main函数对上面的快排算法验证
    public static void main(String[] args) {
        int[] a = {3412,344,23,57,123,6546423,234235,4564,23423};
        sort(a);
        for (int i : a) {
            System.out.print(i + " ");
        }
    }

}
```

考虑重复的双边快排
```java
package com.steven.dataalg.sort;

import java.util.concurrent.ThreadLocalRandom;

/**
 * @Description: 双边循环快速排序,处理重复元素问题
 * @CreateDate: Created in 2023/10/7 18:19
 * @Author: lijie3
 */
public class QuickSort3 {

    public static void sort(int[] a) {
        quickSort(a, 0, a.length - 1);
    }
    //实现快速排序算法
    public static void quickSort(int[] a, int left, int right) {
        if (left < right) {
            int pivot = partition(a, left, right);
            quickSort(a, left, pivot - 1);
            quickSort(a, pivot + 1, right);
        }
    }
    //快排分区，考虑重复值
    public static int partition(int[] a, int left, int right) {
        int pv = a[left];
        int i = left+ 1;
        int j = right;
        while (i <=j){
            while (i <= j && a[i] < pv){
                i++;
            }
            while (i <= j  && a[j] > pv){
                j--;
            }
            if(i <= j){
                swap(a,i,j);
                i++;
                j--;
            }
        }
        swap(a,left,j);
        return j;
    }
    //实现数组元素交换
    public static void swap(int[] array, int i, int j) {
        int t = array[i];
        array[i] = array[j];
        array[j] = t;
    }
    //定义main函数对上面的快排算法验证
    public static void main(String[] args) {
        int[] a = {3412,344,23,57,123,57,6546423,234235,4564,23423};
        sort(a);
        for (int i : a) {
            System.out.print(i + " ");
        }
    }
}
```

**计数排序和桶排序都是基于非比较元素方式的排序算法**
####  计数排序
基本计数排序实现
```java
package com.steven.dataalg.sort;

/**
 * @Description: 计数排序算法
 * @ClassName: CountSort
 * @CreateDate: Created in 2023/10/8 09:27
 * @Author: lijie3
 */
public class CountSort {
    /**
     * 计数排序的流程：
     * 1. 计算数组中的最大值和最小值,创建一个大小为最大值+1的数组
     * 2. 计算数组中的各个元素出现的次数
     * 3. 遍历count数组，将数组中的元素按照次数排序
     * 排序前提： 待排序元素 >= 0
     */
    public static void sort(int[] a){
        int max = a[0];
        for (int i = 0; i < a.length; i++) {
            if(a[i] >max){
                max = a[i];
            }
        }
        int[] count = new int[max+1];
        for (int v : a) {
            count[v]++;
        }
        //i 代表原始数组中的值
        int k = 0;
        for (int i = 0; i < count.length; i++) {
            while (count[i] > 0){
                a[k++] = i;
                count[i] --;
            }
        }
    }

    //对上面的排序算法进行测试
    public static void main(String[] args) {
        int[] a = {1,2,31,4,53,16,27,8,19,10};
        sort(a);
        for (int v : a) {
            System.out.print(v + " ");
        }
    }
}
```

支持负数的排序
```java
package com.steven.dataalg.sort;

/**
 * @Description: 计数排序算法,改进，解决原始数组中存在小于0 的数据
 * @ClassName: CountSort
 * @CreateDate: Created in 2023/10/8 09:27
 * @Author: lijie3
 */
public class CountSort2 {
    /**
     * 计数排序的流程：
     * 1. 计算数组中的最大值和最小值,创建一个大小为(最大值-最小值+1)的数组
     * 2. 计算数组中的各个元素出现的次数
     * 3. 遍历count数组，将数组中的元素按照次数排序
     * 排序前提： 待排序元素 >= 0
     */
    public static void sort(int[] a){
        int max = a[0];
        int min = a[0];
        for (int i = 0; i < a.length; i++) {
            if(a[i] >max){
                max = a[i];
            }
            if(a[i] < min){
                min = a[i];
            }
        }
        int[] count = new int[max-min+1];
        for (int v : a) {
            count[v-min]++;
        }
        //i+min 代表原始数组中的值
        //count[i]代表数组中的元素出现的个数
        int k = 0;
        for (int i = 0; i < count.length; i++) {
            while (count[i] > 0){
                a[k++] = i+min;
                count[i] --;
            }
        }
    }

    //对上面的排序算法进行测试
    public static void main(String[] args) {
        int[] a = {1,2,31,-4,53,16,27,8,19,10};
        sort(a);
        for (int v : a) {
            System.out.print(v + " ");
        }
    }
}
```

#### 桶排序
将数据按一定的规则分布到桶中，对桶中的数据进行排序，最后对桶进行合并成为数组
```java
package com.steven.dataalg.sort;

import com.steven.dataalg.array.DynamicArray;

/**
 * @Description: 桶排序改进，参考计数排序
 * @CreateDate: Created in 2023/10/8 18:59
 * @Author: lijie3
 */
public class BucketSort2 {

    public static void sort(int[] a,int range) {
        int max = a[0];
        int min = a[0];
        for (int i = 0; i < a.length; i++) {
            if(a[i] > max){
                max = a[i];
            }
            if(a[i] < min){
                min = a[i];
            }
        }
        //1.准备桶
        DynamicArray[] buckets = new DynamicArray[(max - min)/range + 1];
        for (int i = 0; i < buckets.length; i++) {
            buckets[i] = new DynamicArray();
        }
        //2.放入数据
        for (int v : a) {
            int bucketIndex = v - min;
            buckets[bucketIndex/range].addLast(v);
        }
        int k = 0;
        for (DynamicArray bucket: buckets){
            int[] array = bucket.stream().toArray();
            //3. 桶内插入排序
            InsertionSort.sort(array);
            //4.排序后依次放入原始数组
            for (int v:array){
                a[k++] = v;
            }
        }

    }

    public static void main(String[] args) {
        int[] a = {1,2,31,4,53,16,27,8,19,10};
        sort(a,3);
        for (int v : a) {
            System.out.print(v + " ");
        }
    }
}
```



## 算法设计的重要思想
### 动态规划 Dynamic programming
通过把原有问题分解为相对简单的子问题的方式求解复杂问题的方法。
核心思想： 分而治之--拆分子问题，记住过往，减少重复计算。
leecode题：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，求青蛙跳上一个10级台阶总共有多少总跳法？
思路：
要跳上第十级台阶，要么是先跳到第九级台阶，然后再跳1级台阶；要么先跳到第八级台阶，再跳2级台阶到第十级
同理，要跳上第九级台阶，要么先跳到第八级台阶，然后跳一级台阶；要么先跳到第7级台阶，再跳2级台阶到第九级

设跳到第n级台阶的跳数为f(n),则可以得出：
f(10) = f(9) + f(8)
f(9) = f(8)+ f(7)
....
f(n) = f(n-1) + f(n-2)

当台阶数为2时，有两种跳法 f(2) = 2
当台阶数为1时，只有一种跳法  f(1)  = 1

通过递归代码可以做如下实现：
```java
    /**
     * 使用递归实现,会出现很多重复计算，导致耗时过长
     * @param n
     * @return
     */
    public static int fib(int n){
        if(n == 1){
            return 1;
        }
        if(n == 2){
            return 2;
        }
        return fib(n-1) + fib(n-2);
    }
```
上面的算法由于递归的过程中出现了大量的重复计算，导致效率很低，时间复杂度 O（n^2）
改进版本1:使用备忘录的方式记录已经计算过的递归结果：
```java

    /**
     * 带备忘录的递归模式，避免重复计算
     * @param n
     * @return
     */
    public static Map<Integer,Integer> countResultMap = new HashMap<>();
    public static int fib2(int n){
        if(n == 1){
            return 1;
        }
        if(n == 2){
            return 2;
        }
        if(countResultMap.containsKey(n)){
            return countResultMap.get(n);
        }
        int result = fib2(n-1) + fib2(n-2);
        countResultMap.put(n,result);
        return result;
    }
```
改进版本可以减少多余的计算，节省大量的时间
备忘录模式思想：从f(10) 向f(1)计算，自顶向下计算求解，备忘录模式需要的空间复杂度为O(n),需要一个map来存储迭代计算的结果

还可以使用动态规划的方式进行求解：
动态规划从较小问题的解，由交叠性质，逐步决策出较大问题的解，它是从f(1)往f(10)方向，往上推求解，所以称为自底向上的解法
动态规划的特征：
最优子结构、状态转移方程、边界、重叠子问题
动态规划解决思路：
从f(1) ->f(10)的顺序进行计算
f(1) = 1
f(2) = 2
f(3) = f(1) + (2)
f(4) = f(2)+ f(3)
可以发现，f(n) 只依赖于前面计算的两个结果，所以只需要两个变量来存储a，b即可满足需求，空间复杂度为O(n)

动态规划代码实现
```java
    /**
     * 使用动态规划的方式实现
     * @param n
     * @return
     */
    public static int fib3_dp(int n){
        if(n == 1){
            return 1;
        }
        if(n == 2){
            return 2;
        }
        int a = 1;
        int b = 2;
        int result = 0;
        for (int i = 3; i <= n; i++) {
            result = a + b;
            a = b;
            b = result;
        }
        return result;
    }
```

动态规划的解题思路：
* 自底向上
* 穷举分析
* 确定边界
* 找出规律，确定最优子结构
* 写出状态转移方程

使用动态规划的算法举例
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
* 解决思路，每次向数组中加入一个元素，求数组中的递增子序列长度并进行记录
* 下一轮使用上一轮的求解结果计算
代码实现
```java
 public static  int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        //初始化就是边界情况
        dp[0] = 1;
        int maxans = 1;
        //自底向上遍历
        for (int i = 1; i < nums.length; i++) {
            dp[i] = 1;
            //从下标0到i遍历
            for (int j = 0; j < i; j++) {
                //找到前面比nums[i]小的数nums[j],即有dp[i]= dp[j]+1
                if (nums[j] < nums[i]) {
                    //因为会有多个小于nums[i]的数，也就是会存在多种组合了嘛，我们就取最大放到dp[i]
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            //求出dp[i]后，dp最大那个就是nums的最长递增子序列啦
            maxans = Math.max(maxans, dp[i]);
        }
        return maxans;
    }
```

### 雪花算法--snowflake算法
twitter提出的在分布式系统中用来生成唯一id的算法
雪花算法是64位的二进制，包含四个部分：
第一位是符号为，始终是0，表示id为正值，没有任何含义
41位是时间戳（算法的核心），具体到毫秒，41位二进制可以使用69年，在java中可以使用System.currentTimeMillis()获取
10位是机器标识，可以全部当作机器id，也可以用来标识机房ID+机器ID，最多可以表示1024台机器
12位是计数序列号，表示单位毫秒内可生成的序列号数目的理论极限

雪花算法存在的问题--时间回拨问题
可能由于人为原因修改了系统环境的时间
也可能因为不同机器上的时间存在差异，需要同步，出现了时间回拨（开启ntp保证时间的同步）
解决方案
* 当回拨时间小的时候，不生成id，循环等待时间点的到达
* 当回拨时间较大时，可以拒绝服务，或是利用拓展位，回拨之后再拓展位上加1，保证id的唯一，需要从机器id中预留一定的位数
具体的解决方案可以参考百度的UIDGenerator和美团的leaf-segment













































