# 数据库100问（基于mysql）

## 1. 慢sql查询如何优化
   1. 首先可以使用explain 查询sql是不是走了索引
   2. 没有走索引的需要让sql走索引
   3. 如果走了索引，
## 2. 什么是索引
    索引是帮助数据库高效获取数据的排好序的数据结构
    索引的数据结构：
    1. 二叉树
    2. 红黑树
    3. Hash表
    4. B-Tree(目前最常用的索引结构)

## 3. 数据类型（mysql）
   1. 数值类型
   >   tinyint     1byte    -128 127
   >   smallint    2bytes   -32768 32767
   >   mediumint   3bytes
   >   int/integer 4byte
   >   bigint      8bytes
   >   float       4byte    
   >   double      8byte
   >   decimal（5，2）：总共五位，小数点后两位

   2. 时间和日期类型

   >  date 3bytes yyyy-mm-dd
   >   time 3byte  hh:mm:ss
   >   year
   >   datetime yyyy-mm-dd hh:mm:ss
   >   timestamp 时间戳


   3. 字符串类型 （单引号）
   >   varchar 变长字符串
   >   char 定长字符串  0-255 bytes
   >   TEXT




## 4. DDL、DML、DQL
### DDL
DDL： data definition language 数据定义语言
#### 数据库操作
> 查看所有数据库： show databases;
> 创建数据库： create database [if not exists] mydb1 [charset=utf8]
> 切换或选择要操作的数据库： use mydb1;
> 删除数据库： drop database [if exists] mydb1;
> 修改数据库访问编码： alter database mydb1 character set utf8;
#### 表操作
创建库：
```sql
 create table [if not exists] tablename(
   id int(10) [auto_increment] [comment '主键id'],
   name varchar(255) [not null] [comment '名称'],
   age int,
   birth date  
 )[];
 ```
查看表：
> show tables;
查看表的创建语句
> show create table table1
查看表结构
> desc table1;

修改表结构
>  添加表列： alter table table1 add column1 varchar(20) [default null];
>  修改列名： alter table table1 change `column1` `column2` varchar(30) [default null];
>  删除列：   alter table table1 drop `column1`; 
>  修改表明： rename table  `table1` to `table2`;

### DML
DML: data manipulation language 数据操作语言
数据插入：
> 指定字段赋值： insert into table1(column1,column2) values(value1,value2),(value3,value4);
> 全字段赋值： insert into table1 values(value1,value2,value3),(value4,value5,value6);
数据修改：
> update table1 set column1=v1,column2=v2 [where column1 = v3];
数据删除：
> delete from table1 [where column = v1];
> truncate [table] table1;  删除表，然后重新创建表 


## 约束（mysql）constraint
创建表时为表中的某些列添加限制条件
### 主键约束 primary key
唯一标识表数据的每一行（可以多个列组合）
表只允许有一个主键
系统默认会再所在的咧和列组合上创建对应的唯一索引
主键约束列不能为null
创建单列主键
```sql
 create table table1(
     id int(11) primary key,
     name varchar(20) not null
 );
 create table table1(
     id int(11) auto_increment,
     name varchar(20) not null,
     [constraint pk1] primary key(id)  
 );
 ```


创建多列主键 (主键参与列都不能为空)
```sql
 create table table1(
   name varchar(20) not null,
   age int(11) not null
   [constraint pk1] primary key(name,age)    
 );
``` 


修改表结构后添加主键
```sql
 alter table table1 add primary key(name,age);
```
删除主键约束
```sql
 alter table table1 drop primary key; 
```

### 自增长约束 auto_increment
一个表只能有一个自增长约束
为主键自动赋值
```sql
create table table1(
     id int(11) auto_increment,
     name varchar(20) not null,
     [constraint pk1] primary key(id)  
 ) auto_increment = 100; --从100开始自增
 insert into table1(name) value('lisi');
 ```
修改的方式添加：

```sql
alter table table1 auto_increment = 200;
```

delete 删除数据auto_increment自增会保留
truncate 删除数据auto_increment自增长会从起始值开始

### 非空约束 not null
创建表时指定字段非空
修改字段时指定
```sql
 alter table table1 modify column1 varchar(20) not null;
 ```
删除非空约束
```sql
 alter table table1 modify column1 varchar(20)
``` 

### 唯一约束
**在mysql中NULL和任何值都不匹配、不相同,所以唯一约束可以允许多个NULL值出现,创建唯一约束时要保证约束列不能为null**
指所有记录中字段的值不能重复出现
创建
字段名后加上unique
```sql
 create table table1(
     id int(11) primary key,
     name varchar(20) unique not null  --列指定
 );
``` 

在所有字段的最后指定唯一约束的列
```sql
 create table table1(
     id int(11) primary key,
     name varchar(20)  not null,
     gender tinyint not null,
     UNIQUE KEY `uk1` (`name`,`gender`) 
 );
``` 

修改添加约束：
```sql
 alter table table1 add constraint uk1 unique(name,age);
``` 

删除约束
```sql
 alter table table1 drop index uk1;
``` 

### 默认值约束
给字段默认值
```sql
 create table table1(
     id int(11) primary key,
     name varchar(20) not null default 'unknow'  
 );
``` 

### 零填充约束
填充长度到字段的指定长度
```sql
 create table table1(
     id int(11) zerofill primary key, --整型zerofill默认长度是10
     name varchar(20) not null default 'unknow'  
 );
``` 

### 外键约束 约束多张表之间的关系
> 主表必须时存在于数据库中
> 从表的外键必须时主表的主键

创建
```sql
   create table table11(
     id int(11) primary key,
     name varchar(20)  not null,
     gender tinyint not null,
     UNIQUE KEY `uk1` (`name`,`gender`) 

 );
   --从表
 create table table2(
    id int(11) primary key,
    name varchar(30) not null,
    dept_id int(11) not null,
    constraint t1_pk foreign key(dept_id) references table1(id); --外键约束
 )
 ```
 修改方式创建
 ```sql
 alter table table2 add constraint t1_pk foreign key(dept_id) references table1(id) on delete cascade on update cascade; --级联删除级联更新
```
删除外键
```sql
alter table table2 drop foreign key ti_pk;
```

多对多的关系使用中间表来进行约束






### DQL 
data query language
#### 查询操作
```sql 
select 
      [all|disntinct] column1 as a1,
      [all|disntinct] column2 as a2,
from 
   table1|view1
[where [condition]]
group by [column1]
having expression
order by [column1] [asc|desc]
limit [0,100]
```

#### 关键字
> 去重某一列 `distinct` 去重所有列 `distinct *`
> 查询区间 `between a and b`
> `least（）` 查询最小值  (如果比较的值存在null，不会进行比较，直接返回nul)
> `greatest（）` 查询最大值 (如果比较的值存在null，不会进行比较，直接返回nul)
>  `ifnull(a,0)` 如果a的值不是null，返回a，如果是null，返回0

#### 聚合函数
> count() 统一某一字段时，不统计null值行
> sum() 不统计null值的行
> min() 不统计null值的行
> max() 不统计null值的行
> avg() 平均值，不统计null值的行

#### 执行顺序
1. from
2. where
3. select
4. group by
5. count() --聚合函数
6. having
7. order by
8. limit

#### 分组
> `group by column1  column2 having condition` 分组查询的select字段只能是分组字段或者聚合函数
> `having` 是对`group by`的结果进行筛选

#### 分页
> `limit n` 显示默认的前n条
> `limit m,n` 从第m条开始，显示n条数据

查询并插入insert into ... select .... 
```sql insert into table1(column1,column2) 
      select 
         column1,column2 
      from 
         table2
      where
         [condition] 
```         
#### 正则表达式
> a
> `regexp ^a` 是否以a开头
> `regexp b$` 是否以b结尾 
> `regexp .a` `.`匹配任意单个字符（除了换行符）
> `regexp [xyz]`  []内任意一个字符是否在匹配对象中出现
> `regexp [^abc]` 匹配除了 [...] 中字符的所有字符,^在[]中出现表示取反的意思，其他地方表示以某某开头
> `'abc' regexp [^a] `  返回1
> `regexp (taa)* `  *匹配0个或多个taa，包括空字符串
> `regexp a+` a出现一次或多次
> `regexp a?` a出现0次或一次
> `regexp a|b` 匹配a或b
> `regexp ^(a|b)` 以a或b开头
> `regexp a{m}` 匹配m个a
> `regexp a{m,}` 匹配m个及多个a
> `regexp a{m,n}` 匹配m到n个a
> `regexp ^d(abc)` ()内的abc存在时匹配，普通字符匹配

#### 多表操作
多表关系
> `一对一`
> `一对多`
> `多对多`

交叉连接(笛卡尔积) 
> 两张表项乘
> 会产生冗余数据

```sql
select * from a,b;
```

内连接（两张表的交集）
[inner] join
```sql
-- 隐式内连接
select * from a,b where a.id = b.cid;   
-- 显式外连接
select * from a inner join b on a.id = b.cid; 
```
```sql
-- 分组、排序、join
select 
   t1.deptno as deptno,
   t1,name as name, 
   count(1) as count 
from dept3 t1 
inner join emp3 t2 
on t1.deptno = t2.deptId 
group by t1.deptno,t1.name 
having count >3  order by count desc; 
```


外连接
> left [outer] join
```sql
-- 右表没有对应的数据补null
select * from dept a left outer join emp b on a.deptno = b.dept_id;
```

> right [outer] join
```sql
select * from dept a right outer join emp b on a.deptno = b.dept_id;
```

> full [outer] join (mysql 中使用union,将查询的结果上下拼接，并去重)

```sql
select * from dept a left outer join emp b on a.deptno = b.dept_id
union
select * from dept a right outer join emp b on a.deptno = b.dept_id;
```
> union all 表示不去重
```sql
select * from dept a left outer join emp b on a.deptno = b.dept_id
union all
select * from dept a right outer join emp b on a.deptno = b.dept_id
```
子查询
select的嵌套查询
子查询返回结果类型
> 单行单列
```sql
   select
       * 
   from 
      emp3 
   where age = (
      select 
         max(age) 
      from emp3);
```

> 单行多列
```sql
   --多表查询实现
   select * from emp3 a join dept3 b  on a.deptid = b.deptno and b.name in ('aaaa','bbbbb');
   --子查询实现
   select 
      * 
   from emp3 a 
   where a.deptid in (
      select 
         deptno 
      from dept3 
      where name in ('aaaa','bbbbb'));
```

> 多行单列
```sql
   --多表查询实现
   select * from emp3 a join dept3 b on a.deptid = b.deptno and b.name = 'aaaa' and a.age <= 20;
   -- 子查询
   select * from emp3 a where deptid in(select name from dept3 where name = 'aaaa') and a.age <=20
```

> 多行多列
```sql
select * from (select * from dept3 where name = 'aaaa') t1 join (select * from emp3 where age <30) t2 on t1.deptno=t2.deptid
```
相关关键字
> all --集合中的所有元素
```sql
select * from table1 where age > all(select age from table2)  --大于子查询中的所有年龄
```
```sql
select * from emp3 where deptid <> all(select deptno form dept3); --不与集合中的任何值匹配
```
> any/some --集合中的任意值比较
```sql
select * from emp3 where age > any(select age from table2) --大于子查询中的任意一个人的年龄  
```
> in --是其中的任意一个
```sql
select * from emp3 where detpid in(select deptno from dept); 
```
> exists 存在数据满足并返回数据 (用in可以达到一样的效果)
```sql
select * from emp3 a where exists （ select * from emp3 b where a.deptid =b.deptno );
```

**多表关联查询的效率会比子查询高，尽量使用关联查询**
表自关联
> 自关联表必须取别名
```sql
select a.name as name ,b.name as manager from emp1 e1 left join emp2 e2 on e1.manager = e2.id;
```
## 5. mysql的函数
### 聚合函数
常见的
> count()、sum()  min() max() avg()
group_concat() 
合并某一列
```sql
select group_concat(emp_name) from emp; --默认分隔符 ，
select group_concat(emp_name separator ';') from emp; --指定；分隔符
select department, group_concat(emp_name separator ';') from emp group by department; -- 先分组后拼接 
select department, group_concat(emp_name order by salary desc separator ';') from emp group by department; -- 先分组后按某顺序排序后拼接 
```
### 数学函数
> abs(x) 求绝对值
> ceil(x) 向上取整 ceil(1.4)= 2
> floor(x) 向下取整 floor(1.4) = 1
> greatest(a,b,c) 取列表最大值
> least(a,b,c) 取列表最小值
> max(column1) 要传列名
> min(column1)
> mod(5,2) 取余
> power(2,3) 求2的3次方
> rand()*100 100以内的随机数
> round(3.433232，3) 四舍五入，保留3位小数
> truncate(x,y) 截取x的小数保留y位小数 
 ### 字符串函数
```sql
  select char_length('hello')/character_length('hello')  --查询字符串长度，一个汉字代表一个函数
  select length('你好') --length返回字节数
  select concat('hello ,','world'); --返回合并字符串
  select concat_ws('-','hello','world') --返回用分隔符合并的字符串
  select field('aaaa','aaaa','bbb','ccc') --=1  返回字符串在字符串列表中第一次出现的位置
  select ltrim('    hello') --去除字符串左边的空格
  select rtrim('world     ')--去除右端空格
  select trim('   hello world     ')--去除两端空格
  select mid('helloworld',2,3) --从第二个字符开始截取，截取长度为3
  select position('abc' in 'hello abc world')  --= 6 判断一个字符串在另一个字符串第一次出现的位置
  select replace('helloaaaworld','aaa','bbb') --将第一个字符串中的aaa替换成bbb
  select reverse('hello') =  --olleh 字符串反转
  select right('hello' ,3) --= llo 返回右边的几个字符
  select strcmp('hello','world') --= -1 比较两个字符串的大小
  select substr('hello',2,3)/substring('hello',2,3) --字符串截取,从第二个字符开始截取，截取三个
  select ucase('hello') --小写变大写
  select upper('hello') --将字符串转为大写
  select lcase('HELLO') --将字符串转为小写
  select lower('HELLO') --将字符串转为小写
```
### 日期函数
```sql
   select unix_timestamp(); --获取时间戳（ms值）
   select unix_timestamp('2022-01-01 08:08:08'); --字符串日期转时间戳
   select from_unix_time(unix_timestamp(),'%Y-%m-%d %H:%i:%s'); --时间戳毫秒值转为字符串格式
   select current_date()/curdate(); --获取当前年月日
   select current_time()/curtime(); --时分秒 
   select current_timestamp(); 获取年月日时分秒
   select date('2022-01-01 08:08:08'); --从日期字符串中获取年月日
   select datediff('2022-01-20','2022-01-02'); --获取日期之间的差值
   select timediff('08:08:08','08:07:08'); --获取时间差值，秒级
   select date_format('2022-1-20 8:8:8','%Y-%m-%d %H:%i:%s'); --日期格式化
   select str_to_date('2022-1-20 8:8:8','%Y-%m-%d %H:%i:%s')  --字符串转日期
   select date_sub('2022-01-20'，interval 2 day/second/month/year/minute)  = 2022-01-18 --将日期进行减法
   select date_add('2022-01-20'，interval 2 day/second/month/year/minute) = 2022-01-22 --将字符串日期进行假发
   select extract(hour/month/year/minute/second/day from '2022-01-01 08:08:08')--从日期中获取小时/天等
   select last_day('2022-01-20') --获取给定日期的所在月最后一天
   select makedate('2021',53) --2021-02-22 指定年份的某一天的日期
   select year/month/minute  ('2022-01-01 08:08:08') --获取各种级别时间
   select quarter('2022-01-20 08:08:08') --获取季度
   select monthname('2022-01-20 08:08:08') --获取月名称
   select dayofmonth('2022-01-20 08:08:08') --这个月的第几天
   select dayofweek('2022-01-20 08:08:08') --1是星期日，2是星期1
   select dayofyear('2022-01-20 08:08:08') --是一年的第几天
   select dayname('2022-01-20 08:08:08') --指定日期周几
   select week('2022-01-20 08:08:08') --获取指定日期是第几周，从0开始
   select weekday('2022-01-20 08:08:08') --是周几
   select yearweek('2022-01-20 08:08:08') --年份和第几周
```

### 控制流函数
if 逻辑判断

```sql 
select if(5>3,'大于','小于'); --类似于java中的三目运算符 
select ifnull('abc','0'); --如果是null，返回'0'
select isnull('abc'); --判断表达式是否为null
select nullif(12,12); --如果两个表达式一样，返回null,否则返回第一个表达式的值
```

case when语句
```sql
   select 
      *,
      case [column1]
         when column1=1 then 'hello'
         when column1=2 then 'world'
         when column1=5 then 'hello world'
         else
            'wrong'
      end as info
   from
      table1;      
```

### 窗口函数（mysql8.0之后添加的）
进行聚合的同时保留分组内的所有数据
**序号函数**
```sql
row_number()|rank()|dense_rank() over(
   partition by ...
   order by ...
)
```
```sql
   --对部门员工按薪资排序，并给出排名 
   --row_number()
   select 
      dname,
      ename,
      salary,
      row_number() over(partition by dname order by salary desc) as rn
    from 
      emp;  
   --rank():薪资相同时rank值相同，序号不连续
    select 
      dname,
      ename,
      salary,
      rank() over(partition by dname order by salary desc) as rn1
    from
      emp;  
    --dense_rank() 薪资相同时rank值相同，序号连续
    select 
      dname,
      ename,
      salary,
      dense_rank() over(partition by dname order by salary desc) as rn2 
   from
      emp; 
   -- 分组求topn
   select * from  (
      select 
            dname,
            ename,
            salary,
            row_number() over(partition by dname order by salary desc) as rn
      from
         emp      
   ) as t 
   where t.rn <= 3
   -- 全体排序，去掉partition by
   select 
      dname,
      ename,
      salary,
      row_number() over(order by salary desc) as rn
   from
      emp;   
```
**分布函数**
查询分组内小于等于当前rank值的行数/分组内总行数
```sql
   --cume_dist()
   select 
      dname,
      ename,
      salary
      cume_dist() over(partition by dname order by salary) as rn1,
      cume_dist() over(order by salary) as rn1
   from
      emp；   
   --percent_rank() 不常用
   select 
      dname,
      ename,
      salary
      percent_rank() over(partition by dname order by salary) as rn1
   from
      emp;
```

**前后函数**
返回位于当前行的前n行（lag（exp，n））或后 n行（lead（exp，n））的exp值
应用查询前一名同学和当前同学成绩的差值
```sql
   -- 
    select 
      dname,
      ename,
      salary,
      hirdate,
      lag(hirdate ,1,'2000-01-01') over(partition by dname order by hirdate) as time1, --排序后上一行的值，没有的补默认值2000-01-01
      lag(hirdate ,2) over(partition by dname order by hirdate) as time2  --排序后上2行的值，没有的补null
      --lack(hirdate ,1,'2000-01-01') over(partition by dname order by hirdate) as time1 --排序后下一行的值
   from
      emp;
```
**头尾函数**
返回第一个或最后一个的表达式值
场景，戒指到当前，按日期排序查询的第一个入职和最后一个入职员工的薪资
```sql
   select
      dname,
      ename,
      salary,
      first_value(salary) over (partition by dname order by hiredate) as fisrt,
      last_value(salary) over (partition by dname order by hiredate) as last
    from
      emp;  
```
**其他**
nth_value(exp,n)
返回窗口中第n个exp的值
场景：截止到当前薪资，显示每个员工薪资中排第二或第三的薪资
```sql
    select
      dname,
      ename,
      salary,
      nth_value(salary,2) over (partition by dname  order by hiredate) as v2,
      nth_value(salary,3) over (partition by dname order by hiredate) as v3
    from
      emp;  
```  
ntile()
将分区中的有序数据分为n个等级，记录等级数
场景，将每个部门员工按照入职日期分成3组

```sql
 select
      dname,
      ename,
      salary,
      ntile(3) over (partition by dname order by hiredate) as v1

    from
      emp; 
```


## 6. 视图view
数据库中只存储视图定义，视图中的数据还是存储在原来的物理表中
> 简化代码,将常用的查询结果集封装成视图
> 保证数据安全

**创建**
```sql
create [or replace] [algorithm = { undifiend|merge|temptable}]
   view view_name[(column_list)]
   as select_statement
[with [cascade|local] check option]   
```   
```sql
create or replace 
view view1_emp
as
select ename,job from emp;

show full tables; --查询视图和表

select * from view1_emp;
```
**修改**
```sql
alter view view1_emp 
as
select a.deptno,b.dname,a.loc.b.ename from dept a,emp b where a.deptno = b.deptno 
```
**更新视图数据（实际上是更新原表数据）**
sql中有聚合函数、有distinct字段、有group by having不能更新、有union、union all 、join不能更新、from字句中有视图不能更新、包含子查询不能更新
**一般情况下只将视图作为虚拟表，不要通过视图更新数据**
**重命名**
```sql
rename table view1_emp to view2_emp;
```
**删除视图**
```sql
drop view if exists view2_emp;
```

## 7.存储过程（mysql5.0之后的版本）
> 一组sql的语句集
> sql语言的代码封装与重用

### 创建
```sql
--删除
drop if exists procedure proc01;
delimiter $$
create procedure proc01()
begin
   select empno,ename from emp;
end $$
delimiter ; --将分隔符恢复到默认   
```
### 调用
```sql
call proc01();
```

### 使用变量
```sql
delimiter $$
create procedure proc02()
begin
   declare var_name01 varchar(20) default 'qqq'; --定义
   set var_name01  = 'lisi'; --赋值
   select var_name01; --使用
end  $$
delimiter ; 
```

```sql
delimiter $$
create procedure proc03()
begin
   declare var_name01 varchar(20) default 'qqq'; --定义
   select  ename into var_name01 from emp where empno = 1001;
   set var_name01  = 'lisi'; --赋值
   select var_name01; --使用
end  $$
delimiter ; 
```
### 使用用户变量
全局有效，不需要声明
```sql
delimiter $$
create procedure proc04()
begin
   set @var_name01  = 'lisi'; --赋值
   select  @var_name01;
   select var_name01; --使用
end  $$
delimiter ; 
select @var_name01; --可在外部使用
```
### 系统变量
全局变量：mysql启动时服务器给的默认值my.ini
会话变量：mysql奖当前所有的全局变量复制一份作为会话变量
全局变量操作
```sql
show global variables; --查看所有全局变量
show @@global.auto_increment_increment;
set global sort_buffer_size = 40000;
set @@global.sort_buffer_size = 40000;
```
会话变量操作
```sql
show session variables; --查看所有全局变量
show @@session.auto_increment_increment;
set session sort_buffer_size = 40000;
set @@session.sort_buffer_size = 40000;
```
### 存储过程传参in
入参
```sql
demilimter $$
create procedure proc06(in param_empno int)
begin
   select * from emp where empno = param_empno
end $$
demiliter ;
call proc06(1001);
```

### 存储过程传参out
出参
```sql
demilimter $$
create procedure proc07(in param_empno int，out out_ename varchar(20))
begin
   select ename into out_ename from emp where empno = param_empno
end $$
demiliter ;
call proc07(1001,@o_ename);
select @o_ename;
```
### 存储过程传参inout
可修改参数并传出
```sql
demlimiter $$
create procedure proc08(inout num int)
begin 
   set num = num * 10;
end $$
delimiter ;
set @inout_num = 2;
call proc08(@inout_num);
select @inout_2num;


delimiter $$
create procedure proc09(inout inout_ename varchar(30),inout sal int)
begin 
   select concat_ws('_',deptno,ename) into inout_ename from emp where emp.ename = inout_ename;
   set sal = sal*12;
end $$
delimiter ;
set @inout_name = 'lisi';
set @inout_sal = 3000;
call proc09(@inout_name,@inout_sal);
select @inout_name;
select @inout_sal;
```
### 流程控制 if elseif then else end if
```sql
delimiter $$
create procedure proc10(in socre int)
begin
if score <60 
   then select 'not pass';
 elseif score >=60 and score <80
   then  select 'pass';
 elseif score >=80 and score <90
   then select 'great pass';
 elseif score >=90 and score <=100
   then select 'full pass' ;
 else
   then select 'error';
  end if;      
end $$
delimiter ; 

set @score = 55;
call proc10(80);
```
```sql
delimiter $$
create procedure proc11(in in_ename varchar(30))
begin
declare var_sal decimal(7,2);
declare var_result varchar(20);
select 
   sal into var_sal,
where ename = in_ename;
if var_sal<10000
   then set var_result = 'shiyongxinzi';
elseif var_sal<20000
   then set var_result = 'zhuanzhengxinzi';
else
   set var_result = 'creatorxinzi';
 end if;
select var_result;     
end $$
delimiter ; 
set @name = 'guanyu';
call proc11(@name);
```

### 流程控制 case when end case
```sql
delimiter $$
create procedure proc12(in pay_type int)
begin
   case pay_type
      when 1 then select 'weixinzifu';
      when 2 then select 'zifubaozifu';
      when 2 then select 'yinhangkazifu';
      else select 'other';
   end case;   
end
delimiter $$;
call proc12(1);
```
```sql
delimiter $$
create procedure proc13(in in_ename varchar(30))
begin
declare var_sal decimal(7,2);
declare var_result varchar(20);
select 
   sal into var_sal,
where ename = in_ename;
case
   when var_sal<10000
      then set var_result = 'shiyongxinzi';
   when  var_sal<20000
      then set var_result = 'zhuanzhengxinzi';
   else
      set var_result = 'creatorxinzi';
 end case;
select var_result;     
end $$
delimiter ; 
set @name = 'guanyu';
call proc13(@name);
```
### 流程控制--循环 while、repeat
```sql
--while 循环 leave 跳出循环
--向表中添加数据
delimiter $$
create procedure proc14(in insert_count int)
begin
   declare i int default 1;
   lable: while i <= insert_count
      insert into user(username,password) values(concat('user-',i),'123456');
      if i = 5
         then leave lebel; --跳出标签位置的循环
      end if;  
      set i = i+1;   
   end while label;
end $$
delimiter ; 
call proc14(10);
```
```sql
--while 循环 iterate 跳过本次循环继续进行下一次循环
--向表中添加数据
delimiter $$
create procedure proc15(in insert_count int)
begin
   declare i int default 1;
   lable: while i <= insert_count
      insert into user(username,password) values(concat('user-',i),'123456');
      set i = i+1; 
      if i = 5
         then iterate lebel; --跳出标签位置的循环
      end if;  
   end while label;
end $$
delimiter ; 
call proc14(10);
```

**repeat util**
```sql
--repeat 循环 iterate 跳过本次循环继续进行下一次循环
--向表中添加数据
delimiter $$
create procedure proc15(in insert_count int)
begin
   declare i int default 1;
   lable: repeat i <= insert_count
      insert into user(username,password) values(concat('user-',i),'123456');
      set i = i+1; 
      util i > insert_count --跳出循环，不要加分号 
   end repeat label;
   select 'repeat end';
end $$
delimiter ; 
call proc15(10);
``` 
**loop**
```sql
delimiter $$
create procedure proc16(in insert_count int)
begin
   declare i int default 1;
   lable: loop i <= insert_count
      insert into user(username,password) values(concat('user-',i),'123456');
      set i = i+1; 
      if i > insert_count --跳出循环
         then leave label;
      end if;    
   end loop label;
   select 'repeat end';
end $$
delimiter ; 
call proc16(10);
```
**游标cursor**
对查询结果集进行额外处理
```sql
drop procedure if exists proc16;
delimiter $$
create procedure proc16(in in_dname varchar(30))
   declare var_empno int;
   declare var_ename varchar(50);
   declare var_sal decimal(7,2);
--声明游标
   declare mycursor cursor for
      select empno,ename,sal,from dept a,emp b 
      where a.deptno = b.deptno and a.dname = in_dname;
 --打开游标
 open mycursor;
--通过游标获取数据
fetch mycursor into var_empno,var_ename,var_sal;
l1:loop --loop 没有推出，会报错
select var_empno,var_ename,var_sal;
end loop l1;
--关闭游标
close mycursor;
begin
end $$
delimter ;

call proc16('sales');
```
**异常处理handler句柄**
对存储过程的错误异常处理

```sql
drop procedure if exists proc16
delimiter $$
create procedure proc17(in in_dname varchar(30))
   declare var_empno int;
   declare var_ename varchar(50);
   declare var_sal decimal(7,2);
   --句柄的操作
   --定义异常标记值
   declare flag int default 1;
  
   --触发条件
   

--声明游标
   declare mycursor cursor for
      select empno,ename,sal,from dept a,emp b 
      where a.deptno = b.deptno and a.dname = in_dname;
   --定义异常处理句柄，异常处理完成后，剩余代码是否执行（continue/exit）
   declare continue handler for NOT FOUND set flag = 0   
   --打开游标
   open mycursor;
   --通过游标获取数据
   fetch mycursor into var_empno,var_ename,var_sal;
   l1:loop --loop 没有推出，会报错
   if flag =1
      then 
         select var_empno,var_ename,var_sal;
   else 
      leave l1;
   end if;         
   end loop l1;
   --关闭游标
   close mycursor;
begin
end $$
delimter ;
call proc17('sales');
```
使用场景：可以通过存储过程创建下个月的每张表

## 8.存储函数
创建存储函数
```sql
drop function if exists my_function1;
--无参数存储函数
delimiter $$
create function my_function1() returns int
begin 
   declare cnt int default 0;
   select count(*) into cnt from emp;
   return cnt;
end $$
delimiter ;

--调用
select my_function1();

--有参数存储函数
drop function if exists my_function2;
--无参数存储函数
delimiter $$
create function my_function2(in param_empno int) returns varchar(50)
begin 
   declare out_empname varchar(50);
   select ename into out_empname  from emp where empno = param_empno;
   return out_empname;
end $$
delimiter ;

--调用
select my_function2(1001);
```
## 9. 触发器
> 特殊的存储过程，对代码进行封装。
> 当表中的数据发生变更时（insert/update/delete），会自动触发触发器的调用,不需要手动调用
> 触发器可以作为日志记录工具来使用
> mysql只支持行级触发
> 定义什么条件触发
> 什么时候触发
> 触发频率

**创建触发器**
```sql
--单条语句触发
create trigger my_trigger1 after|before insert|update|delete
on user
for each row
insert into user_logs values(null,now(),'new user');
--多条语句触发
create trigger my_trigger1 after|before insert|update|delete
on user
for each row
delimiter $$
begin
   insert into user_logs values(null,now(),'new user');
   insert into user_logs values(null,now(),'new user');
end $$
delimiter ;
```



