# 设计模式
> 设计经验的总结
> 解决特定问题的一系列套路
> 面向对象的设计原则的实际运用

## UML
设计模式中要使用的是类图
类图显示模型的静态结构，定义类的名称，属性，方法，以及与其他类之间的关系

## 软件设计原则
> **开闭原则**--对扩展开放，对修改关闭，类似于电脑热插拔，使用抽象类和接口，提高灵活性和适应性
> **里氏替换原则**：任何基类出现的地方，子类一定可以出现，子类可以扩展父类的功能，但不能改变父类原有的功能（使用接口抽象类，不要直接使用继承重写父类的方法）
> **依赖倒转原则**：高层模块不应该依赖底层模块，面对抽象接口来实现依赖，而不是直接面向类实现依赖
> **接口隔离原则**：客户端不应该被迫依赖它不使用的方法，依赖应该建立在最小的接口上
> **迪米特法则**： 最少知道原则，两个软件实体无需直接通信，则不应该发生直接的相互调用，可以通过第三方转发调用
> **合成复用原则**：尽量使用组合或聚合关系来实现，其次才考虑使用继承关系来实现
## 创建型模式
**对象的创建与使用分离，使用者不需要关注对象的创建细节**
### 1. 单例设计模式
创建一个类的单一实例
> 饿汉式：类加载就会导致实例的创建，类的实例即使不使用也会在内存中
```java
//1.直接初始化属静态性，
public class Singleton {
    //直接初始化属静态性
    private static Singleton singleton = new Singleton();

    private  Singleton() {
        System.out.println("生成一个实例");
    }
    public static Singleton getInstance(){
        return singleton;
    }
}
//2.利用静态代码块创建
public class Singleton2 {

    private static Singleton2 singleton2;
    //利用静态代码块创建
    static {
        singleton2 = new Singleton2();
    }

    private Singleton2() {
        System.out.println("生成一个实例");
    }
    public static Singleton2 getInstance(){
        return singleton2;
    }
}

```

> 懒汉式：实例的创建会推迟到类使用时
```java
//3.线程的不安全方式
public class Singleton3 {
    private Singleton3(){

    }
    private static Singleton3 instance;

    public static Singleton3 getInstance(){
        if(instance == null){
            instance = new Singleton3();
        }
        return instance;
    }
}
//4.普通加锁方式
public class Singleton3 {
    private Singleton3(){

    }
    private static Singleton3 instance;

    public static synchronized Singleton3 getInstance(){
        if(instance == null){
            instance = new Singleton3();
        }
        return instance;
    }
}

//5.DCL方式,多线程情况下可能出现空指针，由于JVM的优化可能导致指令重排序，导致空指针，这里需要添加volatile
public class Singleton5 {
    private Singleton5() {
    }

    private static volatile Singleton5 instance;

    public static Singleton5 getInstance(){
        //第一次判断，如果instance不为null
        if(instance == null){
            synchronized (Singleton5.class){
                if(instance == null){
                    instance = new Singleton5();
                }
            }
        }
        return instance;
    }
}
//6.静态内部类方式 （最推荐）
public class Singleton6 {

    private Singleton6() {
    }

    private static class Singleton6Holder{
        //内部类持有外部类
        private final static Singleton6 instance = new Singleton6();
    }
    public static Singleton6 getInstance(){
        //在使用Singleton6Holder时才会加载Singleton6Holder并实例化Singleton6
        return Singleton6Holder.instance;
    }
}
```
> 使用枚举类实现单例模式（利用枚举的安全性，枚举不存在安全性问题）饿汉模式
```java
    public enum SingletonEnum {
    //单例枚举
    INSTANCE;
}
```

> 单例模式的破坏
* 通过序列化和反序列化可以破坏单例模式 （Object io+Seriliziable）
* 利用反射开启Construct的访问检查也可以多次创建不同的实例

> 解决单例模式被破坏的问题
```java
//序列化破坏问题解决
public class Singleton6 implements Serializable {

    private Singleton6() {
    }

    private static class Singleton6Holder{
        //内部类持有外部类
        private final static Singleton6 instance = new Singleton6();
    }
    public static Singleton6 getInstance(){
        //在使用Singleton6Holder时才会加载Singleton6Holder并实例化Singleton6
        return Singleton6Holder.instance;
    }

    /**
     * 反序列化时，ObjectInputStream会自动调用该方法，解决反序列化时单例失效问题
     * @return
     */
    public Object readResolve(){
        return Singleton6Holder.instance;
    }
}
//反射破坏问题解决
public class Singleton6 implements Serializable {

    private static boolean flag = false;

    private Singleton6() {
        //判断flag的值是否为true，如果是则不是第一个访问，抛出异常,解决反射导致的单例失效问题
        synchronized (Singleton6.class){
            if(flag){
                throw new RuntimeException("不能创建多个对象");
            }
            flag = true;
        }
    }

    private static class Singleton6Holder{
        //内部类持有外部类
        private final static Singleton6 instance = new Singleton6();
    }
    public static Singleton6 getInstance(){
        //在使用Singleton6Holder时才会加载Singleton6Holder并实例化Singleton6
        return Singleton6Holder.instance;
    }

    /**
     * 反序列化时，ObjectInputStream会自动调用该方法，解决反序列化时单例失效问题
     * @return
     */
    public Object readResolve(){
        return Singleton6Holder.instance;
    }
}
```
> jdk单例举例：Runtime（java调用系统命令的工具类）

### 2. 工厂方法模式（生产同种类的产品，只产生同一接口或抽象类的子类）
**普通设计方式，添加新的品种咖啡时需要修改工厂类，工厂类是具体的类**
```java
public abstract class Coffee {

    public abstract String getName();

    public void addSugar(){
        System.out.println("add sugar");
    }

    public void addWater(){
        System.out.println("add water");
    }
}
public class LatteCoffee extends Coffee{
    @Override
    public String getName() {
        return "latte coffee";
    }
}
public class AmerCoffee extends Coffee{
    @Override
    public String getName() {
        return "american coffee";
    }
}
//工厂类
public class CoffeeStore {
    public Coffee orderCoffee(String type){
        Coffee coffee  = null;
        //添加其他总类的类目需要修改这里的代码
        if("american".equals(type)){
            coffee = new AmerCoffee();
        }else if("latte".equals(type)){
            coffee = new LatteCoffee();
        }else{
            throw new RuntimeException("cannot support this type："+ type);
        }
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}

```
**简单工厂（不属于23设计模式），解耦工厂与实际产品之间的关系**
```java
public abstract class Coffee {

    public abstract String getName();

    public void addSugar(){
        System.out.println("add sugar");
    }

    public void addWater(){
        System.out.println("add water");
    }
}
public class LatteCoffee extends Coffee{
    @Override
    public String getName() {
        return "latte coffee";
    }
}
public class AmerCoffee extends Coffee{
    @Override
    public String getName() {
        return "american coffee";
    }
}
//添加一个简单工厂类
public class SimpleCoffeeFactory {

    public Coffee createCoffee(String type){
        Coffee coffee  = null;
        if("american".equals(type)){
            coffee = new AmerCoffee();
        }else if("latte".equals(type)){
            coffee = new LatteCoffee();
        }else{
            throw new RuntimeException("cannot support this type："+ type);
        }
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}
//最终的输出工厂依赖于简单工厂，不依赖于具体的被生产类
public class CoffeeStore {
    public Coffee orderCoffee(String type){
        SimpleCoffeeFactory factory  = new SimpleCoffeeFactory();
        Coffee coffee = factory.createCoffee(type);
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}
```
**静态工厂(非23种设计模式)**
```java
public class SimpleCoffeeFactory {

    public static Coffee createCoffee(String type){
        Coffee coffee  = null;
        if("american".equals(type)){
            coffee = new AmerCoffee();
        }else if("latte".equals(type)){
            coffee = new LatteCoffee();
        }else{
            throw new RuntimeException("cannot support this type："+ type);
        }
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}
public class CoffeeStore {
    public Coffee orderCoffee(String type){
        Coffee coffee = SimpleCoffeeFactory.createCoffee(type);
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}
```
以上的几种实现都违背了开闭原则

**工厂方法模式（解耦）**
> 定一个创建对象的接口，让子类决定实例化哪个产品类对象
角色
> 抽象工厂，提供接口，提供创建对象的抽象方法
> 具体工厂
> 抽象产品 ，定义产品（对象）的规范
> 具体产品

* 用户只需要具体工厂名称，不需要知道产品的生产过程
* 系统中添加新的品种时只需要添加具体的产品类和具体的工厂类
* 系统的复杂类会增加
```java
public abstract class Coffee {

    public abstract String getName();

    public void addSugar(){
        System.out.println("add sugar");
    }

    public void addWater(){
        System.out.println("add water");
    }
}
public class LatteCoffee extends Coffee{
    @Override
    public String getName() {
        return "latte coffee";
    }
}
public class AmerCoffee extends Coffee{
    @Override
    public String getName() {
        return "american coffee";
    }
}
//抽象工厂类
public interface CoffeeFactory {

    Coffee createCoffee();
}

public class AmerCoffeeFactory implements CoffeeFactory{
    @Override
    public Coffee createCoffee() {
        return new AmerCoffee();
    }
}
public class LatteCoffeeFactory implements CoffeeFactory{
    @Override
    public Coffee createCoffee() {
        return new LatteCoffee();
    }
}
public class CoffeeStore {

    private CoffeeFactory coffeeFactory;

    //具体生产哪种coffee由客户端传入的工厂对象来决定
    public void setCoffeeFactory(CoffeeFactory coffeeFactory) {
        this.coffeeFactory = coffeeFactory;
    }

    public Coffee orderCoffee(){
        Coffee coffee = coffeeFactory.createCoffee();
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}
```
### 3. 抽象工厂模式
生产不同产品族，不同产品等级的产品，例如既做裤子，又做上衣，将不同风格的裤子、上衣组合起来组合成运动风、商务风、学生风等
角色
> 抽象工厂 包含多个创建不同产品的方法
> 具体工厂 具体产品的工厂
> 抽象产品 定义产品规范
> 具体产品

* 当一个产品族中的多个对象被设计成一起工作时，能保证客户端始终只使用同一个产品族中的对象
* 当产品族中需要新增一个产品时，所有的工厂类都需要添加相应的产品创建方法
* 一系列对象需要进行相互依赖时，或需要进行相互搭配使用时，可以采用抽象工厂
```java
public abstract class Coffee {

    public abstract String getName();

    public void addSugar(){
        System.out.println("add sugar");
    }

    public void addWater(){
        System.out.println("add water");
    }
}
public class LatteCoffee extends Coffee{
    @Override
    public String getName() {
        return "latte coffee";
    }
}
public class AmerCoffee extends Coffee{
    @Override
    public String getName() {
        return "american coffee";
    }
}
public abstract class Dessert {
    public abstract void show();
}
public class MatchMousse extends Dessert{
    @Override
    public void show() {
        System.out.println("matchMousse");
    }
}
public class Trimisu extends Dessert{
    @Override
    public void show() {
        System.out.println("Trimisu");
    }
}
public interface DessertFactory {

    public Coffee createCoffee();

    public Dessert createDessert();
}
//具体的工厂中组装不同的产品族
public class ItalyDessertFactory implements DessertFactory{
    @Override
    public Coffee createCoffee() {
        return new LatteCoffee();
    }

    @Override
    public Dessert createDessert() {
        return new Trimisu();
    }
}
public class AmerDessertFactory implements DessertFactory{
    @Override
    public Coffee createCoffee() {
        return new AmerCoffee();
    }

    @Override
    public Dessert createDessert() {
        return new MatchMousse();
    }
}
```
**简单工厂+配置文件解除耦合(spring的容器实现方式)**
通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合,模仿spring 的IOC容器的实现
* 如果需要扩展新的bean实例，只需要在配置文件中添加一个class的键值对即可.
properties配置文件  
```properties
amer=steven.lee.com.factoryextends.AmerCoffee
latte=steven.lee.com.factoryextends.LatteCoffee
```  
简单工厂类
```java
public class CoffeeFactory {
    //读取配置文件
    //加载具体的实例
    //放在map中


    private static HashMap<String,Coffee> map = new HashMap<>();
    static{
        Properties properties = new Properties();
        final InputStream resourceAsStream = CoffeeFactory.class.getClassLoader().getResourceAsStream("bean.properties");
        try{
            properties.load(resourceAsStream);
            Set<Object> keys = properties.keySet();
            keys.forEach(key ->{
                String classname = properties.getProperty((String) key);
                //反射创建对象
                Class clazz = null;
                try {
                    clazz = Class.forName(classname);
                    Coffee coffee = (Coffee) clazz.newInstance();
                    map.put((String) key,coffee);
                } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
                    e.printStackTrace();
                }
            });

        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    public static Coffee createCoffee(String name){
        return map.get(name);
    }
}
```
> jdk 中的Collection使用了工厂方法模式 ,DateFormat、Calendar 都用了工厂模式
  * Collection 抽象工厂
  * ArrayList  具体工厂
  * Iterator  抽象产品
  * ArrayList.Itr implements Iterator 具体产品

## 4. 原型模式
通过一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的对象
角色
>  抽象原型类 Cloneable
>  具体原型类
>  访问类

* 对象的创建比较复杂，可以使用原型模式快捷的创建对象
* 性能和安全性比较高的场景使用

* 浅克隆 ：新对象的属性和原来对象的属性完全相同（引用对象一样）
* 深克隆 : 新对象的引用对象也会被克隆

**最简单情况**
```java
public class RealizeType implements Cloneable{

    public RealizeType() {
    }

    @Override
    protected RealizeType clone() throws CloneNotSupportedException {
        System.out.println("原型对象复制成功");
        return (RealizeType) super.clone();
    }
}
public class RealizeTypeMain {
    public static void main(String[] args) throws CloneNotSupportedException {
        RealizeType realizeType1 = new RealizeType();
        RealizeType realizeTypeClone = realizeType1.clone();
        System.out.println(realizeType1 ==realizeTypeClone );
    }
}
```
**浅克隆--属性不进行克隆**
```java
package steven.lee.com.prototype.shallow;

/**
 * @Description:
 * @CreateDate: Created in 2023/3/2 20:19
 * @Author: lijie3
 */
public class Citation implements Cloneable{

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void show(){
        System.out.println(name + "is a citation");
    }

    @Override
    protected Citation clone() throws CloneNotSupportedException {
        return (Citation) super.clone();
    }
}
public class CitationMain {

    public static void main(String[] args) throws CloneNotSupportedException {
        Citation citation = new Citation();
        //先克隆后赋值
        Citation citation1 = citation.clone();

        citation.setName("zhangsan");

        citation1.setName("lisi");
    }
}
```
**深克隆**
//对引用属性也要进行克隆
```java
public class Citation implements Cloneable{

    private Student student;

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    public void show(){
        System.out.println(student.getName() + "is a citation");
    }

    @Override
    protected Citation clone() throws CloneNotSupportedException {

        Citation citation =  (Citation) super.clone();
        //克隆时要将引用对象也要进行克隆
        citation.setStudent(student.clone());
        return citation;
    }
}

public class Student implements Cloneable{
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    protected Student clone() throws CloneNotSupportedException {
        return (Student) super.clone();
    }
}
public class DeepMain {
    public static void main(String[] args) throws CloneNotSupportedException {
        Student student = new Student();
        student.setName("steven ");
        Citation citation = new Citation();
        citation.setStudent(student);
        Citation citation1 = citation.clone();
        citation.show();
        citation1.show();
        student.setName("steven1 ");
        //citation1的student未被修改，已被克隆
        citation1.show();
        System.out.println(citation == citation1);
        System.out.println(citation.getStudent() == citation1.getStudent());
    }
}
//另外使用ObjectInputStream/ObjectOutputStream的序列化/反序列化也可以实现原型模式
```   
### 5.构建者模式
将一个复杂的对象的构建与表示分离，使得用相同的构建过程可是创建不同的表示
分离了的部件的构造由builder来负责，由Director来装配
* 适用于某个对象构建过程复杂的情况
* 实现构建和装配的解耦，一步一步创建一个复杂的对象

角色
> 抽象建造者buidler，规定要实现复杂对象的哪些部分的创建
> 具体建造者 实现builder接口
> 产品类 要创建的复杂对象
> 指挥者类 director ，调用具体的建造者来实现类的装配

* 封装性好，将主要组装过程逻辑封装在指挥者中，当建造过程发生变更，只需要在指挥者中添加相应的建造逻辑
* 更加精细的控制创建的过程
* 产品本身与产品的创建过程解耦，使用相同的创建过程可以创建不同的产品对象
* 容易扩展，有新的需求，通过实现一个新的建造者类就可以完成
* 当产品之间的差异过大不适合使用建造者模式
```java
//产品信息
public class Bike {

    private String frame;

    private String seat;

    public String getFrame() {
        return frame;
    }

    public void setFrame(String frame) {
        this.frame = frame;
    }

    public String getSeat() {
        return seat;
    }

    public void setSeat(String seat) {
        this.seat = seat;
    }
}
//建造者
public abstract class Builder {

    protected  Bike bike = new Bike();

    public abstract Builder builderFrame();
    public abstract Builder builderSeat();
    public abstract Bike createBike();
}
public class MobikeBuilder extends Builder{


    @Override
    public Builder builderFrame() {
        bike.setFrame("mobike frame");

        return this;
    }

    @Override
    public Builder builderSeat() {
        bike.setSeat("mobike seat");
        return this;
    }

    @Override
    public Bike createBike() {
        return new Bike();
    }
}
public class OfoBuilder extends Builder{
    @Override
    public Builder builderFrame() {
        bike.setFrame("ofo frame");

        return this;
    }

    @Override
    public Builder builderSeat() {
        bike.setSeat("ofo seat");
        return this;
    }

    @Override
    public Bike createBike() {
        return bike;
    }
}
//指挥者，控制调用的先后顺序并生成最终的产品
public class Director {
    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }
    
    public Bike construct(){
        return builder.builderFrame().builderSeat().createBike();
    }
}
```
* 可以合并指挥者和建造者
```java
public class OfoBuilder extends Builder{
    @Override
    public Builder builderFrame() {
        bike.setFrame("ofo frame");

        return this;
    }

    @Override
    public Builder builderSeat() {
        bike.setSeat("ofo seat");
        return this;
    }

    @Override
    public Bike createBike() {
//        return bike;
        return this.builderFrame().builderSeat().createBike();
    }
}
```
**扩展**
当一个类创建时需要传入很多参数时，如果使用全参数的构造器，可读性会很差
可以使用建造者模式来实现
```java
public class LombokBuilder {

    private int id;

    private String name;

    public LombokBuilder() {
    }

    public LombokBuilder(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public static Builder builder(){
        return new Builder();
    }

    public static class Builder {
        private int id;

        private String name;

        public Builder id(int id){
            this.id = id;
            return this;
        }

        public Builder name(String name){
            this.name = name;
            return this;
        }
        public LombokBuilder build(){
            return new LombokBuilder(this.id,this.name);
        }
    }

    @Override
    public String toString() {
        return "LombokBuilder{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }

    public static void main(String[] args) {
        LombokBuilder lombokBuilder = LombokBuilder.builder().id(1).name("dxy").build();
        System.out.println(lombokBuilder);
    }
}
```


## 结构型模式
**用于描述如何将类或对象按照某种布局组成更大的结构,分为类结构型模式和对象结构型模式**
**组合和聚合关系比继承关系耦合度更低，满足合成复用原则，对象结构型模式比类结构型模式具有更大的灵活性**
### 6.代理模式
由于某些原因需要给对象提供一个代理提供对被代理对象的控制
* java 中代理按照代理类的生成时机不同又分为静态代理和动态代理

角色
> 抽象主题类Subject
> 真是主题类Real Subject
> 代理类 Proxy 提供与真实主题相同的接口，提供对真实访问主题的访问控制和功能扩充

* 动态代理相比静态代理可以将所有的被代理类或接口的方法都放在代理类中的同一个方法中进行集中处理
* 被代理类增加一个方法，动态代理类中不需要添加额外的代理方法，而静态代理必须添加一个新的代理方法来支持代理

* 代理模式和客户端与目标独享之间起到了一个终结作用和保护目标对象的作用
* 代理对象可以扩展目标的功能
* 将客户端与目标对象分离，在一定程度上降低系统耦合度
* 增加了系统的复杂度

* 使用场景：远程代理（rpc请求），防火墙代理，保护代理

**静态代理**
```java
public interface SellTickets {

    void sell();
}
//具体实现类
public class TrainStation implements SellTickets{
    @Override
    public void sell() {
        System.out.println("Train station sell tickets");
    }
}
//静态代理类
public class ProxyPoint implements SellTickets{
    private TrainStation trainStation = new TrainStation();
    @Override
    public void sell() {
        System.out.println("proxy get tips");
        trainStation.sell();
    }
}
//客户端
public class Main {

    public static void main(String[] args) {
        ProxyPoint proxyPoint = new ProxyPoint();
        proxyPoint.sell();
    }
}

```
**jdk动态代理**
> Proxy 生成动态代理的工具
> newProxyInstance方法参数  
  * ClassLoader:类加载器
  * Class<>[] 被代理类实现的接口class类型
  * Invocationhandler

> InvocationHandler中的invoke参数
  * proxy 生成的代理对象本身
  * Method method 被代理执行的方法
  * Object[] args 被代理对象方法执行时的传参

> 使用arthas分析生成的代码，可以看到动态生成了一个$Proxy的类
> $Proxy实现了SellTickets接口，并且继承了Proxy类（这是jdk动态代理只能代理接口的原因）
> $Proxy中持有了一个h参数（从Proxy继承过来，h的即在newProxyInstance方法中指定的InvocationHandler）
> 客户端拿到的实际上就是$Proxy对象，执行该对象的sell方法会调用h的invoke方法进而执行station的sell方法

```java
public class ProxyFactory {

    private TrainStation station = new TrainStation();
    public SellTickets getProxyObject(){
        //返回代理对象
        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),
                station.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     *  代理执行方法  
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("jdk动态代理执行");
                        return method.invoke(station,args);
                    }
                });
        return sellTickets;

    }
}
```

**cglib动态代理**
> cglib可以在内存中动态生成类的代理
```java
public class Transtation {
    public void sell(){
        System.out.println("Transtation sell tickets");
    }
}
public class ProxyFactory implements MethodInterceptor {
    private Transtation transtation = new Transtation();
    public Transtation getProxyObject(){
        //创建enhancer对象，与jdk的proxy类类似
        Enhancer enhancer = new Enhancer();
        //设置父类
        enhancer.setSuperclass(Transtation.class);
        //设置回调函数
        enhancer.setCallback(this);
        //创建代理对象
        Transtation o = (Transtation) enhancer.create();
        return o;
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("cglib invoke");
        return method.invoke(transtation,objects);
    }
}
public class Main {

    public static void main(String[] args) {
       ProxyFactory proxyFactory = new ProxyFactory();
        Transtation transtation = proxyFactory.getProxyObject();
        transtation.sell();
    }
}
```


### 7 适配器模式
> 将一个类的接口转换成客户端希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类能一起工作
> 分为类适配器（使用类继承）和对象适配器（组合、聚合），前者耦合度高，后者实际使用中会多一点

角色
* 目标 当前系统业务所期待的接口，可以是抽象类或接口
* 适配者 是被访问和适配的现存组件库中的组件接口
* 适配器类 转换器，通过继承或引用适配者对象，把适配者接口转换成目标接口

**基于继承关系实现的适配器**
> 由于java的单继承特性，当目标是一个具体的类不是接口时，无法使用这种方式
> 违背了合成复用原则

```java
public interface TFCard {

    String readTf();

    void writeTf(String content);
}

public class TFCardImpl implements TFCard{
    @Override
    public String readTf() {
        return "tfcard read hello world";
    }

    @Override
    public void writeTf(String content) {
        System.out.println("tf card write:" + content);
    }
}
//目标接口
public interface SDCard {

    String readSd();

    void writeSd(String content);
}
//目标实现类，无法满足现有系统对适配者接口的要求
public class SDCardImpl implements SDCard{

    @Override
    public String readSd() {
        return "sd card read hello world";
    }

    @Override
    public void writeSd(String content) {
        System.out.println("sd card write: "+ content);
    }
}
//基于类继承的适配器
public class SDCardAdapter extends TFCardImpl implements SDCard{


    @Override
    public String readSd() {
        return readTf();
    }

    @Override
    public void writeSd(String content) {
        writeTf(content);
    }
}
```
**对象适配器模式**
对象适配器模式采用聚合放方式，将适配者接口聚合到适配器中
解决了类适配器存在的两个问题
```java
//对象聚合方式实现适配器
public class SDCardAdapter2 implements SDCard{
    private TFCard tfCard;

    @Override
    public String readSd() {
        return tfCard.readTf();
    }

    @Override
    public void writeSd(String content) {
        tfCard.writeTf(content);
    }
}
//client
public class ComputerMain {

    //从sd card中读取数据

    public String readSd(SDCard sdCard){
        if(sdCard == null){
            throw  new NullPointerException("sd card should not null");
        }
        return sdCard.readSd();
    }

    public void write(SDCard sdCard,String content){
        if(sdCard == null){
            throw  new NullPointerException("sd card should not null");
        }
        sdCard.writeSd(content);
    }

    public static void main(String[] args) {
        ComputerMain computerMain = new ComputerMain();
        //不使用适配器情况
        String message = computerMain.readSd(new SDCardImpl());
        System.out.println(message);

        //类适配器（少用）
        message = computerMain.readSd(new SDCardAdapter());
        System.out.println(message);
        //对象适配器
        message = computerMain.readSd(new SDCardAdapter2(new TFCardImpl()));
        System.out.println(message);
    }
}
```
使用场景
* 以前开发的系统存在满足新系统功能需求的类，但器接口同新系统的接口不一致
* 使用第三方的组件，但组件接口定义和自己要求的接口定义不同
jdk中的使用
> Reader、inputStream 的适配使用的是InputStreamReader,在底层使用的适配器是StreamDecoder，使用的是对象适配器

### 8 装饰者模式
在不改变现有对象结构的情况下，动态的给该对象增加一些职责（增加额外的功能）

**角色**
> 抽象构件 定义一个抽象接口以规范准备接收附加责任的对象
> 具体构建 实现抽象构件，通过装饰角色为其添加一些职责
> 抽象装饰 继承或实现抽象构件，并包含具体的构件的实例，通过其子类扩展构建的功能
> 具体装饰 实现抽象装饰的相关方法，并给具体构件对象添加附加的责任

**好处**
* 装饰者带来比继承更好的灵活性，扩展更加方便，通过组合不同的装饰者对象来获取具有不同行为状态的多样化结果，完全准许开闭原则
* 装饰类和呗装饰类可以独立扩展，不会发生耦合

场景
当继承方式对系统进行扩展或采用继承不利于系统宽展和维护时使用
final类的定义不能继承，这时可以使用装饰者模式

**jdk中的装饰者示例**
在IO中大量使用如BufferedWriter

```java

//抽象构建角色
public abstract class FriedFood {

    private float price;

    private String desc;

    public FriedFood() {
    }

    public FriedFood(float price, String desc) {
        this.price = price;
        this.desc = desc;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }


    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public abstract  float cost();

}
//具体构建角色1
public class FriedRice extends FriedFood{


    public FriedRice() {
        this(10,"炒面");
    }

    public FriedRice(float price, String desc) {
        super(price, desc);
    }



    @Override
    public float cost() {
        return getPrice();
    }
}

//具体构建角色2
public class FriedNoodles extends FriedFood{
    public FriedNoodles() {
        this(10,"炒面");
    }

    public FriedNoodles(float price, String desc) {
        super(price, desc);
    }

    @Override
    public float cost() {
        return getPrice();
    }
}

//装饰者类，抽象装饰角色
public abstract class Garnish  extends FriedFood{
    //声明快餐类变量

    private FriedFood friedFood;

    public FriedFood getFriedFood() {
        return friedFood;
    }

    public Garnish() {
    }

    public void setFriedFood(FriedFood friedFood) {
        this.friedFood = friedFood;
    }

    public Garnish(float price, String desc, FriedFood friedFood) {
        super(price, desc);
        this.friedFood = friedFood;
    }
}
//具体装饰者角色1
public class Egg extends Garnish{
    public Egg(FriedFood friedFood) {
        super(1,"egg", friedFood);
    }

    @Override
    public float cost() {
        return getPrice() + getFriedFood().cost();
    }

    @Override
    public String getDesc() {
        return getFriedFood().getDesc()+"+"+super.getDesc()  ;
    }
}
//具体装饰者角色2
public class Bacon extends Garnish{
    public Bacon(FriedFood friedFood) {
        super(2,"bacon",friedFood);
    }

    @Override
    public float cost() {
        return getPrice()+ getFriedFood().cost();
    }
    @Override
    public String getDesc() {
        return getFriedFood().getDesc()+"+"+super.getDesc()  ;
    }
}
//客户算使用时可以进行多次反复的装饰
public class Main {
    public static void main(String[] args) {
        FriedFood friedRice = new FriedRice();
        System.out.println(friedRice.getDesc()+",price:"+ friedRice.cost());
        friedRice = new Egg(friedRice);
        System.out.println(friedRice.getDesc()+",price:"+ friedRice.cost());
        //再次装饰，再加一个蛋
        friedRice = new Egg(friedRice);
        System.out.println(friedRice.getDesc()+",price:"+ friedRice.cost());
        friedRice = new Bacon(friedRice);
        System.out.println(friedRice.getDesc()+",price:"+ friedRice.cost());
    }
}
```
**代理模式与装饰者模式的区别联系**
* 都要实现与目标类相同的业务接口
* 两个类都需要声明目标对象
* 都可以在不修改目标类的前提下增强目标方法

* 使用目的不同，装饰者是增强目标对象
* 静态代理是保护和隐藏目标对象
* 聚合的对象不同，静态代理代理的是具体的实现类（在类定义时就已经确定了使用哪个具体的被代理对象），而装饰者装饰者接口（在使用时才能决定传入哪个具体的实现类）


### 9
### 10
### 11


## 行为型模式
**用于描述类或对象之间怎样写作共同完成单个对象无法单独完成的任务，以及怎样分配职责**

