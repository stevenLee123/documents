# 设计模式
> 设计经验的总结
> 解决特定问题的一系列套路
> 面向对象的设计原则的实际运用

## UML
设计模式中要使用的是类图
类图显示模型的静态结构，定义类的名称，属性，方法，以及与其他类之间的关系

## 软件设计原则
> **开闭原则**--对扩展开放，对修改关闭，类似于电脑热插拔，使用抽象类和接口，提高灵活性和适应性
> **里氏替换原则**：任何基类出现的地方，子类一定可以出现，子类可以扩展父类的功能，但不能改变父类原有的功能（使用接口抽象类，不要直接使用继承重写父类的方法）
> **依赖倒转原则**：高层模块不应该依赖底层模块，面对抽象接口来实现依赖，而不是直接面向类实现依赖
> **接口隔离原则**：客户端不应该被迫依赖它不使用的方法，依赖应该建立在最小的接口上
> **迪米特法则**： 最少知道原则，两个软件实体无需直接通信，则不应该发生直接的相互调用，可以通过第三方转发调用
> **合成复用原则**：尽量使用组合或聚合关系来实现，其次才考虑使用继承关系来实现
## 创建型模式
**对象的创建与使用分离，使用者不需要关注对象的创建细节**
### 1. 单例设计模式
创建一个类的单一实例
> 饿汉式：类加载就会导致实例的创建，类的实例即使不使用也会在内存中
```java
//1.直接初始化属静态性，
public class Singleton {
    //直接初始化属静态性
    private static Singleton singleton = new Singleton();

    private  Singleton() {
        System.out.println("生成一个实例");
    }
    public static Singleton getInstance(){
        return singleton;
    }
}
//2.利用静态代码块创建
public class Singleton2 {

    private static Singleton2 singleton2;
    //利用静态代码块创建
    static {
        singleton2 = new Singleton2();
    }

    private Singleton2() {
        System.out.println("生成一个实例");
    }
    public static Singleton2 getInstance(){
        return singleton2;
    }
}

```

> 懒汉式：实例的创建会推迟到类使用时
```java
//3.线程的不安全方式
public class Singleton3 {
    private Singleton3(){

    }
    private static Singleton3 instance;

    public static Singleton3 getInstance(){
        if(instance == null){
            instance = new Singleton3();
        }
        return instance;
    }
}
//4.普通加锁方式
public class Singleton3 {
    private Singleton3(){

    }
    private static Singleton3 instance;

    public static synchronized Singleton3 getInstance(){
        if(instance == null){
            instance = new Singleton3();
        }
        return instance;
    }
}

//5.DCL方式,多线程情况下可能出现空指针，由于JVM的优化可能导致指令重排序，导致空指针，这里需要添加volatile
public class Singleton5 {
    private Singleton5() {
    }

    private static volatile Singleton5 instance;

    public static Singleton5 getInstance(){
        //第一次判断，如果instance不为null
        if(instance == null){
            synchronized (Singleton5.class){
                if(instance == null){
                    instance = new Singleton5();
                }
            }
        }
        return instance;
    }
}
//6.静态内部类方式 （最推荐）
public class Singleton6 {

    private Singleton6() {
    }

    private static class Singleton6Holder{
        //内部类持有外部类
        private final static Singleton6 instance = new Singleton6();
    }
    public static Singleton6 getInstance(){
        //在使用Singleton6Holder时才会加载Singleton6Holder并实例化Singleton6
        return Singleton6Holder.instance;
    }
}
```
> 使用枚举类实现单例模式（利用枚举的安全性，枚举不存在安全性问题）饿汉模式
```java
    public enum SingletonEnum {
    //单例枚举
    INSTANCE;
}
```
 使用枚举的好处：
* 使用静态成员变量，限制实例个数
* 不会出现并发问题
* 不会被反射破坏单例
* 不会被反序列化破坏单例
* 属于饿汉式
* 可以通过构造方法加入初始化逻辑

> 单例模式的破坏
* 通过序列化和反序列化可以破坏单例模式 （Object io+Seriliziable）
* 利用反射开启Construct的访问检查也可以多次创建不同的实例

> 解决单例模式被破坏的问题
```java
//序列化破坏问题解决
public class Singleton6 implements Serializable {

    private Singleton6() {
    }

    private static class Singleton6Holder{
        //内部类持有外部类
        private final static Singleton6 instance = new Singleton6();
    }
    public static Singleton6 getInstance(){
        //在使用Singleton6Holder时才会加载Singleton6Holder并实例化Singleton6
        return Singleton6Holder.instance;
    }

    /**
     * 反序列化时，ObjectInputStream会自动调用该方法，解决反序列化时单例失效问题
     * @return
     */
    public Object readResolve(){
        return Singleton6Holder.instance;
    }
}
//反射破坏问题解决
public class Singleton6 implements Serializable {

    private static boolean flag = false;

    private Singleton6() {
        //判断flag的值是否为true，如果是则不是第一个访问，抛出异常,解决反射导致的单例失效问题
        synchronized (Singleton6.class){
            if(flag){
                throw new RuntimeException("不能创建多个对象");
            }
            flag = true;
        }
    }

    private static class Singleton6Holder{
        //内部类持有外部类
        private final static Singleton6 instance = new Singleton6();
    }
    public static Singleton6 getInstance(){
        //在使用Singleton6Holder时才会加载Singleton6Holder并实例化Singleton6
        return Singleton6Holder.instance;
    }

    /**
     * 反序列化时，ObjectInputStream会自动调用该方法，解决反序列化时单例失效问题
     * @return
     */
    public Object readResolve(){
        return Singleton6Holder.instance;
    }
   
}
```

> jdk单例举例：Runtime（java调用系统命令的工具类）

### 2. 工厂方法模式（生产同种类的产品，只产生同一接口或抽象类的子类）
**普通设计方式，添加新的品种咖啡时需要修改工厂类，工厂类是具体的类**
```java
public abstract class Coffee {

    public abstract String getName();

    public void addSugar(){
        System.out.println("add sugar");
    }

    public void addWater(){
        System.out.println("add water");
    }
}
public class LatteCoffee extends Coffee{
    @Override
    public String getName() {
        return "latte coffee";
    }
}
public class AmerCoffee extends Coffee{
    @Override
    public String getName() {
        return "american coffee";
    }
}
//工厂类
public class CoffeeStore {
    public Coffee orderCoffee(String type){
        Coffee coffee  = null;
        //添加其他总类的类目需要修改这里的代码
        if("american".equals(type)){
            coffee = new AmerCoffee();
        }else if("latte".equals(type)){
            coffee = new LatteCoffee();
        }else{
            throw new RuntimeException("cannot support this type："+ type);
        }
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}

```
**简单工厂（不属于23设计模式），解耦工厂与实际产品之间的关系**
```java
public abstract class Coffee {

    public abstract String getName();

    public void addSugar(){
        System.out.println("add sugar");
    }

    public void addWater(){
        System.out.println("add water");
    }
}
public class LatteCoffee extends Coffee{
    @Override
    public String getName() {
        return "latte coffee";
    }
}
public class AmerCoffee extends Coffee{
    @Override
    public String getName() {
        return "american coffee";
    }
}
//添加一个简单工厂类
public class SimpleCoffeeFactory {

    public Coffee createCoffee(String type){
        Coffee coffee  = null;
        if("american".equals(type)){
            coffee = new AmerCoffee();
        }else if("latte".equals(type)){
            coffee = new LatteCoffee();
        }else{
            throw new RuntimeException("cannot support this type："+ type);
        }
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}
//最终的输出工厂依赖于简单工厂，不依赖于具体的被生产类
public class CoffeeStore {
    public Coffee orderCoffee(String type){
        SimpleCoffeeFactory factory  = new SimpleCoffeeFactory();
        Coffee coffee = factory.createCoffee(type);
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}
```
**静态工厂(非23种设计模式)**
```java
public class SimpleCoffeeFactory {

    public static Coffee createCoffee(String type){
        Coffee coffee  = null;
        if("american".equals(type)){
            coffee = new AmerCoffee();
        }else if("latte".equals(type)){
            coffee = new LatteCoffee();
        }else{
            throw new RuntimeException("cannot support this type："+ type);
        }
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}
public class CoffeeStore {
    public Coffee orderCoffee(String type){
        Coffee coffee = SimpleCoffeeFactory.createCoffee(type);
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}
```
以上的几种实现都违背了开闭原则

**工厂方法模式（解耦）**
> 定一个创建对象的接口，让子类决定实例化哪个产品类对象
角色
> 抽象工厂，提供接口，提供创建对象的抽象方法
> 具体工厂
> 抽象产品 ，定义产品（对象）的规范
> 具体产品

* 用户只需要具体工厂名称，不需要知道产品的生产过程
* 系统中添加新的品种时只需要添加具体的产品类和具体的工厂类
* 系统的复杂类会增加
```java
public abstract class Coffee {

    public abstract String getName();

    public void addSugar(){
        System.out.println("add sugar");
    }

    public void addWater(){
        System.out.println("add water");
    }
}
public class LatteCoffee extends Coffee{
    @Override
    public String getName() {
        return "latte coffee";
    }
}
public class AmerCoffee extends Coffee{
    @Override
    public String getName() {
        return "american coffee";
    }
}
//抽象工厂类
public interface CoffeeFactory {

    Coffee createCoffee();
}

public class AmerCoffeeFactory implements CoffeeFactory{
    @Override
    public Coffee createCoffee() {
        return new AmerCoffee();
    }
}
public class LatteCoffeeFactory implements CoffeeFactory{
    @Override
    public Coffee createCoffee() {
        return new LatteCoffee();
    }
}
public class CoffeeStore {

    private CoffeeFactory coffeeFactory;

    //具体生产哪种coffee由客户端传入的工厂对象来决定
    public void setCoffeeFactory(CoffeeFactory coffeeFactory) {
        this.coffeeFactory = coffeeFactory;
    }

    public Coffee orderCoffee(){
        Coffee coffee = coffeeFactory.createCoffee();
        coffee.addSugar();
        coffee.addWater();
        return coffee;
    }
}
```
### 3. 抽象工厂模式
生产不同产品族，不同产品等级的产品，例如既做裤子，又做上衣，将不同风格的裤子、上衣组合起来组合成运动风、商务风、学生风等
角色
> 抽象工厂 包含多个创建不同产品的方法
> 具体工厂 具体产品的工厂
> 抽象产品 定义产品规范
> 具体产品

* 当一个产品族中的多个对象被设计成一起工作时，能保证客户端始终只使用同一个产品族中的对象
* 当产品族中需要新增一个产品时，所有的工厂类都需要添加相应的产品创建方法
* 一系列对象需要进行相互依赖时，或需要进行相互搭配使用时，可以采用抽象工厂
```java
public abstract class Coffee {

    public abstract String getName();

    public void addSugar(){
        System.out.println("add sugar");
    }

    public void addWater(){
        System.out.println("add water");
    }
}
public class LatteCoffee extends Coffee{
    @Override
    public String getName() {
        return "latte coffee";
    }
}
public class AmerCoffee extends Coffee{
    @Override
    public String getName() {
        return "american coffee";
    }
}
public abstract class Dessert {
    public abstract void show();
}
public class MatchMousse extends Dessert{
    @Override
    public void show() {
        System.out.println("matchMousse");
    }
}
public class Trimisu extends Dessert{
    @Override
    public void show() {
        System.out.println("Trimisu");
    }
}
public interface DessertFactory {

    public Coffee createCoffee();

    public Dessert createDessert();
}
//具体的工厂中组装不同的产品族
public class ItalyDessertFactory implements DessertFactory{
    @Override
    public Coffee createCoffee() {
        return new LatteCoffee();
    }

    @Override
    public Dessert createDessert() {
        return new Trimisu();
    }
}
public class AmerDessertFactory implements DessertFactory{
    @Override
    public Coffee createCoffee() {
        return new AmerCoffee();
    }

    @Override
    public Dessert createDessert() {
        return new MatchMousse();
    }
}
```
**简单工厂+配置文件解除耦合(spring的容器实现方式)**
通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合,模仿spring 的IOC容器的实现
* 如果需要扩展新的bean实例，只需要在配置文件中添加一个class的键值对即可。
bean.properties配置文件  
```properties
amer=steven.lee.com.factoryextends.AmerCoffee
latte=steven.lee.com.factoryextends.LatteCoffee
```  
简单工厂类
```java
public class CoffeeFactory {
    //读取配置文件
    //加载具体的实例
    //放在map中


    private static HashMap<String,Coffee> map = new HashMap<>();
    static{
        Properties properties = new Properties();
        final InputStream resourceAsStream = CoffeeFactory.class.getClassLoader().getResourceAsStream("bean.properties");
        try{
            properties.load(resourceAsStream);
            Set<Object> keys = properties.keySet();
            keys.forEach(key ->{
                String classname = properties.getProperty((String) key);
                //反射创建对象
                Class clazz = null;
                try {
                    clazz = Class.forName(classname);
                    Coffee coffee = (Coffee) clazz.newInstance();
                    map.put((String) key,coffee);
                } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
                    e.printStackTrace();
                }
            });

        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    public static Coffee createCoffee(String name){
        return map.get(name);
    }
}
```
> jdk 中的Collection使用了工厂方法模式 ,DateFormat、Calendar 都用了工厂模式
  * Collection 抽象工厂
  * ArrayList  具体工厂
  * Iterator  抽象产品
  * ArrayList.Itr implements Iterator 具体产品

## 4. 原型模式
通过一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的对象
角色
>  抽象原型类 Cloneable
>  具体原型类
>  访问类

* 对象的创建比较复杂，可以使用原型模式快捷的创建对象
* 性能和安全性比较高的场景使用

* 浅克隆 ：新对象的属性和原来对象的属性完全相同（引用对象一样）
* 深克隆 : 新对象的引用对象也会被克隆

**最简单情况**
```java
public class RealizeType implements Cloneable{

    public RealizeType() {
    }

    @Override
    protected RealizeType clone() throws CloneNotSupportedException {
        System.out.println("原型对象复制成功");
        return (RealizeType) super.clone();
    }
}
public class RealizeTypeMain {
    public static void main(String[] args) throws CloneNotSupportedException {
        RealizeType realizeType1 = new RealizeType();
        RealizeType realizeTypeClone = realizeType1.clone();
        System.out.println(realizeType1 ==realizeTypeClone );
    }
}
```
**浅克隆--属性不进行克隆**
```java
package steven.lee.com.prototype.shallow;

/**
 * @Description:
 * @CreateDate: Created in 2023/3/2 20:19
 * @Author: lijie3
 */
public class Citation implements Cloneable{

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void show(){
        System.out.println(name + "is a citation");
    }

    @Override
    protected Citation clone() throws CloneNotSupportedException {
        return (Citation) super.clone();
    }
}
public class CitationMain {

    public static void main(String[] args) throws CloneNotSupportedException {
        Citation citation = new Citation();
        //先克隆后赋值
        Citation citation1 = citation.clone();

        citation.setName("zhangsan");

        citation1.setName("lisi");
    }
}
```
**深克隆**
//对引用属性也要进行克隆
```java
public class Citation implements Cloneable{

    private Student student;

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    public void show(){
        System.out.println(student.getName() + "is a citation");
    }

    @Override
    protected Citation clone() throws CloneNotSupportedException {

        Citation citation =  (Citation) super.clone();
        //克隆时要将引用对象也要进行克隆
        citation.setStudent(student.clone());
        return citation;
    }
}

public class Student implements Cloneable{
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    protected Student clone() throws CloneNotSupportedException {
        return (Student) super.clone();
    }
}
public class DeepMain {
    public static void main(String[] args) throws CloneNotSupportedException {
        Student student = new Student();
        student.setName("steven ");
        Citation citation = new Citation();
        citation.setStudent(student);
        Citation citation1 = citation.clone();
        citation.show();
        citation1.show();
        student.setName("steven1 ");
        //citation1的student未被修改，已被克隆
        citation1.show();
        System.out.println(citation == citation1);
        System.out.println(citation.getStudent() == citation1.getStudent());
    }
}
//另外使用ObjectInputStream/ObjectOutputStream的序列化/反序列化也可以实现原型模式
```   
### 5.构建者模式
将一个复杂的对象的构建与表示分离，使得用相同的构建过程可是创建不同的表示
分离了的部件的构造由builder来负责，由Director来装配
* 适用于某个对象构建过程复杂的情况
* 实现构建和装配的解耦，一步一步创建一个复杂的对象

角色
> 抽象建造者buidler，规定要实现复杂对象的哪些部分的创建
> 具体建造者 实现builder接口
> 产品类 要创建的复杂对象
> 指挥者类 director ，调用具体的建造者来实现类的装配

* 封装性好，将主要组装过程逻辑封装在指挥者中，当建造过程发生变更，只需要在指挥者中添加相应的建造逻辑
* 更加精细的控制创建的过程
* 产品本身与产品的创建过程解耦，使用相同的创建过程可以创建不同的产品对象
* 容易扩展，有新的需求，通过实现一个新的建造者类就可以完成
* 当产品之间的差异过大不适合使用建造者模式
```java
//产品信息
public class Bike {

    private String frame;

    private String seat;

    public String getFrame() {
        return frame;
    }

    public void setFrame(String frame) {
        this.frame = frame;
    }

    public String getSeat() {
        return seat;
    }

    public void setSeat(String seat) {
        this.seat = seat;
    }
}
//建造者
public abstract class Builder {

    protected  Bike bike = new Bike();

    public abstract Builder builderFrame();
    public abstract Builder builderSeat();
    public abstract Bike createBike();
}
public class MobikeBuilder extends Builder{


    @Override
    public Builder builderFrame() {
        bike.setFrame("mobike frame");

        return this;
    }

    @Override
    public Builder builderSeat() {
        bike.setSeat("mobike seat");
        return this;
    }

    @Override
    public Bike createBike() {
        return new Bike();
    }
}
public class OfoBuilder extends Builder{
    @Override
    public Builder builderFrame() {
        bike.setFrame("ofo frame");

        return this;
    }

    @Override
    public Builder builderSeat() {
        bike.setSeat("ofo seat");
        return this;
    }

    @Override
    public Bike createBike() {
        return bike;
    }
}
//指挥者，控制调用的先后顺序并生成最终的产品
public class Director {
    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }
    
    public Bike construct(){
        return builder.builderFrame().builderSeat().createBike();
    }
}
```
* 可以合并指挥者和建造者
```java
public class OfoBuilder extends Builder{
    @Override
    public Builder builderFrame() {
        bike.setFrame("ofo frame");

        return this;
    }

    @Override
    public Builder builderSeat() {
        bike.setSeat("ofo seat");
        return this;
    }

    @Override
    public Bike createBike() {
//        return bike;
        return this.builderFrame().builderSeat().createBike();
    }
}
```
**扩展**
当一个类创建时需要传入很多参数时，如果使用全参数的构造器，可读性会很差
可以使用建造者模式来实现
```java
public class LombokBuilder {

    private int id;

    private String name;

    public LombokBuilder() {
    }

    public LombokBuilder(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public static Builder builder(){
        return new Builder();
    }

    public static class Builder {
        private int id;

        private String name;

        public Builder id(int id){
            this.id = id;
            return this;
        }

        public Builder name(String name){
            this.name = name;
            return this;
        }
        public LombokBuilder build(){
            return new LombokBuilder(this.id,this.name);
        }
    }

    @Override
    public String toString() {
        return "LombokBuilder{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }

    public static void main(String[] args) {
        LombokBuilder lombokBuilder = LombokBuilder.builder().id(1).name("dxy").build();
        System.out.println(lombokBuilder);
    }
}
```


## 结构型模式
**用于描述如何将类或对象按照某种布局组成更大的结构,分为类结构型模式和对象结构型模式**
**组合和聚合关系比继承关系耦合度更低，满足合成复用原则，对象结构型模式比类结构型模式具有更大的灵活性**
### 6.代理模式
由于某些原因需要给对象提供一个代理提供对被代理对象的控制
* java 中代理按照代理类的生成时机不同又分为静态代理和动态代理

角色
> 抽象主题类Subject
> 真是主题类Real Subject
> 代理类 Proxy 提供与真实主题相同的接口，提供对真实访问主题的访问控制和功能扩充

* 动态代理相比静态代理可以将所有的被代理类或接口的方法都放在代理类中的同一个方法中进行集中处理
* 被代理类增加一个方法，动态代理类中不需要添加额外的代理方法，而静态代理必须添加一个新的代理方法来支持代理

* 代理模式和客户端与目标独享之间起到了一个终结作用和保护目标对象的作用
* 代理对象可以扩展目标的功能
* 将客户端与目标对象分离，在一定程度上降低系统耦合度
* 增加了系统的复杂度

* 使用场景：远程代理（rpc请求），防火墙代理，保护代理

**静态代理**
```java
public interface SellTickets {

    void sell();
}
//具体实现类
public class TrainStation implements SellTickets{
    @Override
    public void sell() {
        System.out.println("Train station sell tickets");
    }
}
//静态代理类
public class ProxyPoint implements SellTickets{
    private TrainStation trainStation = new TrainStation();
    @Override
    public void sell() {
        System.out.println("proxy get tips");
        trainStation.sell();
    }
}
//客户端
public class Main {

    public static void main(String[] args) {
        ProxyPoint proxyPoint = new ProxyPoint();
        proxyPoint.sell();
    }
}

```
**jdk动态代理**
> Proxy 生成动态代理的工具
> newProxyInstance方法参数  
  * ClassLoader:类加载器
  * Class<>[] 被代理类实现的接口class类型
  * Invocationhandler

> InvocationHandler中的invoke参数
  * proxy 生成的代理对象本身
  * Method method 被代理执行的方法
  * Object[] args 被代理对象方法执行时的传参

> 使用arthas分析生成的代码，可以看到动态生成了一个`$Proxy`的类
> $Proxy实现了SellTickets接口，并且继承了Proxy类（这是jdk动态代理只能代理接口的原因）
> `$Proxy`中持有了一个h参数（从Proxy继承过来，h的即在newProxyInstance方法中指定的InvocationHandler）
> 客户端拿到的实际上就是$Proxy对象，执行该对象的sell方法会调用h的invoke方法进而执行station的sell方法

```java
public class ProxyFactory {

    private TrainStation station = new TrainStation();
    public SellTickets getProxyObject(){
        //返回代理对象
        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),
                station.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     *  代理执行方法  
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("jdk动态代理执行");
                        return method.invoke(station,args);
                    }
                });
        return sellTickets;

    }
}
```

**cglib动态代理**
> cglib可以在内存中动态生成类的代理
```java
public class Transtation {
    public void sell(){
        System.out.println("Transtation sell tickets");
    }
}
public class ProxyFactory implements MethodInterceptor {
    private Transtation transtation = new Transtation();
    public Transtation getProxyObject(){
        //创建enhancer对象，与jdk的proxy类类似
        Enhancer enhancer = new Enhancer();
        //设置父类
        enhancer.setSuperclass(Transtation.class);
        //设置回调函数
        enhancer.setCallback(this);
        //创建代理对象
        Transtation o = (Transtation) enhancer.create();
        return o;
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("cglib invoke");
        return method.invoke(transtation,objects);
    }
}
public class Main {

    public static void main(String[] args) {
       ProxyFactory proxyFactory = new ProxyFactory();
        Transtation transtation = proxyFactory.getProxyObject();
        transtation.sell();
    }
}
```


### 7 适配器模式
> 将一个类的接口转换成客户端希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类能一起工作
> 分为类适配器（使用类继承）和对象适配器（组合、聚合），前者耦合度高，后者实际使用中会多一点

角色
* 目标 当前系统业务所期待的接口，可以是抽象类或接口
* 适配者 是被访问和适配的现存组件库中的组件接口
* 适配器类 转换器，通过继承或引用适配者对象，把适配者接口转换成目标接口

**基于继承关系实现的适配器**
> 由于java的单继承特性，当目标是一个具体的类不是接口时，无法使用这种方式
> 违背了合成复用原则

```java
public interface TFCard {

    String readTf();

    void writeTf(String content);
}

public class TFCardImpl implements TFCard{
    @Override
    public String readTf() {
        return "tfcard read hello world";
    }

    @Override
    public void writeTf(String content) {
        System.out.println("tf card write:" + content);
    }
}
//目标接口
public interface SDCard {

    String readSd();

    void writeSd(String content);
}
//目标实现类，无法满足现有系统对适配者接口的要求
public class SDCardImpl implements SDCard{

    @Override
    public String readSd() {
        return "sd card read hello world";
    }

    @Override
    public void writeSd(String content) {
        System.out.println("sd card write: "+ content);
    }
}
//基于类继承的适配器
public class SDCardAdapter extends TFCardImpl implements SDCard{


    @Override
    public String readSd() {
        return readTf();
    }

    @Override
    public void writeSd(String content) {
        writeTf(content);
    }
}
```
**对象适配器模式**
对象适配器模式采用聚合放方式，将适配者接口聚合到适配器中
解决了类适配器存在的两个问题
```java
//对象聚合方式实现适配器
public class SDCardAdapter2 implements SDCard{
    private TFCard tfCard;

    @Override
    public String readSd() {
        return tfCard.readTf();
    }

    @Override
    public void writeSd(String content) {
        tfCard.writeTf(content);
    }
}
//client
public class ComputerMain {

    //从sd card中读取数据

    public String readSd(SDCard sdCard){
        if(sdCard == null){
            throw  new NullPointerException("sd card should not null");
        }
        return sdCard.readSd();
    }

    public void write(SDCard sdCard,String content){
        if(sdCard == null){
            throw  new NullPointerException("sd card should not null");
        }
        sdCard.writeSd(content);
    }

    public static void main(String[] args) {
        ComputerMain computerMain = new ComputerMain();
        //不使用适配器情况
        String message = computerMain.readSd(new SDCardImpl());
        System.out.println(message);

        //类适配器（少用）
        message = computerMain.readSd(new SDCardAdapter());
        System.out.println(message);
        //对象适配器
        message = computerMain.readSd(new SDCardAdapter2(new TFCardImpl()));
        System.out.println(message);
    }
}
```
使用场景
* 以前开发的系统存在满足新系统功能需求的类，但器接口同新系统的接口不一致
* 使用第三方的组件，但组件接口定义和自己要求的接口定义不同
jdk中的使用
> Reader、inputStream 的适配使用的是InputStreamReader,在底层使用的适配器是StreamDecoder，使用的是对象适配器

### 8 装饰者模式
在不改变现有对象结构的情况下，动态的给该对象增加一些职责（增加额外的功能）

**角色**
> 抽象构件 定义一个抽象接口以规范准备接收附加责任的对象
> 具体构建 实现抽象构件，通过装饰角色为其添加一些职责
> 抽象装饰 继承或实现抽象构件，并包含具体的构件的实例，通过其子类扩展构建的功能
> 具体装饰 实现抽象装饰的相关方法，并给具体构件对象添加附加的责任

**好处**
* 装饰者带来比继承更好的灵活性，扩展更加方便，通过组合不同的装饰者对象来获取具有不同行为状态的多样化结果，完全准许开闭原则
* 装饰类和呗装饰类可以独立扩展，不会发生耦合

场景
当继承方式对系统进行扩展或采用继承不利于系统宽展和维护时使用
final类的定义不能继承，这时可以使用装饰者模式

**jdk中的装饰者示例**
在IO中大量使用如BufferedWriter

```java

//抽象构建角色
public abstract class FriedFood {

    private float price;

    private String desc;

    public FriedFood() {
    }

    public FriedFood(float price, String desc) {
        this.price = price;
        this.desc = desc;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }


    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public abstract  float cost();

}
//具体构建角色1
public class FriedRice extends FriedFood{


    public FriedRice() {
        this(10,"炒面");
    }

    public FriedRice(float price, String desc) {
        super(price, desc);
    }



    @Override
    public float cost() {
        return getPrice();
    }
}

//具体构建角色2
public class FriedNoodles extends FriedFood{
    public FriedNoodles() {
        this(10,"炒面");
    }

    public FriedNoodles(float price, String desc) {
        super(price, desc);
    }

    @Override
    public float cost() {
        return getPrice();
    }
}

//装饰者类，抽象装饰角色
public abstract class Garnish  extends FriedFood{
    //声明快餐类变量

    private FriedFood friedFood;

    public FriedFood getFriedFood() {
        return friedFood;
    }

    public Garnish() {
    }

    public void setFriedFood(FriedFood friedFood) {
        this.friedFood = friedFood;
    }

    public Garnish(float price, String desc, FriedFood friedFood) {
        super(price, desc);
        this.friedFood = friedFood;
    }
}
//具体装饰者角色1
public class Egg extends Garnish{
    public Egg(FriedFood friedFood) {
        super(1,"egg", friedFood);
    }

    @Override
    public float cost() {
        return getPrice() + getFriedFood().cost();
    }

    @Override
    public String getDesc() {
        return getFriedFood().getDesc()+"+"+super.getDesc()  ;
    }
}
//具体装饰者角色2
public class Bacon extends Garnish{
    public Bacon(FriedFood friedFood) {
        super(2,"bacon",friedFood);
    }

    @Override
    public float cost() {
        return getPrice()+ getFriedFood().cost();
    }
    @Override
    public String getDesc() {
        return getFriedFood().getDesc()+"+"+super.getDesc()  ;
    }
}
//客户算使用时可以进行多次反复的装饰
public class Main {
    public static void main(String[] args) {
        FriedFood friedRice = new FriedRice();
        System.out.println(friedRice.getDesc()+",price:"+ friedRice.cost());
        friedRice = new Egg(friedRice);
        System.out.println(friedRice.getDesc()+",price:"+ friedRice.cost());
        //再次装饰，再加一个蛋
        friedRice = new Egg(friedRice);
        System.out.println(friedRice.getDesc()+",price:"+ friedRice.cost());
        friedRice = new Bacon(friedRice);
        System.out.println(friedRice.getDesc()+",price:"+ friedRice.cost());
    }
}
```
**代理模式（静态）与装饰者模式的区别联系**
* 都要实现与目标类相同的业务接口
* 两个类都需要声明目标对象
* 都可以在不修改目标类的前提下增强目标方法

* 使用目的不同，装饰者是增强目标对象
* 静态代理是保护和隐藏目标对象
* 聚合的对象不同，静态代理代理的是具体的实现类（在类定义时就已经确定了使用哪个具体的被代理对象，隐藏了目标独享），而装饰者装饰者接口（在使用时才能决定传入哪个具体的实现类）


### 9. 桥接模式
抽象与实现分离，使他们可以独立变化，使用组合关系代理继承关系，降低抽象和耦合的维度
> 类功能层次与类实现层次的之间搭建桥梁
> 类功能层次：使用继承的方式，扩展基类的功能，比如A有a()方法，B继承A同时B又扩展了b()方法，C继承B又扩展了c（）方法
> 类实现层次：重写基类方法但不添加新的方法

**角色**
> 抽象化角色 定义抽象类，包含一个对实现化对象的引用
> 扩展抽象化 
> 实现化
> 具体实现化

```java
//功能层次类，扩展了display方法
public class Display {
    //持有类实现层次的基类
    private Displaybase displaybase;

    public Display(Displaybase displaybase) {
        this.displaybase = displaybase;
    }

    public void open(){
        displaybase.rawOpen();
    }

    public void print(){
        displaybase.rawPrint();
    }

    public void close(){
        displaybase.rawClose();
    }

    public final void display(){
        open();
        print();
        close();
    }

}
//类功能层次，扩展了multiDisplay方法
public class CountDisplay extends Display{
    public CountDisplay(Displaybase displaybase) {
        super(displaybase);
    }
    public void multiDisplay(int times){
        open();
        for (int i = 0; i < times; i++) {
            print();
        }
        close();
    }
}
//类实现层次基类
public abstract class Displaybase {

    public abstract void rawOpen();
    public abstract  void rawPrint();
    public abstract  void rawClose();
}
//类实现层次
public class DisplaybaseImpl extends Displaybase {

    private String string;
    private int width;

    public DisplaybaseImpl(String string) {
        this.string = string;
        this.width = string.length();
    }

    @Override
    public void rawOpen() {
        printLine();
    }

    @Override
    public void rawPrint() {
        System.out.println("|" + string + "|");
    }

    @Override
    public void rawClose() {
        printLine();
    }

    private void printLine(){
        System.out.print("+");
        for (int i = 0; i < width; i++) {
            System.out.print("-");
        }
        System.out.println("+");
    }
}
```
好处：
> 提供系统的可扩展性，当两个变化为度中任意一个维度进行扩展，都不需要修改原有系统，只需要添加类实现层次或是类的功能层次结构中继续添加实现类即可
> 实现细节对客户端透明

使用场景:
当系统中不希望使用基层或因为多层次基层导致系统的类大量增加
当类存在两个维度独立变化，且这两个维度都需要扩展
举例：在spring的BeanFactory设计中，扩展类WebApplicationContext持有了BeanFactory的一个层次实现类，实现了两个不同维度容器的桥接

### 10. 外观（门面（facade））模式
通过为多个复杂的子系统提供一个一致的子接口，使得子系统更容易被访问的模式 ---迪米特法则
为相互关联的在一起的错综复杂的类整理出一个高层接口
角色：
外观角色：为多个子系统提供一个共同的接口
子系统角色：实现系统的部分功能，客户通过外观角色访问它

```java
//子系统1
public class Light {
    public void on(){
        System.out.println("on light");
    }

    public void off(){
        System.out.println("off light");
    }
}
//子系统2
public class TV {

    public void on(){
        System.out.println("on tv");
    }

    public void off(){
        System.out.println("off tv");
    }
}
//子系统3
public class AirCondition {
    public void on(){
        System.out.println("on AirCondition");
    }

    public void off(){
        System.out.println("off AirCondition");
    }
}
//门面类，外观类，用户与该类对象交互
public class SmartApplianceFacade {

    private Light light;

    private TV tv;

    private AirCondition airCondition;

    public SmartApplianceFacade() {
        light = new Light();
        tv =new TV();
        airCondition = new AirCondition();
    }

    public void say(String message){
        if(message.contains("on")){
            on();
        } else if(message.contains("off")){
            off();
        }else{
            System.out.println("error");
        }

    }
    public  void on(){
        light.on();
        tv.on();
        airCondition.on();
    }
    public void off(){
        light.off();
        tv.off();
        airCondition.off();
    }
}
public class Main {
    public static void main(String[] args) {
        SmartApplianceFacade facade = new SmartApplianceFacade();
        facade.say("on");
        facade.say("off");
    }
}
```
优缺点：
* 降低子系统与客户端之间的耦合度
* 降低客户访问各个子系统的难度
* 不符合开闭原则，修改麻烦

实例：
* ServletRequest使用HttpServletRequest作为门面类
* slf4j 作为log4j的门面，在编程时只需要使用slf4j提供的接口即可




### 11.组合模式
在树形结构中，要保持节点之间的一致性，可以将节点和叶子节点定义保持一致可以很方便的操作各个节点
把一组相似的对象作为单一的对象，依据树型结构来组合对象

角色
> 抽象根节点
> 树枝节点：定义树枝节点的行为
> 叶子结点： 叶子结点下没有其他分支

```java 
public abstract class MenuComponent {

    protected String name;

    protected int level;


    public MenuComponent(String name, int level) {
        this.name = name;
        this.level = level;
    }

    public  void add(MenuComponent component){
        throw new UnsupportedOperationException("not support add");
    }

    public void remove(MenuComponent component){
        throw new UnsupportedOperationException("not support remove");
    }

    public MenuComponent getChild(int index){
        throw new UnsupportedOperationException("not support get");
    }


    public String getName() {
        return name;
    }

    public int getLevel() {
        return level;
    }

    //打印
    public abstract void print();
}
//树枝节点
public class Menu extends MenuComponent{

    private List<MenuComponent> menuComponentList = new ArrayList<>();
    public Menu(String name, int level) {
        super(name, level);
    }

    @Override
    public void add(MenuComponent component) {
        this.menuComponentList.add(component);
    }

    @Override
    public void remove(MenuComponent component) {
        this.menuComponentList.remove(component);
    }

    @Override
    public MenuComponent getChild(int index) {
        return this.menuComponentList.get(index);
    }

    @Override
    public void print() {
        System.out.println(name);
        for (int i = 0; i < menuComponentList.size(); i++) {
            menuComponentList.get(i).print();
        }
    }
}
//叶子结点
public class MenuItem extends MenuComponent {

    public MenuItem(String name, int level) {
        super(name, level);
    }

    @Override
    public void print() {
        System.out.println("name:" + name + ",level:" + level);
    }
}
//保持访问的一致性
public class Main {
    public static void main(String[] args) {
        MenuComponent menuComponent = new Menu("菜单管理",2);
        menuComponent.add(new MenuItem("用户页面",3));
        menuComponent.add(new MenuItem("配置页面",3));
        menuComponent.add(new MenuItem("文档页面",3));
        MenuComponent menuComponent2 = new Menu("用户管理",2);
        menuComponent2.add(new MenuItem("添加用户",3));
        menuComponent2.add(new MenuItem("修改用户",3));
        menuComponent2.add(new MenuItem("删除用户",3));
        MenuComponent menuComponent3 = new Menu("角色管理",2);
        menuComponent3.add(new MenuItem("添加角色",3));
        menuComponent3.add(new MenuItem("修改角色",3));
        menuComponent3.add(new MenuItem("删除角色",3));
        MenuComponent root = new Menu("后台管理",1);
        root.add(menuComponent);
        root.add(menuComponent2);
        root.add(menuComponent3);
        root.print();
    }
}
```
**优缺点**
* 清晰定义分层次的复杂对象
* 客户端可以一致的使用其中的单个对象，不需要关系是单个对象还是整个组合结构
* 添加子节点时不需要修改节点类

### 12.享元模式
运用共享技术来有效的支持大量细粒度的对象复用，提高代码的复用
区分外部状态（非享元部分）和内部（享元）部分
角色
> 抽象享元角色
> 具体享元角色
> 非享元
> 享元工厂


```java
//抽象享元
public abstract class AbstractBox {

    public abstract  String getShape();

    public void display(String color){
        System.out.println("方块形状:"+ getShape() +",颜色:"+color);
    }
}
public class IBox extends AbstractBox{
    @Override
    public String getShape() {
        return "I";
    }
}
public class LBox extends AbstractBox{
    @Override
    public String getShape() {
        return "L";
    }
}
public class OBox extends AbstractBox{
    @Override
    public String getShape() {
        return "O";
    }
}
//享元工厂
public class BoxFactory {

    private static BoxFactory factory = new BoxFactory();

    private HashMap<String,AbstractBox> map;

    private BoxFactory() {
        this.map = new HashMap<>();
        map.put("I",new IBox());
        map.put("O",new OBox());
        map.put("L",new LBox());
    }

    public static BoxFactory getInstance(){
        return factory;
    }

    public AbstractBox getShape(String name){
        return map.get(name);
    }
}
//对可以共用的部分提供享元，对不可共用的部分提供修改的接口
public class Main {

    public static void main(String[] args) {
        BoxFactory factory = BoxFactory.getInstance();
        AbstractBox box1 = factory.getShape("I");
        box1.display("green");
        //两次用到的box是同一个对象
        AbstractBox box2 = factory.getShape("O");
        box2.display("red");
        AbstractBox box3 = factory.getShape("O");
        box3.display("pink");
        System.out.println(box2 == box3);

    }
}
```
优缺点：
* 极大的减少内存中相似或相同的对象数量，节省系统资源
* 外部状态相对独立，不影响内部状态
* 分离内部状态和外部状态导致系统的复杂度增加
使用场景
* 当一个系统中有大量相同或相似的对象，造成内存的大量消耗
* 对象的大部分状态都可以外部化，将这些外部状态传入对象中
* 在使用享元模式需要维护一个存储享元对象的享元池，需要消耗一定的资源，需要频繁的访问享元时才使用享元

举例
jdk中的Integer（基本数据类型）、 使用了享元模式
```java 
    Integer i1 = 127;
        Integer i2 = 127;
        System.out.println(i1==i2); //true,Integer.valueof()中使用的IntegerCache将-128~127这个范围内进行了缓存

        Integer i3 = 128;

        Integer i4= 128;
        System.out.println(i3==i4);//false,IntegerCache将-128~127这个范围内进行了缓存,大于127部进行缓存
```
## 行为型模式
**用于描述类或对象之间怎样写作共同完成单个对象无法单独完成的任务，以及怎样分配职责**
### 13.模版方法模式
在一个算法设计中，已经确定了算法执行的所有关键步骤，而且确定了所有步骤执行的顺序，这时可以使用一个包含模版方法的抽象类，让子类实现具体的步骤
角色
> 抽象类，包含已实现的模版方法和基本方法（可以时抽象或具体方法）
> 具体类 实现具体的步骤处理方法

```java

//抽象模版类
public abstract class AbstractCook {

    public abstract void pourOil();

    public abstract  void heatOil();

    public abstract void fry();


    public void cookProcess(){
        pourOil();
        heatOil();
        fry();
    }
}
//实现具体步骤方法的类
public class BaocaiCook extends AbstractCook{
    @Override
    public void pourOil() {
        System.out.println("pourOil");
    }

    @Override
    public void heatOil() {
        System.out.println("heatOil");
    }

    @Override
    public void fry() {
        System.out.println("fry baocai");
    }
}
public class Main {
    public static void main(String[] args) {
        AbstractCook baocaiCook = new BaocaiCook();
        baocaiCook.cookProcess();
    }
}
```
优缺点
* 提高代码复用性
* 将部分的代码放在抽象父类中，不需要放入不同的子类中
* 实现了反转控制
* 通过父类调用其子类的操作，扩展了子类的具体行为，复合开闭原则

* 对每个不同的实现都要定义一个子类，系统更加庞大
* 父类的抽象方法由子类实现，代码的降低

场景
* 实现整体步骤固定，各个步骤有区别的流程
* 需要通过子类来决定父类中的某个步骤是否需要执行

InputStream类中的read（）都是在父类中定义的抽象方法，在子类中实现具体的read逻辑

### 14. 策略模式
定义一系列算法，并将算法封装起来，可以相互替换，不影响使用算法的客户
角色
> 抽象策略类 定义给出所有具体策略所需的接口
> 具体策略类  实现算或行为
> 环境类 Context ，策略引用上下文，给客户端调用

```java
//策略接口
public abstract class Strategy {
    public abstract void show();
}
//具体策略1
public class StrategyA extends Strategy{
    @Override
    public void show() {
        System.out.println("use Strategy A");
    }
}
//具体策略2
public class StrategyB extends Strategy{
    @Override
    public void show() {
        System.out.println("use Strategy B");
    }
}
//策略上下文
public class StrategyContext {
    private Strategy strategy;

    public StrategyContext(Strategy strategy) {
        this.strategy = strategy;
    }


    public void show(){
        strategy.show();
    }
}
//通过上下文使用策略
public class Main {

    public static void main(String[] args) {
        StrategyContext context = new StrategyContext(new StrategyA());
        context.show();
    }
}
```

优缺点
* 策略类之间可以自由切换
* 易于扩展
* 避免多重条件判断
* 复合开遍则

* 客户端必须知道所有的策略类
* 通过享元模式可以减少相同策略类的创建

使用场景
系统动态选择某种算法
出现大量if else 可以考虑使用策略模式

jdk中的策略模式
Comparator接口的排序功能

### 15. 命令模式
将命令封装成类进行传递，使发出命令和执行命令的责任分开，对命令进行管理
角色
> 抽象命令角色 申明命令执行方法
> 具体命令 实现命令接口
> 执行命令角色
> 调用命令（发出命令）角色
```java
//抽象命令类
public interface Command {

    void execute();
}

//命令接收者
public class SeniorChef {

    public void makeFood(String name,int num){
        System.out.println("做"+num +"份"+name);
    }
}
//具体命令类
public class OrderCommand implements Command {

    //持有接收者对象
    private SeniorChef reciver;

    //持有订单对象
    private Order order;

    public OrderCommand(SeniorChef reciver, Order order) {
        this.reciver = reciver;
        this.order = order;
    }

    @Override
    public void execute() {
        System.out.println(order.getDiningTable() + "桌的订单:");
        Map<String, Integer> foodDir = order.getFoodDir();
        foodDir.forEach((key, value) -> {
            reciver.makeFood(key, value);
        });
        System.out.println(order.getDiningTable() +"桌的饭准备好了");

    }
}
//其他附加信息类
public class Order {
    //桌号
    private int diningTable;

    //餐品
    private Map<String,Integer> foodDir = new HashMap<>();

    public int getDiningTable() {
        return diningTable;
    }

    public void setDiningTable(int diningTable) {
        this.diningTable = diningTable;
    }

    public Map<String, Integer> getFoodDir() {
        return foodDir;
    }

    public void setFoodDir(Map<String, Integer> foodDir) {
        this.foodDir = foodDir;
    }
    public void setFood(String name,int num){
        foodDir.put(name,num);
    }
}
//命令发起者
public class Waitor {
    //持有命令对象
    private List<Command> commandList = new ArrayList<>();

    public void setCommand(Command command){
        commandList.add(command);
    }

    //发起命令
    public void sendCommand(){
        System.out.println("服务员说，新订单来了....");
        for (Command command : commandList) {
            if(command!=null){
                command.execute();
            }
        }
    }
}
public class Consumer {

    public static void main(String[] args) {

        Order order1 = new Order();
        order1.setDiningTable(1);
        order1.setFood("西红柿鸡蛋饭",1);
        order1.setFood("可乐",1);
        Order order2 = new Order();
        order2.setDiningTable(2);
        order2.setFood("汉堡",1);
        order2.setFood("百事",1);
        //创建接收着
        SeniorChef reciver = new SeniorChef();
        Command command1 = new OrderCommand(reciver,order1);
        Command command2 = new OrderCommand(reciver,order2);
        //创建调用者
        Waitor waitor = new Waitor();
        waitor.setCommand(command1);
        waitor.setCommand(command2);
        waitor.sendCommand();
    }
}
```
优缺点
* 降低系统耦合度
* 增加或删除命令很方便
* 可以使用宏命令
* 方便实现undo和redo

* 系统结构更加复杂
* 可能导致系统存在过多的命令类

使用场景
* 系统需要将请求调用者和接收着解除耦合可以使用命令模式
* 实现命令的撤销和回复操作

示例：
jdk中的Runnable相当于是抽象的命令

### 16.责任链模式
避免请求发送者与多个请求处理者耦合在一起，将请求的处理者通过前一对象记住其下一个对象的引用而连成一条链，当有请求发生时，可沿着链传递请求，直到有对象处理它为止
角色
> 抽象处理者：定义一个处理请求的接口，包含抽象处理方法和一个后继处理者的引用
> 具体处理者：抽象处理者的实现类
> 类户类：创建处理链

```java
//抽象处理者类
public abstract class Handler {
    protected final static int num_one =1;
    protected  final static int num_three = 3;
    protected  final static int num_seven = 7;
    //责任范围
    private int numStart;

    private int numEnd;

    //后继处理者
    private Handler nextHandler;

    public Handler(int numStart, int numEnd) {
        this.numStart = numStart;
        this.numEnd = numEnd;
    }

    public void setNextHandler(Handler nextHandler) {
        this.nextHandler = nextHandler;
    }

    //处理方法
    public abstract void handle(LeaveRequest request);

    public final void submit(LeaveRequest request){
        if(request.getNum() <= numEnd){
            this.handle(request);
        }else if(this.nextHandler!=null && request.getNum() > this.numEnd){
            this.nextHandler.submit(request);
        }else{
            System.out.println("流程结束");
        }
    }
}
//处理人1
public class GroupLeader extends Handler{

    public GroupLeader() {
        super(0, Handler.num_three);
    }

    @Override
    public void handle(LeaveRequest request) {
        System.out.println(request.getName() + "请假" + request.getNum() + "天,"+request.getContent());
        System.out.println("小组长处理完毕");
    }
}
//处理人2
public class Manager extends Handler{
    public Manager() {
        super(Handler.num_one, Handler.num_three);
    }

    @Override
    public void handle(LeaveRequest request) {
        System.out.println(request.getName() + "请假" + request.getNum() + "天,"+request.getContent());
        System.out.println("经理处理完毕");
    }
}
//处理人3
public class CEO extends Handler{
    public CEO() {
        super(Handler.num_three, Handler.num_seven);
    }

    @Override
    public void handle(LeaveRequest request) {
        System.out.println(request.getName() + "请假" + request.getNum() + "天,"+request.getContent());
        System.out.println("ceo处理完毕");
    }
}
//请求
public class LeaveRequest {
    private String name;

    private int num;

    private String content;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public LeaveRequest(String name, int num, String content) {
        this.name = name;
        this.num = num;
        this.content = content;
    }
}
public class Client {
    public static void main(String[] args) {
        LeaveRequest request = new LeaveRequest("steven",4,"cold");
        Handler gleader = new GroupLeader();
        Handler manager = new Manager();
        Handler ceo = new CEO();
        //设置处理链
        gleader.setNextHandler(manager);
        manager.setNextHandler(ceo);
        gleader.submit(request);
    }
}
```
处理流程过长时，可以将处理流程分配到每个处理类中
javaweb中的filterChain是使用的责任链模式

### 17.状态模式
将类的状态封装成独立的状态类，允许状态对象在其内部发生改变时改变类的行为，避免在类中编写大量的状态判断逻辑
角色
> 上下文角色
> 抽象角色 封装环境对象中的特定状态所对应的行为
> 具体状态角色 

```java
//抽象状态类
public abstract class LiftState {
    //上下文对象，这里叫电梯
    protected Context context;

    public void setContext(Context context) {
        this.context = context;
    }

    public abstract void close();
    public abstract void run();
    public abstract void stop();
    public abstract void open();

}
//具体状态类1
public class RunState extends LiftState{
    @Override
    public void close() {
        //nothing
    }

    @Override
    public void run() {
        System.out.println("电梯已经在运行...");
    }

    @Override
    public void stop() {
        this.context.setCurrentState(Context.STOP_STATE);
        super.context.stop();
    }

    @Override
    public void open() {
        //nothing
    }
}

public class StopState extends LiftState{
    @Override
    public void close() {
        this.context.setCurrentState(Context.CLOSE_STATE);
        super.context.close();
    }

    @Override
    public void run() {
        this.context.setCurrentState(Context.RUN_STATE);
        super.context.run();
    }

    @Override
    public void stop() {
        System.out.println("电梯已经停止...");
    }

    @Override
    public void open() {
        this.context.setCurrentState(Context.OPEN_STATE);
        super.context.open();
    }
}
public class CloseState extends LiftState{
    @Override
    public void close() {
        System.out.println("电梯已关闭");
    }

    @Override
    public void run() {
        this.context.setCurrentState(Context.RUN_STATE);
        super.context.run();
    }

    @Override
    public void stop() {
        this.context.setCurrentState(Context.STOP_STATE);
        super.context.stop();
    }

    @Override
    public void open() {
        this.context.setCurrentState(Context.OPEN_STATE);
        super.context.open();
    }
}
public class OpenState extends LiftState{
    @Override
    public void close() {
        super.context.setCurrentState(Context.CLOSE_STATE);
        super.context.close();
    }

    @Override
    public void run() {
        //nothing
    }

    @Override
    public void stop() {
        //nothing
    }

    @Override
    public void open() {
        System.out.println("电梯开启...");
    }
}
//上下文对象
public class Context {

    public final static OpenState OPEN_STATE = new OpenState();
    public final static CloseState CLOSE_STATE = new CloseState();

    public final static  RunState RUN_STATE = new RunState();

    public final static  StopState STOP_STATE = new StopState();

    private LiftState currentState;

    public LiftState getCurrentState() {
        return currentState;
    }

    public void setCurrentState(LiftState currentState) {
        this.currentState = currentState;
        this.currentState.setContext(this);
    }

    public void close() {
        this.currentState.close();
    }

    public void run() {
        this.currentState.run();
    }

    public void stop() {
        this.currentState.stop();
    }

    public void open() {
        this.currentState.open();
    }
}
public class Main {

    public static void main(String[] args) {
        Context context =new Context();
        context.setCurrentState(Context.STOP_STATE);
        context.run();
        context.stop();
        context.open();
        context.close();
    }
}
```
优缺点
* 将所有与状态相关的行为都放在一个类中，方便增加新的状态，只需要改变对象状态即可改变对象的行为
* 允许状态转换逻辑与对象合成一体，不需要在上下文类中进行大量的状态判断逻辑
* 系统中增加了大量的类
* 实现复杂
* 对开闭原则支持不好

### 18.观察者模式（事件发布订阅模式）
发布订阅模式，定义一种多对多的依赖关系，让观察者同时监听某个主题对象，主题对象发生变化时，通知所有观察者
角色

> 抽象主题
> 具体主题
> 抽象观察者
> 具体观察者

```java 

//被观察对象（主题）
public interface  Subject {

    void detach(Observer observer);

    void attach(Observer observer);


    void notify(String message);
}
//具体对象
public class SubSubject implements Subject{
    private List<Observer> observerList = new ArrayList<>();

    @Override
    public void detach(Observer observer) {
        observerList.remove(observer);
    }

    @Override
    public void attach(Observer observer) {
        observerList.add(observer);
    }

    @Override
    public void notify(String message) {
        for (Observer observer : observerList) {
            observer.update(message);
        }
    }
}
//抽象观察者
public interface Observer {
     void update(String message);
}
//具体观察者
public class Observer1 implements Observer{
    private String name;

    public Observer1(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " get message"+message);
    }
}
//具体观察者
public class Observer2 implements Observer{
    private String name;
    public Observer2(String name) {
        this.name = name;
    }
    @Override
    public void update(String message) {
        System.out.println(name+ " get message :"+message);
    }
}
public class Main {
    public static void main(String[] args) {
        Subject subject = new SubSubject();
        subject.attach(new Observer1("jobs"));
        subject.attach(new Observer2("tom"));
        subject.notify("hello world");

    }
}
```
优缺点
* 降低耦合
* 可实现广播机制

jdk中的观察者
Observable/Observer

### 19. 中介者模式
### 20. 迭代器模式
### 21. 访问者模式
### 22. 备忘录模式
### 23. 解释器模式
