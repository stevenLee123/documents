# JVM
## JVM 基础概念及调优
### 1. JVM组成
> 类装载子系统 加载字节码文件放入方法区（元空间）
> 字节码执行引擎 之行字节码、写程序计数器、之行垃圾收集线程进行垃圾回收
> 运行时数据区（方法区、java堆、java栈（线程）、本地方法栈、程序计数器）

### 2. java栈（先进后出）
存放局部变量数据，分配给线程使用。一个方法对应一块栈帧内存空间

### 3. 程序计数器
每个线程都会分配一个程序计数器，存储线程当前执行的位置，当线程出现切换时，程序计数器用于在线程回复之行时指示当前线程之行的位置，程序计数器的值是由字节码之行引擎来修改的
栈帧结构
> 局部变量 方法中的局部变量
> 操作数栈 临时存放JVM指令操作数据的栈
> 动态链接 符号引用转化为直接引用
> 方法出口 方法返回的位置
另外栈中的引用对象的真实地址在堆中
### 4. 方法区（元空间）
存放类的元数据信息、常量值、静态变量（可能存在对象，在方法去中存放的也是变量的引用，真正的变量放在堆中）

### 5. 使用javap命令（将class文件转译为jvm虚拟机指令），结合jvm虚拟机能查看代码完整的之行流程

### 6. 本地方法 （native修饰的方法，没有方法体）

### 7. 堆 
新生代 分为一个eden区、两个survivor区
> eden 区，对象出生的区域
> survivor 经过minior gc之后存活的类会从eden区移动到survivor区
老年代 存放超过某一年龄代的对象，或是大对象直接分配到老年代

### 8.可达性分析
GC Root根节点 --线程本地变量、静态变量本地方法栈变量
从GC root开始搜索，搜索到的对象为非垃圾对象、未搜索到的为垃圾对象，全部回收

### 9. 一个对象在堆中的生命流转周期（一般情况下）
> 1. 对象创建以后放在新生代的eden区
> 2. 当eden区的空间无法再分配内存给新的对象时，触发一次minior GC，通过可达性分析判断eden区的对象是否被引用，如果不被引用，则直接回收，如果被引用，放入survivor区，对象的分代年龄加1，eden区再次分配空间给新的对象
> 3. 当eden区再次无法分配内存给新的对象，再次触发minior GC，通过可达性分析判断eden区和已经分配了对象的一个survivor区的可回收对象，对非垃圾对象的分代年龄再次加1，放入到另一个空闲的survivor区
> 4. 当内存不足时重复步骤3
> 5. 当某次minior gc 回收垃圾后空闲的survivor无法存放下存活的对象，则需要进行senior GC ，将对象放入老年代
> 6. 当老年代无法存放更多的对象时，会进行一次full gc
> 7. 当进行了full gc后任然无法存放新产生的对象，则JVM会抛出OOM异常

### 10. arthas 阿里开源的jvm调优工具

### 11. Java虚拟机调优 -- 减少full gc的次数，减少STW（stop the world）
为什么会有stop the world：如果不停止用户线程，线程之行过程中可能会不断的出现引用的变化，类似于现实中你妈打扫垃圾的过程中你还在不断的丢垃圾
动态年龄判断：当某次minior GC之后，存活对象的总大小大于一块survivor 区域大小的50%，则直接将这次minior GC存活下来的对象直接放入老年代中
分代GC的理论基础：大多数的对象都是朝生夕死

### 12. jvm参数设置 针对jdk8的版本，主要是对堆空间分代大小进行设置，对元空间大小进行设置，分代年龄进行设置等等

### 13. 对象的创建过程 jvm类加载子模块加载完类后对对象进行初始化，给对象的属性赋初始值--->执行底层的<init>方法，实际上是对对象的属性赋真实的值，和执行指定的类构造器方法 


## JMM java内存模型与内存屏障 Java memory model
### 主内存、工作线程
主内存：存放共享变狼
工作线程：线程所属的内存，是主内存的副本



### JMM的原子操作
> read 读取 从主内存中读取数据
> load 载入 将主内存数据写入到工作内存数据
> use 使用 从工作内存读取数据计算
> assin 赋值 将计算好的值重新赋值到工作内存中
> store 存储 将工作内存数据写入主内存
> write 写入 将store过去的变量值赋值给主内存中的变量
> lock 锁定 将主内存变量加锁，标识为线程独占
> unlock 解锁 将主内存变量解锁，解锁后其他线程可以锁定该对象

### 缓存一致性协议（MESI，硬件层面的协议）：解决多线程访问共享变量，当某一线程对变量进行修改，其他线程能马上感知到变量的修改（其他线程在使用该变量时，该变量在线程的工作内存中会被置为无效状态，这时线程会需要重新从主内存中将变量值拷贝到工作线程进行计算）

### cpu总线嗅探机制

### volatile：保证变量对线程的可见性，保证代码执行的有序性
实现原理：使用缓存一致性协议，在多个线程读取并修改主内存中的共享变量时，如果某一线程对变量进行了修改，修改后的数据会立即从该线程的工作内存 store、write到主内存。而其他使用该变量的线程在使用该变量时，该变量在工作内存中会被置为无效的状态，每次使用前必须从主内存中read、load到工作内存才能使用
在汇编层面，使用lock前缀指令保证变量对线程的可见性
jvm中使用内存屏障保证指令不重排序（storeload）


### 并发编程的三大特性
可见性
有序性
原子性

### 指令重排：
cpu在不影响单线程程序执行结果的前提下，对代码的执行顺序进行调整，最大限度的发挥机器的性能（as-if-serial）
指令重排会遵循 as-if-serial以及happens-before原则

happens-before: 前一个操作的结果对后续操作时可见

### 双重检测锁DCL存在的问题
在实现单例时，可能有些代码会时用双重检测锁的方式实现，这种方式可能由于指令重排导致存在安全漏洞（对象半初始化，对象已创建，但是没有进行属性的赋值）,需要在目标对象上加上一个volatile关键子

### 内存屏障：添加内存屏障避免指令重排


## java 锁

乐观锁
悲观锁
偏向锁
轻量级锁
重量级锁
CAS自旋锁


###  synchronized与lock的区别
synchronized 是悲观锁、互斥锁、同步锁，jdk1.6之前synchronized性能很差，是重量级锁
使用原子操作类可以很大程度上提高代码的执行效率

AQS机制

### cas自旋锁 
CAS compare and swap 比较并交换
CAS可以成为称为无锁，乐观锁，自旋锁
原子性问题 在比较并交换时，在汇编层面将这个操作变成了一个原子操作，实际上还是加了锁

### ABA问题
两个线程在cas变量a操作过程中，线程A首先拿到了a的原始值v1，进行cas，这时线程B也拿到了变量a的原始值v1，进行cas，当B的执行速度比A快时，B将a的值改成v2，随后又改成v1，然后A在进行cas的时候发现a当前的值和原来的值时相同的，则认为没有其他线程修改a，而实际上B已经对A的值进行了修改操作
解决ABA 是在引入变量的版本号，当变量值修改时，同时修改版本号信息

### 锁优化（膨胀升级）（synchronized）
jdk1.6以后针对synchronized的性能问题进行优化，引入锁状态进行锁膨胀升级： 
> 无状态（0(是否偏向，默认不开启偏向) 01（状态值））（没有加锁的情况） 
> 偏向锁 (1（启用偏向锁）01（偏向锁） )（在对象内部存储线程id，当线程id相同时，无需加锁）
> 自旋锁 （0 00（轻量级锁））（当新访问对象的线程id和对象存储的线程id不一致，则将锁升级到自旋锁，cas开始进行自旋，这种情况下是多个线程加锁CAS轻度竞争）
> 重量级锁（jdk1.6之前的锁，通过monitor对象+线程访问队列来实现） （0 10（重量级锁） ）（当有大量的线程并发时，cas多次（可能是10次，也可能是自适应自旋）自旋不成功，将锁升级成重量级锁）

### 分段CAS优化（LongAdder）: 使用cell数组将cas自旋分给cell数组中的值

### 轻量级（自旋）锁与重量级锁的比较
当并发的线程较少时，轻量级锁只会少量自旋，性能不重量级锁性能好
当并发的线程很多时，轻量级锁的自旋会照成大量的性能消耗

### 对象内部的存储结构
对象头：mark word 、metaData元数据指针、数据长度（数组对象有）
实例数据：
对齐填充：对象的大小必须是8个字节的倍数，是为了提高对象的寻址性能


## 面试题




