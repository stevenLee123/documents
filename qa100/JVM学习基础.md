# JVM

学习路线
![学习路线](./image/jvm%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.png)

## JVM 基础概念及调优
### 1. JVM组成
> 类装载子系统 加载字节码文件放入方法区（元空间） （loading(加载) -> linking（链接） ->Intializtion（初始化））
> 运行时数据区（方法区、java堆、java栈（线程独享）、本地方法栈、程序计数器（线程独享））
> 字节码执行引擎 执行字节码、写程序计数器、执行垃圾收集线程进行垃圾回收

### 2. 程序计数器
* java的二进制字节码（即JVM指令，所有平台都是一致的）无法被操作系统直接执行，需要经过java的解释器解释成机器码，然后才能由CPU执行
* 作用：程序计数器会记住下一条jvm指定的执行地址，通过寄存器实现
* 特点
  * 线程私有
  * 不会存在内存溢出
* 每个线程都会分配一个程序计数器，存储线程当前执行的位置，当线程出现切换时，程序计数器用于，一旦指令执行，程序计数器将更新到下一条指令，另外在线程恢复执行时指示能当前线程之行的位置，程序计数器的值是由字节码执行引擎来修改的 保存当前线程执行指令的地址，

### 2. java栈（先进后出）
存放局部变量数据，分配给线程使用。一个方法对应一块栈帧内存空间
栈帧结构
> 局部变量 方法中的局部变量
> 操作数栈 临时存放JVM指令操作数据的栈
> 动态链接 符号引用转化为直接引用
> 方法出口 方法返回的位置
另外栈中的引用对象的真实地址在堆中
栈大小设置(-Xss 2MB) linux 下默认是1024KB
栈溢出
> 出现没有出口的递归(栈帧过多)，抛出StackOverflowError
> 方法的执行超出了栈的大小（栈帧过大)，抛出StackOverflowError

线程安全问题：
方法内的局部变量如果没有出现逃逸的情况不会有线程安全的问题

线程诊断与排查问题
* 使用top命令定位哪个进程对CPU的占用过高
* ps H -eo pid,tid,%cpu|grep pid 进一步定位哪个线程引起cpu占用过高
* 使用jstack pid 查看线程详情，根据线程id找到有问题的线程，（可能是死锁，可能是死循环等问题），定位到线程行数

### 本地方法栈（native method stacks）
* 为本地方法执行提供内存空间
* 线程私有





### 4. 方法区（hotspot 1.8之后是元空间，使用的是操作系统的本地内存）--存储类相关的信息
线程共享
虚拟机启动时创建
存放类的元数据信息、运行时常量值、静态变量（可能存在对象，在方法中存放的也是变量的引用，真正的变量放在堆中）、字段和方法数据，以及方法和构造函数的代码，包括用于类和实例初始化及接口初始化的特殊方法
* 运行时常量池 Stringtable，不在操作系统本地内存中，在堆（heap）中

* 设置的元空间太小(jdk8，默认没有大小限制) -XX:MaxMetaspaceSize=100M - XX: -UseCompressedOops 抛出OutOfMemoryError:metaspace(jdk1.6是 PermGen space)
* 

* 方法区溢出，OutOfMemoryError

#### 常量池
二进制字节码的组成 ： 类基本信息，常量池，类的方法定义，包含虚拟机的指令
常量池的作用：为指令提供常量服务，以查表的方式查找到类名、方法名、参数类型、字面量等信息
常量池是.class文件中的，当该类被加载时，他的常量池信息会放入运行时常量池，并将里面的符号地址变为真实的地址
使用javap -v HelloWorld.class 查看类反编译后的详细信息

**串池StringTable**
运行时会将字符串常量放入StringTable中，运行时是懒加载的，只有用到时才会将串放入串池

```java
//字符串会放入StringTable串池中，在常量池中
String a = "a";
String b = "b";

String ab = "ab";
//创建c时首先会创建一个StringBuilder类并进行初始化，然后将a、b append到StringBuilder中，然后调用StringBuilder的toString方法，toString方法实际上是又创建了一个新的String对象,这时c是放在堆中的
String c = a +b; 
//返回false，因为c在堆中，而ab在常量池中
c==ab
//会直接使用常量池中的“ab”串，是javac在编译期的优化，结果在编译期确定为“ab”
String d = "a"+ "b";
//返回true，都在常量池中
ab == d;



```
特性：
* 常量池中的字符串仅是符号，第一次用到时才会变为对象
* 利用串池的机制，来避免重复创建字符串对象
* 字符串变量拼接的原理是StringBuilder（jdk1.8）
* 字符串常量拼接的原理是编译期优化
* 可以使用intern方法，主动将串池中还没有的字符串放入常量池中
jdk 1.8 尝试将字符串对象放入串池，如果没有则放入，如果有则不放入，然后将串池中的对象返回
jdk1.6 在串池中不存在串时会将字符串对象复制到串池中，
```java
String s = new String("a") + new String("b");
//返回false，s在堆中，而StringTable中没有“ab”
s == "ab"
//jdk1.8将字符串对象尝试放入串池中，如果有就不放入，没有则放入（不入池则s还是在堆中），同时将串池的对象返回，这是s已经在串池中
//jdk1.6将会拷贝字符串到常量池中，s还是在堆中
s2 = s.intern();
//StringTable中已经存在“ab”，返回true
s2 == "ab"
//StringTable中已经存在“ab”，返回true
s == "ab"
```
* jdk7之前StringTable是放在永久代中，在jdk8中StringTable是放在堆中的，放在堆中是为了保证在垃圾回收时StringTable能及时被垃圾回收，而不需要在full GC时才被回收

* 在jdk8中配置垃圾回收规则： -XX：+UseGCOverheadLimit （默认开启，可以使用-XX：-UseGCOverheadLimit关闭）  当jvm大量的时间花在垃圾回收（98%的时间）而只有少于2%的堆内存被垃圾回收，则jvm认为程序异常，jvm进程退出

* StringTable是可以被垃圾回收的

配置jvm打印垃圾回收的详情：
-Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc
### 6. 使用javap命令（将class文件转译为jvm虚拟机指令），结合jvm虚拟机能查看代码完整的之行流程

### 7. 堆 
* 存放对象的内存区域
* 线程共享的一块内存区域，虚拟机启动时创建，垃圾回收器管理的主要区域
新生代 分为一个eden区、两个survivor区
> eden 区，对象出生的区域
> survivor 经过minior gc之后存活的类会从eden区移动到survivor区
老年代 存放超过某一年龄代的对象，或是大对象直接分配到老年代
设置最小堆 -Xms
设置最大堆 -Xmx
堆内存溢出OutOfMemoryError
> 死循环导致堆内存溢出
> 内存大小不够导致内存溢出

JVM诊断工具(jdk自带的一些常用的诊断工具)
jps 查看java进程 `jps 【选项 】 [hostid]`
jmap -heap pid 检测某一时刻的堆内存使用情况
jconsole 图形化工具，查看堆内存占用，线程数量，类加载数量，cpu占用率
jstat 统计jvm内存信息  `jstat 【选项】 【进程ID】 [间隔时间 ] [查询次数]`
jinfo JVM参数查看和修改 `jinfo 【选项】【具体选项参数名】【进程ID】`
jstack JVM线程信息监控 `jstack [ 选项 ] [进程ID]远程IP`

VisualVM 通过安装各种插件实现对jvm的各种运行状态的实时监控
可以通过dump内存快照（堆转储）查看大对象占用内存的情况
arthas 阿里提供的jdk诊断工具，涵盖了几乎所有的jdk自带的诊断工具，同时可以很方便的查看死锁线程、修改应用中的某个类代码并动态编译和加载类到JVM
 * 启动： java -jar arthas-boot.jar
 * 查看全局信息（实时刷新）： dashboard
 * 查看线程状态： thread
 * 查看某一线程信息： tread  14 


### 8.可达性分析
GC Root根节点 --线程本地变量、静态变量本地方法栈变量
从GC root开始搜索，搜索到的对象为非垃圾对象、未搜索到的为垃圾对象，全部回收

### 9. 一个对象在堆中的生命流转周期（一般情况下）
> 1. 对象创建以后放在新生代的eden区
> 2. 当eden区的空间无法再分配内存给新的对象时，触发一次minior GC，通过可达性分析判断eden区的对象是否被引用，如果不被引用，则直接回收，如果被引用，放入survivor区，对象的分代年龄加1，eden区再次分配空间给新的对象
> 3. 当eden区再次无法分配内存给新的对象，再次触发minior GC，通过可达性分析判断eden区和已经分配了对象的一个survivor区的可回收对象，对非垃圾对象的分代年龄再次加1，放入到另一个空闲的survivor区
> 4. 当内存不足时重复步骤3
> 5. 当某次minior gc 回收垃圾后空闲的survivor无法存放下存活的对象，则需要进行senior GC ，将对象放入老年代
> 6. 动态年龄判断：当某次minior GC之后，存活对象的总大小大于一块survivor 区域大小的50%，则直接将这次minior GC存活下来的对象直接放入老年代中
分代GC的理论基础：大多数的对象都是朝生夕死
> 7. 当老年代无法存放更多的对象时，会进行一次full gc
> 8. 当进行了full gc后任然无法存放新产生的对象，则JVM会抛出OOM异常

### 10. arthas 阿里开源的jvm调优工具

### 11. Java虚拟机调优 -- 减少full gc的次数，减少STW（stop the world）
为什么会有stop the world：如果不停止用户线程，线程之行过程中可能会不断的出现引用的变化，类似于现实中你妈打扫垃圾的过程中你还在不断的丢垃圾


### 12. jvm参数设置 针对jdk8的版本，主要是对堆空间分代大小进行设置，对元空间大小进行设置，分代年龄进行设置等等

### 13. 对象的创建过程 jvm类加载子模块加载完类后对对象进行初始化，给对象的属性赋初始值--->执行底层的`<init>`方法，实际上是对对象的属性赋真实的值，和执行指定的类构造器方法 



### 14.visualVM jvm虚拟机诊断的图形化工具

### 15.阿里开源的JVM诊断工具 Arthas
> 使用java -jar arthas-boot.jar 启动
> dashboard查看全局的线程、内存占用信息、rumtime信息等

### 16.垃圾收集器

### 17.垃圾回收算法

### 18.对象的完整创建过程
> 类加载检查
> 类加载
> 分配内存（堆内存）
> 初始化属性的默认值（0值）
> 设置对象头（对象分代年龄、锁信息、gc标志等信息）
> 执行`<init>`方法（先对属性的真实值进行赋值，然后执行对象的构造方法）

### 19.对象的组成部分
> 对象头

    * 对象的hashcode
    * markword
      * 对象的锁状态
      * 对象当前使用的线程id
      * gc标志
    * 对象元数据指针（指向方法区（元空间））
    * 数组长度（数组对象才有）

> 对象数据
> 对齐填充  

### 20.jvm中的类加载器
* 引导类加载器，负责加载支持JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar,charsets.jar等
* 扩展类加载器：负责加载支撑JVM运行的位于jre的lib目录下的ext扩展目录中的jar包
* 应用程序类加载器：负责加载ClassPath路径下的类包，主要是加载自己编写的应用程序类
* 自定义加载器：负责加载用户自定义路径下的类包
  
```java
//jdk 8下的运行结果如注释
public class ClassLoaderTest {

    public static void main(String[] args) {
        //引导类加载器，返回null
        System.out.println(String.class.getClassLoader());
        //应用程序类加载器，jdk.internal.loader.ClassLoaders$AppClassLoader@251a69d7
        System.out.println(ClassLoaderTest.class.getClassLoader());
        //扩展类加载器 sun.misc.Launcher$ExtClassLoader@6d1e7682
        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());
        //引导类加载器  null
        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());
    }
}
```
```java
//jdk 17下的运行结果如注释
public class ClassLoaderTest {

    public static void main(String[] args) {
        //引导类加载器，返回null
        System.out.println(String.class.getClassLoader());
        //应用程序类加载器，jdk.internal.loader.ClassLoaders$AppClassLoader@251a69d7
        System.out.println(ClassLoaderTest.class.getClassLoader());
        //扩展类加载器 jdk.internal.loader.ClassLoaders$PlatformClassLoader@16b98e56
        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());
        //引导类加载器  null
        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());
    }
}
```

### 21.双亲委派机制
类加载器的亲子层级结构 
> 顶层父类 引导类加载器
> 扩展类加载器
> 应用程序类加载器
> 自定义类加载器

程序员自己写了一个类，会首先找到应用程序类加载器，应用程序类加载器会委托给扩展类加载器，而扩展类加载器会继续向上委托给引导类加载器，如果引导类加载器能加载，则加载该类，如果不能加载，扩展类加载器尝试加载，如果扩展类加载器无法加载，则应用程序类加载器尝试自己加载

这样做原因
保证jre的核心jar包加载的安全性，防止jre核心的被篡改
避免类的重复加载

### 22.tomcat的类加载机制
> 因为tomcat中会部署不同的web应用，如果A应用里使用了spring3，而B应用里用了spring4，则两个应用中可能存在大量的spring重复类，而且重复类之间可能存在不同的逻辑，如果使用双亲委派机制，则由于同一classpath路径下的类不会被重复加载，这样可能导致了应用中类加载存在问题
> tomcat自定义了WebAppClassLoader打破了双亲委派机制解决了上面的问题

### 23.指针碰撞与空闲列表
指针碰撞：这种情况将java堆的内存化为绝对规整的一块区域，所有用过的内存放在一边，空闲内存放在另一边，中间的指针作为分界点的指示器，分配内存就仅仅是吧指针指向空闲空间的那一边挪动一段与对象大小相等的距离
空闲列表：java堆内存不是绝对规整的，已经使用的内存与未使用的内存空间相互交错，虚拟机维护一个列表，记录那些内存时可以用的，在分配内存时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

### 24.对象分配内存时的兵法问题解决CAS与TLAB
在并发情况下，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况
解决办法：
* CAS （比较并交换）虚拟机采用cas配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理
* TLAB（thread local allocation buffer）本地线程分配缓冲，把内存分配的动作按照线程划分在不同的空间中进行，每个线程在java堆中预先分配一小块内存，通过-XX:+/-UserTLAB参数来设定，- XX:TLABSize 指定分配内存的大小

### 25. 对象占用内存的大小
> 使用jol-core包来分析对象的占用内存以及各个字节的含义
* 对象头（markword（32位4字节，64位8字节） + klass poniter（开启指针压缩占4字节，关闭指针压缩占8字节）+数组长度4字节（数组对象有值））
* 实例数据
* 对齐填充，保证对象的总的字节数是8的整数倍

### 26. 对象指针压缩
将对象的内存地址从8个字节压缩到4个字节
在jdk8下指针压缩默认开启
-XX:UseCompressedOops

### 27. 对象逃逸分析
分析对象的作用域，当一个对象在方法中被定义后，可能被外部方法所引用，例如作为调用参数传递到其他地方
```java
//返回了方法内部使用的对象导致逃逸  
 public ClassLoaderTest test(){
        return new ClassLoaderTest();
    }
```
开启逃逸分析
-XX:+DoEscapeAnalysis jdk7之后默认开启（-表示关闭）
开启逃逸分析+标量替换可以避免将局部变量分配在堆上，避免大量的gc

### 28.判断对象是否是垃圾的引用计数法有什么问题
当对象创建后每出现对对象的一次引用，引用计数加一，没失去一个引用，引用计数器减一，当计数器值为0时被判定为垃圾对象
> 出现了循环引用，导致引用计数引用永远都不会为0，出现内存泄露

### 29. GC可达性分析
将GC roots作为起点，从这些节点开始向下搜索引用的对象，找到的对象都被标记为非垃圾对象，其他对象都是垃圾对象
GC roots根节点：
> 线程栈的本地变量
> 静态变量
> 本地方法栈变量

### 30.什么样类能被回收
> 该类的所有对象实例都已经被回收，java堆中不存在该类的任何实例
> 加载该类的Classloader已经被回收
> 该类对应的java.lang.class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法

### jvm内部的各种垃圾回收算法
**标记清除算法**
将内存中的垃圾对象（或非垃圾对象）做标记，然后清除垃圾对象
> 造成大量的空间碎片
**标记-复制算法**
将内存分为两块，其中一块作为备用的复制算法，一块作为当前使用的算法，当需要垃圾回收时，标记当前使用的内存中的垃圾对象，将非垃圾对象复制到备用内存中，然后将已经使用的内存清空，备用内存切换当前成使用内存
> 空间利用率变低
> 当存在大量存活对象时，需要进行大量的内存复制操作，效率比较低下

**标记-整理算法**
标记存活对象，将剩余的垃圾对象清除，再将存活对象移动到内存空间的一端

### 31.分代收集理论
大部分对象都是朝生夕死

### 32.CMS垃圾收集器收集过程
* cms是老年代的垃圾收集器
> 并发的垃圾收集器
> 实现了让垃圾收集器与用户线程基本上能同时工作
> 使用标记-清除算法

步骤：
* 初始标记：暂停所有其他线程，记录GC roots直接引用的对象（速度很快）
* 并发标记：从GC roots直接关联的对象开始遍历整个对象的过程，耗时较长，用户线程不需要停止，可能导致已标记对象发生变化
* 重新标记：修正并发标记期间因为用户程序继续运行导致标记变动的一部分对象标记记录，停止用户线程（解决少标记的问题，即产生了新的对象（不能被回收）没有被标记的问题）
* 并发清理：开启用户线程，GC线程开始对未标记区域清理，这一阶段新增的对象会被标记为不做任何处理的对象
* 并发重置：重置本次GC过程的标记数据

### 34.CMS存在的问题
并发收集阶段再次触发full gc
> 在并发标记、并发清理的阶段如果用户线程产生了大量的对象，可能会触发full gc，则并发失败
> 此时会进入用户线程停止阶段，收集器切换到serial old垃圾收集器来回收垃圾

### 35.三色标记算法
黑色：垃圾收集器访问过的对象，它是安全存活的，如果有其他对象引用只想了黑色对象，无需重新扫描一遍.黑色对象不可能直接指向某个白色对象
灰色：表示对象已经被垃圾收集器访问，但这个对象上至少还有一个引用没有被扫描过
白色: 对象尚未被垃圾收集器访问过，可达性分析刚开始剪短，所有对象都是白色对象

### 36.G1垃圾回收器回收垃圾的过程
* 初始标记：暂停锁哟前台新城，并记录下gc roots直接能引用的对象，速度很快
* 并发标记：同cms的并发标记（不暂停用户线程）
* 最终标记：同cms，需要暂停用户线程
* 筛选回收：首先对各个region的回收价值成本进行排序，根据用户所期望的GC停顿STW时间（-XX:MaxGcPauseMills指定）来制定回收计划
回收使用的上方是标记复制算法，将一个region中存货的对象复制到另一个region中，不会像cms那样回收完因为很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有内存碎片

### 37.G1垃圾回收器最大停顿时间的实现
G1收集器后台维护一个有限列表，根据允许的收集时间，优先选择回收价值最大的region。这种使用region划分内存空间及有优先级的区域回收方式，保证g1在有限时间内可以尽可能提高收集效率

### 38.什么是内存泄漏，怎么快速排查
举例：在jvm中使用map进行缓存，当map越来越大，一直占用老年代空间，时间长了就导致full gc频繁，甚至导致OOM
使用jvm自带的jmap，jconsole、jstack等工具来排查
可以使用redis等缓存工具将jvm的缓存移动到redis数据库中

### 39。GC是什么时候做的
GC是需要代码运行到安全点或安全区域才能做
安全点指代码中的特定位置，线程运行到这些位置时他的状态是确定的，有以下几种安全点：
1. 方法执行返回之前
2. 调用某个方法之后
3. 抛出异常的位置
4. 循环的末尾
安全点是对正在执行的线程设定的，如果一个线程处于sleep状态或中断状态，它不能响应JVM的终端请求，再运行到安全点上。
安全区域：一段代码片段中，引用关系不会发生变化，这个区域内的任何地方开始GC都是安全的

### 40.字符串常量池
jdk7之后字符串常量池重永久代的运行时常量池分离到堆里
jdk8中，永久带被移除，运行时常量池在元空间，字符串常量池依然在堆里


### JMX
JMX(Java Management Extensions),Java管理扩展,是一个为应用程序植入管理功能的框架 

Notification
MBean之间的通信是必不可少的，Notification起到了在MBean之间沟通桥梁的作用。JMX 的通知由四部分组成：
1、Notification这个相当于一个信息包，封装了需要传递的信息
2、Notification broadcaster这个相当于一个广播器，把消息广播出。
3、Notification listener 这是一个监听器，用于监听广播出来的通知信息。
4、Notification filiter 这个一个过滤器，过滤掉不需要的通知。这个一般很少使用

