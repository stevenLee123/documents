# JVM
## JVM 基础概念及调优
### 1. JVM组成
> 类装载子系统 加载字节码文件放入方法区（元空间） （loading(加载) -> linking（链接） ->Intializtion（初始化））
> 运行时数据区（方法区、java堆、java栈（线程独享）、本地方法栈、程序计数器（线程独享））
> 字节码执行引擎 执行字节码、写程序计数器、执行垃圾收集线程进行垃圾回收

### 2. java栈（先进后出）
存放局部变量数据，分配给线程使用。一个方法对应一块栈帧内存空间
栈帧结构
> 局部变量 方法中的局部变量
> 操作数栈 临时存放JVM指令操作数据的栈
> 动态链接 符号引用转化为直接引用
> 方法出口 方法返回的位置
另外栈中的引用对象的真实地址在堆中
栈大小设置(-Xss 2MB)
栈溢出
> 出现没有出口的递归(栈帧过多)，抛出StackOverflowError
> 方法的执行超出了栈的大小（栈帧过大)，抛出StackOverflowError


### 3. 程序计数器
> 线程私有
每个线程都会分配一个程序计数器，存储线程当前执行的位置，当线程出现切换时，程序计数器用于，一旦指令执行，程序计数器将更新到下一条指令，另外在线程恢复执行时指示能当前线程之行的位置，程序计数器的值是由字节码执行引擎来修改的 保存当前线程执行指令的地址，

### 4. 方法区（元空间）
线程共享
虚拟机启动时创建
存放类的元数据信息、运行时常量值、静态变量（可能存在对象，在方法中存放的也是变量的引用，真正的变量放在堆中）、字段和方法数据，以及方法和构造函数的代码，包括用于类和实例初始化及接口初始化的特殊方法
方法区溢出，OutOfMemoryError
> 设置的元空间太小(jdk8) -XX:MaxMetaspaceSize=100M - XX: -UseCompressedOops 抛出OutOfMemoryError

### 5. 本地方法 （native修饰的方法，没有方法体，调用本地库）
> 线程私有

### 6. 使用javap命令（将class文件转译为jvm虚拟机指令），结合jvm虚拟机能查看代码完整的之行流程

### 7. 堆 
存放对象的内存区域
线程共享的一块内存区域，虚拟机启动时创建，垃圾回收器管理的主要区域
新生代 分为一个eden区、两个survivor区
> eden 区，对象出生的区域
> survivor 经过minior gc之后存活的类会从eden区移动到survivor区
老年代 存放超过某一年龄代的对象，或是大对象直接分配到老年代
设置最小堆 -Xms
设置最大堆 -Xmx
堆内存溢出OutOfMemoryError
> 死循环导致堆内存溢出
> 内存大小不够导致内存溢出

堆内存诊断工具
jps 查看java进程
jmap -heap pid 检测某一时刻的堆内存使用情况
jconsole 图形化工具


### 8.可达性分析
GC Root根节点 --线程本地变量、静态变量本地方法栈变量
从GC root开始搜索，搜索到的对象为非垃圾对象、未搜索到的为垃圾对象，全部回收

### 9. 一个对象在堆中的生命流转周期（一般情况下）
> 1. 对象创建以后放在新生代的eden区
> 2. 当eden区的空间无法再分配内存给新的对象时，触发一次minior GC，通过可达性分析判断eden区的对象是否被引用，如果不被引用，则直接回收，如果被引用，放入survivor区，对象的分代年龄加1，eden区再次分配空间给新的对象
> 3. 当eden区再次无法分配内存给新的对象，再次触发minior GC，通过可达性分析判断eden区和已经分配了对象的一个survivor区的可回收对象，对非垃圾对象的分代年龄再次加1，放入到另一个空闲的survivor区
> 4. 当内存不足时重复步骤3
> 5. 当某次minior gc 回收垃圾后空闲的survivor无法存放下存活的对象，则需要进行senior GC ，将对象放入老年代
> 6. 当老年代无法存放更多的对象时，会进行一次full gc
> 7. 当进行了full gc后任然无法存放新产生的对象，则JVM会抛出OOM异常

### 10. arthas 阿里开源的jvm调优工具

### 11. Java虚拟机调优 -- 减少full gc的次数，减少STW（stop the world）
为什么会有stop the world：如果不停止用户线程，线程之行过程中可能会不断的出现引用的变化，类似于现实中你妈打扫垃圾的过程中你还在不断的丢垃圾
动态年龄判断：当某次minior GC之后，存活对象的总大小大于一块survivor 区域大小的50%，则直接将这次minior GC存活下来的对象直接放入老年代中
分代GC的理论基础：大多数的对象都是朝生夕死

### 12. jvm参数设置 针对jdk8的版本，主要是对堆空间分代大小进行设置，对元空间大小进行设置，分代年龄进行设置等等

### 13. 对象的创建过程 jvm类加载子模块加载完类后对对象进行初始化，给对象的属性赋初始值--->执行底层的<init>方法，实际上是对对象的属性赋真实的值，和执行指定的类构造器方法 







